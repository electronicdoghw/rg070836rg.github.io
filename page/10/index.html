<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Chens">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="Chens">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chens">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/10/">





  <title>Chens</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chens</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/数据库/数据库实验集合 无答案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/数据库/数据库实验集合 无答案/" itemprop="url">据库实验集合 无答案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/datastructure/" itemprop="url" rel="index">
                    <span itemprop="name">datastructure</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#0 建表代码</p>
<h1 id="数据库10-8实验"><a href="#数据库10-8实验" class="headerlink" title="数据库10.8实验"></a>数据库10.8实验</h1><p>1  给表student列Sno增加检查长度为8位的约束并测试。<br>2 给表student列ssex的输入限定为男、女两个值并测试。<br>3  给表sc列grade的输入限定为0到100并测试。<br>4  给表sc的列增加外键约束并测试。<br>5  给表student增加列idcard表示身份证号并限定输入长度为18位，且最后一位奇数表示男，偶数表示女，这个值必须与ssex一致，并请测试。</p>
<h1 id="数据库10-15实验"><a href="#数据库10-15实验" class="headerlink" title="数据库10.15实验"></a>数据库10.15实验</h1><p>1.查询姓名为“丁鹏”的学号、性别、年龄、院系；<br>2.查询选修课程名为“数据库”课程的同学的学号、姓名、院系；<br>3.查询没被任何同学选的课程号及课程名；<br>4查询与“丁鹏”在同一院系的同学的学号、姓名、性别、院系；</p>
<h1 id="数据库10-22实验"><a href="#数据库10-22实验" class="headerlink" title="数据库10.22实验"></a>数据库10.22实验</h1><ol>
<li>查询所有被选的课程号及课程名，并将查询结果的列名用中文表示</li>
<li>查询年龄在19到21岁之间的同学的学号、姓名、性别，并按学号降序显示</li>
<li>查询既不是英语系、数学系，也不是计算机科学系的学生的学号、姓名和性别</li>
<li>查询所有姓王的学生的学号、姓名和性别，并按学号升序显示</li>
<li>查询所有不姓刘的学生姓名</li>
<li>查询名字中第2个字为”敏”字的学生的学号和姓名</li>
<li>查所有有成绩的学生学号和课程号</li>
</ol>
<h1 id="数据库10-29实验"><a href="#数据库10-29实验" class="headerlink" title="数据库10.29实验"></a>数据库10.29实验</h1><ol>
<li>创建登录名log1,口令为123456，缺省数据库为 student</li>
<li>创建用户wangyong，登录名为log1</li>
<li>创建角色student_role</li>
<li>为角色studen_role增加成员wangyong</li>
<li>授予角色studen_role在表student上的查询权限、在sc表上的插入权限</li>
<li>撤销角色studen_role在表student上的查询权限</li>
<li>删除角色、用户、登录名</li>
<li>创建视图v_1查询计算机系的所有学生学号、姓名、性别、年龄</li>
</ol>
<h1 id="数据库11-05实验"><a href="#数据库11-05实验" class="headerlink" title="数据库11.05实验"></a>数据库11.05实验</h1><ol>
<li>查询选修了课程的学生人数</li>
<li>计算1号课程的学生平均成绩</li>
<li>查询选修1号课程的学生最高分数、最低分数</li>
<li>列出每个课程号及相应的选课人数</li>
<li>查询选修了3门以上课程的学生学号</li>
<li>列出每门课程的最高分数、最低分数</li>
</ol>
<h1 id="数据库11-19实验"><a href="#数据库11-19实验" class="headerlink" title="数据库11.19实验"></a>数据库11.19实验</h1><hr>
<p>1.查询每一门课的间接先修课（即先修课的先修课）</p>
<ol start="2">
<li>查询每个学生的学号、姓名、选修的课程名及成绩</li>
<li>查询与“刘晨”在同一个系学习的学生。</li>
<li>查询选修了课程名为“信息系统”的学生学号和姓名</li>
<li>找出每个学生超过他选修课程平均成绩的课程号与课程名。</li>
</ol>
<h1 id="数据库11-26实验"><a href="#数据库11-26实验" class="headerlink" title="数据库11.26实验"></a>数据库11.26实验</h1><ol>
<li>列出每个系的男生人数、女生人数</li>
<li>查询选修了课程名为“信息系统”的学生学号和姓名</li>
<li>删除“王兰”所选的全部课程；</li>
<li>将“计算机”系的学生成绩全部清零；</li>
<li>查询没有选修1号课程的学生姓名。</li>
<li>查询选修了课程1或者选修了课程2的学生姓名。</li>
<li>查询既选修了课程1又选修了课程2的学生姓名</li>
<li>查询选修了课程1但没有又选修了课程2的学生姓名</li>
</ol>
<h1 id="数据库12-03实验"><a href="#数据库12-03实验" class="headerlink" title="数据库12.03实验"></a>数据库12.03实验</h1><ol>
<li>创建一个视图显示学号、姓名、数据结构和数据库原理课程的成绩</li>
<li>查询选修了全部课程的同学的学号、姓名</li>
<li>查询平均成绩在60分以上的同学的学号、姓名</li>
<li>查询平均成绩在全系平均成绩之上的同学的学号、姓名</li>
</ol>
<h1 id="数据库12-10实验"><a href="#数据库12-10实验" class="headerlink" title="数据库12.10实验"></a>数据库12.10实验</h1><ol>
<li>列出每门课程成绩都在90分以上的学生学号、姓名</li>
<li>查询没有选修数据结构课程的学生学号与姓名</li>
<li>查询既没有选修数据结构又没有选修数据库课程的学生学号与姓名</li>
<li>将所有选择“数据结构”课程的“计算机系”的学生成绩置为0分</li>
</ol>
<h1 id="数据库12-17实验"><a href="#数据库12-17实验" class="headerlink" title="数据库12.17实验"></a>数据库12.17实验</h1><p>（1）编写一个存储过程，可以查询指定系的学生的选课信息，列出学号、姓名、所在系、课程名和成绩等内容。调用该存储过程，测试执行结果。<br>（2）编写一个存储过程，返回指定课程的平均分。调用该存储过程，测试执行结果。<br>（3）编写一个存储过程可以查询指定系指定成绩等级的学生的选课信息，列出学号、姓名、所在系、课程名和成绩等内容。调用该存储过程，测试执行结果。（成绩等级为优、良、中、及格、不及格，其中成绩在90分到100分之间为‘优’，在80分到89分之间为‘良’，在70分到79分之间为‘中’，在60分到69分之间为‘及格’，在0分到59分之间为‘不及格’。）</p>
<h1 id="数据库12-24实验"><a href="#数据库12-24实验" class="headerlink" title="数据库12.24实验"></a>数据库12.24实验</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">实验十五：T-SQL(13)</span><br><span class="line"></span><br><span class="line">一个简化的图书馆信息管理系统，系统需求如下：</span><br><span class="line"></span><br><span class="line">1.图书馆有若干管理员librarian，各自有员工号empid、姓名name、身份证号idno等属性。</span><br><span class="line">2.图书馆有若干种图书booktype，每种图书有ISBN、名称title、出版社publisher、作者writers、价格price等属性，每种图书有唯一的ISBN号，同种图书可购入多本。</span><br><span class="line">3.每一本图书book有唯一标记bookid和种类booktype。</span><br><span class="line">4.读者reader在办理借书证后方可借阅，一个读者有唯一的借书证号cardno，还有姓名name、身份证号idno、住址address、注销标记logoff等。每个读者最多可借20本书，读者在注销前，须归还所有已借图书或报失。</span><br><span class="line">5.需处理以下基本业务：</span><br><span class="line">①借书：在某时刻某读者通过某管理员借阅某一本书。</span><br><span class="line">②还书：在某时刻通过某管理员归还某一本书，读者可以在借阅历史表中查阅自己以前所借的书。</span><br><span class="line">③报失：在某时刻某读者向某管理员报失某一本书；报失之后该书不能再借；每一次还书和报失记录都须对应某一次借书记录，且可由不同管理员处理。</span><br><span class="line">用E/R图建立该系统的概念模型如下：</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/rg070836rg/a4p2kyspc1t257mmjchii3pn/187670B02AA84575AC18BD628EFDF806.png" alt="187670B02AA84575AC18BD628EFDF806.png-23.7kB"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请按要求完成如下工作：</span><br><span class="line">1. 参考以上E-R图，设计关系模式，并确定各关系模式的属性应满足的数据完整性约束，然后定义表的参照完整性约束</span><br><span class="line">2. 根据借还书流程设计相应的触发器.</span><br></pre></td></tr></table></figure></p>
<p>0建库<br>1 librarian表<br>2 booktype表<br>3 book表<br>4 reader表<br>5 Record表<br>6 根据借还书流程设计相应的触发器</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/数据库/数据库作业合集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/数据库/数据库作业合集/" itemprop="url">数据库作业合集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库作业09-17"><a href="#数据库作业09-17" class="headerlink" title="数据库作业09.17"></a>数据库作业09.17</h1><hr>
<h2 id="一、选择题"><a href="#一、选择题" class="headerlink" title="一、选择题"></a>一、选择题</h2><pre><code>1.数据库系统是采用了数据库技术的计算机系统，数据库系统由数据库、数据库管理系统、应用系统和（C）。 
</code></pre><blockquote>
<p>段落引用</p>
</blockquote>
<p> A.系统分析员<br> B.程序员<br> C.数据库管理员<br> D.操作员  </p>
<pre><code>2.数据库（DB），数据库系统（DBS）和数据库管理系统（DBMS）之间的关系是（A）。 
</code></pre><p> A.DBS包括DB和DBMS<br> B.DBMS包括DB和DBS<br> C.DB包括DBS和DBMS<br> D.DBS就是DB，也就是DBMS  </p>
<pre><code>3.下面列出的数据库管理技术发展的三个阶段中，没有专门的软件对数据进行管理的是（D）。 
  I．人工管理阶段 II．文件系统阶段 III．数据库阶段 
</code></pre><p> A.I 和 II<br> B.只有 II<br> C.II 和 III<br> D.只有 I  </p>
<pre><code>4.下列四项中，不属于数据库系统特点的是（C）。 
</code></pre><p> A.数据共享<br> B.数据完整性<br> C.数据冗余度高<br> D.数据独立性高  </p>
<pre><code>5.数据库系统的数据独立性体现在（B）。 
</code></pre><p> A.不会因为数据的变化而影响到应用程序<br> B.不会因为数据存储结构与数据逻辑结构的变化而影响应用程序<br> C.不会因为存储策略的变化而影响存储结构<br> D.不会因为某些存储结构的变化而影响其他的存储结构  </p>
<pre><code>6.描述数据库全体数据的全局逻辑结构和特性的是（A）。 
</code></pre><p> A.模式<br> B.内模式<br> C.外模式<br> D.  </p>
<pre><code>7.要保证数据库的数据独立性，需要修改的是（C）。 
</code></pre><p> A.模式与外模式<br> B.模式与内模式<br> C.三级模式之间的两层映射<br> D.三层模式  </p>
<pre><code>8.要保证数据库的逻辑数据独立性，需要修改的是（A）。 
</code></pre><p> A.模式与外模式之间的映射<br> B.模式与内模式之间的映射<br> C.模式<br> D.三级模式  </p>
<pre><code>9.用户或应用程序看到的那部分局部逻辑结构和特征的描述是（C）模式。 
</code></pre><p> A.模式<br> B.物理模式<br> C.子模式<br> D.内模式  </p>
<pre><code>10.下述（D）不是DBA数据库管理员的职责。 
</code></pre><p> A.完整性约束说明<br> B.定义数据库模式<br> C.数据库安全<br> D.数据库管理系统设计  </p>
<pre><code>11.概念模型是现实世界的第一层抽象，这一类模型中最著名的模型是（B）。 
</code></pre><p> A.层次模型<br> B.关系模型<br> C.网状模型<br> D.实体-关系模型  </p>
<pre><code>12.区分不同实体的依据是（B）。 
</code></pre><p> A.名称<br> B.属性<br> C.对象<br> D.概念  </p>
<pre><code>13.关系数据模型是目前最重要的一种数据模型，它的三个要素分别是（B）。 
</code></pre><p> A.实体完整性、参照完整性、用户自定义完整性<br> B.数据结构、关系操作、完整性约束<br> C.数据增加、数据修改、数据查询<br> D.外模式、模式、内模式  </p>
<pre><code>14.在（A）中一个结点可以有多个双亲，结点之间可以有多种联系。 
</code></pre><p> A.网状模型<br> B.关系模型<br> C.层次模型<br> D.以上都有  </p>
<pre><code>15.（B）的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。 
</code></pre><p> A.网状模型<br> B.关系模型<br> C.层次模型<br> D.以上都有</p>
<h2 id="二、填空问答题"><a href="#二、填空问答题" class="headerlink" title="二、填空问答题"></a>二、填空问答题</h2><ol>
<li><p>数据库数据具有<code>长期的存储</code>、<code>有组织</code> 和 <code>共享</code>三个基本特点。 </p>
</li>
<li><p>试述数据、数据库、数据库系统、数据库管理系统的概念。</p>
<p> <code>数据</code>：描述事物的符号记录称为数据。数据的种类有文字、图形、图象、声音、正文等等。数据与其语义是不可分的。 </p>
<p> <code>数据库</code>：数据库是长期储存在计算机内、有组织的、可共享的数据集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。</p>
<p> <code>数据库系统</code>：数据库系统（DBS）是指在计算机系统中引入数据库后的系统构成。数据库系统由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员构成。</p>
<p> <code>数据库管理系统</code>：数据库管理系统(DBMS)是位于用户与操作系统之间的一层数据管理软件。用于科学地组织和存储数据、高效地获取和维护数据。DBMS主要功能包括数据定义功能、数据操纵功能、数据库的运行管理功能、数据库的建立和维护功能。</p>
</li>
<li><p>使用数据库系统有什么好处？</p>
<p> 使用数据库系统的好处是由数据库管理系统的特点或优点决定的。使用数据库系统的好处很多，例如可以大大提高应用开发的效率，方便用户的使用，减轻数据库系统管理人员维护的负担等。</p>
</li>
<li><p>数据库管理系统是数据库系统的一个重要组成部分，它的功能包括<code>数据定义功能</code>、<code>数据组织存储和管理数据操作功能</code>、<code>存储和管理数据操作功能</code>、<code>数据库的建立和维护功能</code>。 </p>
</li>
<li><p>数据库系统是指在计算机系统中引入数据库后的系统，一般由<code>数据库</code>、<code>数据库管理</code>、<code>应用系统</code>和<code>数据库构成</code>构成。 </p>
</li>
<li><p>数据库管理技术的发展是与计算机技术及其应用的发展联系在一起的，它经历了三个阶段：<code>人工管理</code>阶段，<code>文件系统</code>阶段和<code>数据库系统</code>阶段。 </p>
</li>
<li><p>DBMS还必须提供<code>数据的安全性</code>保护、<code>数据的完整性</code>检查、<code>并发控制</code>、<code>数据库恢复</code>等数据控制功能。 </p>
</li>
<li><p><em>书上p38第12题。</em></p>
<p> 学校中有若干系，每个系有若干班级和教研室，每个教研室有若干教员，其中有的教授和副教授每人各带若干研究生，每个班有若干学生，每个学生选修若干课程，每门课可由若干学生选修。请用E-R图画出此学校的概念模型。</p>
</li>
</ol>
<p><img src="http://static.zybuluo.com/rg070836rg/n0ufkkmhpjsoi3gbmruqzwiw/REIjmMS.png" alt="REIjmMS.png-31.3kB"></p>
<h1 id="数据库作业09-24"><a href="#数据库作业09-24" class="headerlink" title="数据库作业09.24"></a>数据库作业09.24</h1><p>标签（空格分隔）： 数据库作业</p>
<hr>
<p>##一、填空问答题</p>
<ol>
<li><p>数据模型的三个要素。</p>
<p> 数据模型通常由数据结构、数据操作和完整性约束三部分组成。 </p>
<p> ① <code>数据结构</code>：是所研究的对象类型的集合，是对系统的静态特性的描述。 </p>
<p> ② <code>数据操作</code>：是指对数据库中各种对象（型）的实例（值）允许进行的操作的集合，包括操作及有关的操作规则，是对系统动态特性的描述。 </p>
<p> ③ <code>数据的约束条件</code>：是完整性规则的集合，完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</p>
</li>
</ol>
<ol start="2">
<li><p>三级模式之间的两层映象保证了数据库系统中的数据能够具有较高的<code>逻辑独立性</code>和<code>物理独立性</code>。 </p>
</li>
<li><p>数据模型的三要素是指<code>数据结构</code>，<code>数据操作</code>，<code>完整性约束</code>。实际数据库系统中所支持的主要数据模型是<code>层次模型</code>，<code>网状模型</code>，<code>关系模型</code>。 </p>
</li>
<li><p>数据模型中的<code>数据结构</code>是对数据系统的静态特征描述，包括数据结构和数据间联系的描述，<code>数据操作</code>是对数据库系统的动态特征描述，是一组定义在数据上的操作，包括操作的涵义、操作符、运算规则及其语言等。 </p>
</li>
<li><p>试述数据库系统三级模式结构，这种结构的优点是什么？ </p>
<p> 数据库系统的三级模式结构由<code>外模式</code>、<code>概念模式</code>和<code>内模式</code>组成。</p>
<p> <code>外模式</code>，亦称子模式或用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p>
<p> <code>概念模式</code>，亦称逻辑模式，是数据库中全体数据的逻辑结构和特性的描述，是所有用户的公共数据视图。模式描述的是数据的全局逻辑结构。外模式涉及的是数据的局部的逻辑结构，通常是模式的子集。</p>
<p> <code>内模式</code>，亦称存储模式，是数据在数据库系统内部的表示，即对数据的物理结构和存储方式的描述。数据库系统的三级模式是对数据的三个抽象级别，它把数据的具体组织留给DBMS管理，使用户能逻辑抽象地处理数据，而不必关心数据在计算机中的表示和存储。</p>
<p> 为了能够在内部实现这三个抽象层次的联系和转换，数据库系统在这三级模式之间提供了两层映象：外模式／模式映象和模式／内模式映象。正是这两层映象保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。 </p>
</li>
<li><p>关系的完整性约束条件包括三大类：<code>实体完整性</code>、<code>参照完整性</code>和<code>用户定义的完整性</code>。 </p>
</li>
</ol>
<h1 id="数据库作业10-08"><a href="#数据库作业10-08" class="headerlink" title="数据库作业10.08"></a>数据库作业10.08</h1><p>标签（空格分隔）： 数据库作业</p>
<hr>
<p>第2章 关系数据库    </p>
<pre><code>1.下面的选项不是关系数据库基本特征的是（A）。 
</code></pre><p> A. 不同的列应有不同的数据类型<br> B. 不同的列应有不同的列名<br> C. 与行的次序无关<br> D. 与列的次序无关  </p>
<pre><code>2.一个关系只有一个（D ） 。 
</code></pre><p> A. 候选码<br> B.外码<br> C.超码<br> D.主码  </p>
<pre><code>3.关系模型中，一个码是（C）。 
</code></pre><p> A. 可以由多个任意属性组成<br> B. 至多由一个属性组成<br> C. 由一个或多个属性组成，其值能够惟一标识关系中一个元组<br> D. 以上都不是  </p>
<pre><code>4.现有如下关系：患者（患者编号，患者姓名，性别，出生日期，所在单位）医疗（患者编号，医生编号，医生姓名，诊断日期，诊断结果）其中，医疗关系中的外码是（A）。 
</code></pre><p> A.患者编号<br> B.患者姓名<br> C.患者编号和患者姓名<br> D.医生编号和患者编号  </p>
<pre><code>5.关系代数运算是以（c）为基础的运算 。 
</code></pre><p> A.关系运算<br> B.谓词演算<br> C.集合运算<br> D.代数运算  </p>
<pre><code>6.关系数据库管理系统应能实现的专门关系运算包括（B）。 
</code></pre><p> A.排序、索引、统计<br> B.选择、投影、连接<br> C.关联、更新、排序<br> D.显示、打印、制表  </p>
<pre><code>7.五种基本关系代数运算是（A）。 
</code></pre><p> A. ∪ － × σ π<br> B.∪ － σ π<br> C. ∪ ∩ × σ π<br> D.∪ ∩ σ π  </p>
<pre><code>8.关系数据库中的投影操作是指从关系中（B） 。 
</code></pre><p> A. 抽出特定记录<br> B.抽出特定字段<br> C.建立相应的影像<br> D.建立相应的图形  </p>
<pre><code>9.从一个数据库文件中取出满足某个条件的所有记录形成一个新的数据库文件的操作是（A）操作 。 
</code></pre><p> A.投影<br> B.连接<br> C.选择<br> D.复制  </p>
<pre><code>10.关系代数中的连接操作是由（B）操作组合而成 。 
</code></pre><p> A.选择和投影<br> B.选择和笛卡尔积<br> C.投影、选择、笛卡尔积<br> D.投影和笛卡尔积  </p>
<pre><code>11.一般情况下，当对关系R和S进行自然连接时，要求R和S含有一个或者多个共有的（C） 。 
</code></pre><p> A.记录<br> B.行<br> C.属性<br> D.元组  </p>
<pre><code>12.假设有关系R和S，关系代数表达式R－（R－S）表示的是（A）。 
</code></pre><p> A.R∩S<br> B.R∪S<br> C.R－S<br> D.R×S  </p>
<p>#数据库作业10.15</p>
<p>##第2章 关系数据库    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.试述关系模型的三个组成部分。 </span><br><span class="line"></span><br><span class="line">关系模型由关系数据结构、关系操作集合和关系完整性约束三部分组成。 </span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>2.关系数据模型中，二维表的列称为<code>属性</code>，二维表的行称为<code>记录或元组</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>3.等值连接与自然连接的区别是什么？ </p>
<pre><code>连接运算中有两种最为重要也最为常用的连接，一种是等值连接（equi-join），另一种是自然连接（Natural join）。 Θ为“＝”的连接运算称为等值连接。它是从关系R与S的笛卡尔积中选取A、B属性值相等的那些元组。即等值连接为： R A=B S = { tｒ tｓ| tｒ∈R ∧ tｓ∈S ∧ tｒ[A] = tｓ[B] } 自然连接（Natural join）是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且要在结果中把重复的属性去掉。即若R和S具有相同的属性组B，则自然连接可记作： R S = { tｒ tｓ| tｒ∈R ∧ tｓ∈S ∧ tｒ[B] = tｓ[B] } 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">4.关系代数运算中，专门的关系运算有`选择`，`投影`，`连接`。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.关系代数中，从两个关系中找出相同元组的运算称为`交`运算。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.R∞S表示R与S的`自然连接`。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7.设有学生关系：S（XH，XM，XB，NL，DP）。在这个关系中，XH表示学号，XM表示姓名，XB表示性别，NL表示年龄，DP表示系部。查询学生姓名和所在系的投影操作的关系运算式是`π2,5（S） 或 πXM,DP（S）`。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8.在“学生-选课-课程”数据库中的3个关系如下：</span><br><span class="line">S（S#，SNAME，SEX，AGE）；SC（S#，C#，GRADE）;</span><br><span class="line">C（C#，CNAME，TEACHER），</span><br><span class="line">查找选修“数据库技术”这门课程学生的学生名和成绩，若用关系代数表达式来表示为</span><br><span class="line">πSNAME,GRADE(S(SC(σCNAME=’数据库技术’?)))。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9.已知系（系编号，系名称，系主任，电话，地点）和学生（学号，姓名，性别，入学日期，专业，系编号）两个关系，系关系的主码是`系编号`，系关系的外码是`没有`，学生关系的主码是`学号`，学生关系的外码是`系编号`。</span><br></pre></td></tr></table></figure>
<h2 id="数据库作业10-22"><a href="#数据库作业10-22" class="headerlink" title="#数据库作业10.22"></a>#数据库作业10.22</h2><blockquote>
<p>   1.SQL语言是（<strong>B</strong>）的语言，容易学习 。 </p>
</blockquote>
<p> A. 过程化<br> B.非过程化<br> C.格式化<br> D.导航式  </p>
<blockquote>
<p> 2.在视图上不能完成的操作是（<strong>C</strong>） 。 </p>
</blockquote>
<p> A.更新视图<br> B.查询<br> C.在视图上定义新的表<br> D.在视图上定义新的视图  </p>
<blockquote>
<p>  3.SQL语言集数据查询、数据操纵、数据定义和数据控制功能于一体，其中，CREATE、DROP、ALTER语句是实现哪种功能（<strong>C</strong>）。 </p>
</blockquote>
<p> A.数据查询<br> B.数据操纵<br> C.数据定义<br> D.数据控制  </p>
<blockquote>
<p> 4.下列的SQL语句中，（<strong>D</strong>）不是数据定义语句。 </p>
</blockquote>
<p> A.CREATE TABLE<br> B.DROP VIEW<br> C.CREATE VIEW<br> D.GRANT  </p>
<blockquote>
<p> 5.若要删除数据库中已经存在的表S，可用（<strong>C</strong>）。 </p>
</blockquote>
<p> A.DELETE TABLE S<br> B.DELETE S<br> C.DROP TABLE S<br> D.DROP S  </p>
<blockquote>
<p> 6.若要在基本表S中增加一列CN（课程名），可用（<strong>C</strong>）。 </p>
</blockquote>
<p> A. ADD TABLE S（CN CHAR（８））<br> B. ADD TABLE S ALTER（CN CHAR（８））<br> C. ALTER TABLE S ADD（CN CHAR（８））<br> D. ALTER TABLE S （ADD CN CHAR（８））  </p>
<blockquote>
<p>  7.学生关系模式 S（ S＃，Sname，Sex，Age），S的属性分别表示学生的学号、姓名、性别、年龄。要在表S中删除一个属性“年龄”，可选用的SQL语句是（<strong>B</strong>）。 </p>
</blockquote>
<p> A.DELETE Age from S<br> B.ALTER TABLE S DROP Age<br> C.UPDATE S Age<br> D.ALTER TABLE S ‘Age’  </p>
<blockquote>
<p> 8.若用如下的SQL语句创建了一个表SC： CREATE TABLE SC （S# CHAR（6） NOT NULL，C# CHAR（3） NOT NULL，SCORE INTEGER，NOTE CHAR（20））；向SC表插入如下行时，（<strong>B</strong>）行可以被插入 。 </p>
</blockquote>
<p> A. （’201009’，’111’，60，必修）<br> B. （’200823’，’101’，NULL，NULL）<br> C. （NULL，’103’，80，’选修’）<br> D. （’201132’，NULL，86，’ ’）  </p>
<blockquote>
<p>  9.假设学生关系S（S＃，SNAME，SEX），课程关系C（C＃，CNAME），学生选课关系SC（S＃，C＃，GRADE）。要查询选修“Computer”课的男生姓名，将涉及到关系（<strong>D</strong>）。 </p>
</blockquote>
<p> A.S<br> B.S，SC<br> C.C，SC<br> D.S，C，SC  </p>
<h1 id="数据库作业10-29"><a href="#数据库作业10-29" class="headerlink" title="数据库作业10.29"></a>数据库作业10.29</h1><hr>
<p>1.以下（$D$）不属于实现数据库系统安全性的主要技术和方法。 </p>
<p> A.存取控制技术<br> B.视图技术<br> C.审计技术<br> D.出入机房登记和加防盗门  </p>
<p>2.SQL中的视图机制提高了数据库系统的（$D$）。 </p>
<p> A.完整性<br> B.并发控制<br> C.隔离性<br> D.安全性  </p>
<hr>
<p>3.SQL语言的GRANT和REVOKE语句主要是用来维护数据库的（$C$）。 </p>
<p> A.完整性<br> B.可靠性<br> C.安全性<br> D.一致性  </p>
<hr>
<p>4.在数据库的安全性控制中，授权的数据对象的（$A$），授权子系统就越灵活。 </p>
<p> A.范围越小<br> B.约束越细致<br> C.范围越大<br> D.约束范围大  </p>
<hr>
<p>5.找出下面SQL命令中的数据控制命令（$A$）。 </p>
<p> A.GRANT<br> B.COMMIT<br> C.UPDATE<br> D.SELECT  </p>
<hr>
<p>6.试述SQL语言的特点。</p>
<blockquote>
<ol>
<li>综合统一。 SQL语言集数据定义语言DDL、数据操纵语言DML、数据控制语言DCL的功能于一体。</li>
<li>高度非过程化。用SQL语言进行数据操作，只要提出“做什么”，而无须指明“怎么做”，因此无需了解存取路径，存取路径的选择以及SQL语句的操作过程由系统<pre><code>自动完成。
</code></pre></li>
<li>面向集合的操作方式。SQL语言采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。</li>
<li>以同一种语法结构提供两种使用方式。SQL语言既是自含式语言，又是嵌入式语言。作为自含式语言，它能够独立地用于联机交互的使用方式，也能够嵌入到高<pre><code>级语言程序中，供程序员设计程序时使用。
</code></pre></li>
<li>语言简捷，易学易用。</li>
</ol>
</blockquote>
<hr>
<p>7.SQL的中文全称是<strong>结构化查询语言</strong>。</p>
<hr>
<p>8.什么是基本表？什么是视图？两者的区别和联系是什么？</p>
<blockquote>
<p>基本表是本身独立存在的表，在SQL中一个关系就对应一个表。视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表。即数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。视图在概念上与基本表等同，用户可以如同基本表那样使用视图，可以在视图上再定义视图。</p>
</blockquote>
<hr>
<p>9.视图是从<strong>基本表或视图</strong>中导出的表，数据库中实际存放的是视图的<code>定义</code>。</p>
<hr>
<p>10.试述视图的优点。</p>
<blockquote>
<ol>
<li>视图能够简化用户的操作。 <ol start="2">
<li>视图使用户能以多种角度看待同一数据。 </li>
<li>视图对重构数据库提供了一定程度的逻辑独立性。 </li>
<li>视图能够对机密数据提供安全保护。 </li>
</ol>
</li>
</ol>
</blockquote>
<hr>
<p>11.数据库的安全性是指保护数据库以防止不合法的使用所造成的<code>数据泄漏</code>、<code>更改</code>或<code>破坏</code>。</p>
<hr>
<p>12.用户标识和鉴别的方法有很多种，而且在一个系统中往往是多种方法并举，以获得更强的安全性。常用的方法有通过输入<code>用户名</code>和<code>口令</code>来鉴别用户。</p>
<hr>
<p>13.<code>用户权限定义</code>和<code>合法权检查机制</code>一起组成了DBMS的安全子系统。</p>
<hr>
<p>14.用户权限是由两个要素组成的：<code>数据对象</code>和<code>操作类型</code>。</p>
<hr>
<p>15.在数据库系统中，定义存取权限称为授权。SQL语言用<code>GREAT</code>命令向用户授予对数据的操作权限，用<code>REVOKE</code>命令收回授予的权限。</p>
<h1 id="数据库作业11-19"><a href="#数据库作业11-19" class="headerlink" title="数据库作业11.19"></a>数据库作业11.19</h1><hr>
<p>1.完整性检查和控制的防范对象是（AC），防止它们进入数据库。安全性控制的防范对象是（BD），防止他们对数据库数据的存取。 </p>
<p> A.不合语义的数据<br> B.非法用户<br> C.不正确的数据<br> D.非法操作  </p>
<hr>
<pre><code>2.找出下面SQL命令中的数据控制命令（A）。 
</code></pre><p> A.GRANT<br> B.COMMIT<br> C.UPDATE<br> D.SELECT  </p>
<hr>
<pre><code>3.下述SQL命令中，允许用户定义新关系时，引用其他关系的主码作为外码的是（C）。 
</code></pre><p> A.INSERT<br> B.DELETE<br> C.REFERENCES<br> D. SELECT  </p>
<hr>
<pre><code>4.下述SQL命令的短语中，定义属性上约束条件的是（ABC）。 
</code></pre><p> A.NOT NULL短语<br> B.UNIQUE短语<br> C.CHECK短语<br> D.HAVING短语  </p>
<hr>
<p>5.数据库的安全性是指保护数据库以防止不合法的使用所造成的<strong>数据泄漏</strong>、<strong>更改</strong>或<strong>破坏</strong>。</p>
<p>6.计算机系统有三类安全性问题，即<strong>技术安全类</strong> 、<strong>管理安全类</strong>和 <strong>政策法律类</strong>。</p>
<p>7.用户标识和鉴别的方法有很多种，而且在一个系统中往往是多种方法并举，以获得更强的安全性。常用的方法有通过输入<strong>用户名</strong>和 <strong>口令</strong>来鉴别用户。</p>
<p>8.<strong>用户权限定义</strong> 和<strong>合法权检查机制</strong>一起组成了DBMS的安全子系统。</p>
<p>9.用户权限是由两个要素组成的：<strong>数据对象</strong> 和<strong>操作类型</strong> 。</p>
<p>10.在数据库系统中，定义存取权限称为<strong>授权</strong> 。SQL语言用<strong>GRANT</strong>语句向用户授予对数据的操作权限，用<strong>REVOKE</strong>语句收回授予的权限。</p>
<h1 id="数据库作业11-26"><a href="#数据库作业11-26" class="headerlink" title="数据库作业11.26"></a>数据库作业11.26</h1><h2 id="标签（空格分隔）：-数据库作业"><a href="#标签（空格分隔）：-数据库作业" class="headerlink" title="标签（空格分隔）： 数据库作业"></a>标签（空格分隔）： 数据库作业</h2><p>1 . 数据库的完整性是指数据的<strong>正确性</strong>和<strong>相容性</strong>。</p>
<hr>
<p>2.SQL标准使用了一系列概念来描述完整性，包括关系模型的<strong>实体完整性</strong> 、<strong>参照完整性</strong>和<strong>用户自定义的完整性</strong>。</p>
<hr>
<p>3.已知关系模式$R$的全部属性集$U=\begin{Bmatrix}<br>A,B,C,D,E,G<br>\end{Bmatrix}$及函数依赖集：$F=\begin{Bmatrix}<br>ABC,CA,BCD,ACDB,D EG,BE C，CG BD,CE AG<br>\end{Bmatrix}$<br>求属性集闭包$(BD)+$</p>
<hr>
<p>4．有关系模式$A（C，T，H，R，S）$，其中各属性的含义是：<br>C：课程 T：教员 H：上课时间 R：教室 S：学生。根据语义有如下函数依赖集：$F=\begin{Bmatrix}<br>C→T，（H，R）→C，（H，T）RC，（H，S）→R<br>\end{Bmatrix}$<br>求关系模式A的候选码</p>
<p><strong>答：（H，S）</strong></p>
<hr>
<p>5.已知关系模式$R&lt;U,F&gt;$，$U=\begin{Bmatrix}<br>A,B,C,D,E,G<br>\end{Bmatrix}$<br>$F=\begin{Bmatrix}<br>AB→C,D→EG,C→A,BE→C,BC→D,CG→BD,ACD→B,CE→AG<br>\end{Bmatrix}$<br>（1）.求出关系模式的候选码。<br>（2）.此关系模型最高属于哪级范式。</p>
<p><strong>答：<br>(1).Fm={AB→C,D→E,D→G,C→A,BE→C,BC→D,CG→D,CD→B,CE→G}<br>(2).AB,BC,BD,BE,CD,CE,CG<br>(3).3NF</strong></p>
<h1 id="数据库作业12-03"><a href="#数据库作业12-03" class="headerlink" title="数据库作业12.03"></a>数据库作业12.03</h1><hr>
<pre><code>1.规范化理论是关系数据库进行逻辑设计的理论依据，根据这个理论，关系数据库中的关系必须满足：一个属性都是(B)。 
</code></pre><p> A.长度不变的<br> B.不可分解的<br> C.互相关联的<br> D.互不相关的  </p>
<pre><code>2.已知关系模式R(A，B，C，D，E)及其上的函数依赖集合F＝{A→D，B→C ，E→A }，该关系模式的候选码是(B)。 
</code></pre><p> A.AB<br> B.BE<br> C.CD<br> D.DE  </p>
<pre><code>3.关系模式中，满足2NF的模式(B)。 
</code></pre><p> A.可能是1NF<br> B.必定是1NF<br> C.必定是3NF<br> D.必定是BCNF  </p>
<pre><code>4.关系模式R中的属性全是主属性，则R的最高范式必定是(C)。 
</code></pre><p> A.1NF<br> B.2NF<br> C.3NF<br> D.BCNF  </p>
<pre><code>5.消除了部分函数依赖的1NF的关系模式，必定是(B)。 
</code></pre><p> A.1NF<br> B.2NF<br> C.3NF<br> D.BCNF  </p>
<pre><code>6.关系模式的候选码可以有1个或多个，而主码有(C)。 
</code></pre><p> A.多个<br> B.0个<br> C.1个<br> D.1个或多个  </p>
<pre><code>7.候选码的属性可以有(D)。 
</code></pre><p> A.多个<br> B.0个<br> C.1个<br> D.1个或多个  </p>
<pre><code>8.关系数据库规范化是为了解决关系数据库中(B)的问题而引入的。 
</code></pre><p> A.提高查询速度<br> B.插入、删除异常和数据冗余<br> C.保证数据的安全性和完整性<br> D.  </p>
<pre><code>9.学生表(id，name，sex，age，depart_id，depart_name)，存在的函数依赖是id→{name，sex，age，depart_id};dept_id→dept_name，其满足(B)。
</code></pre><p> A.1NF<br> B.2NF<br> C.3NF<br> D.BCNF  </p>
<pre><code>10.设有关系模式R(S，D，M)，其函数依赖集：F＝{S→D，D→M}，则关系模式R的规范化程度最高达(B)。 
</code></pre><p> A.1NF<br> B.2NF<br> C.3NF<br> D.BCNF  </p>
<pre><code>11.设有关系模式R(A，B，C，D)，其数据依赖集：F＝{(A，B)→C，C→D}，则关系模式R的规范化程度最高达到(B)。 
</code></pre><p> A.1NF<br> B.2NF<br> C.3NF<br> D.BCNF  </p>
<p>12.已知关系模式R&lt;U,F&gt;，U={A,B,C,D,E,G}，F={AB→C,D→EG,C→A,BE→C,BC→D,CG→BD,ACD→B,CE→AG}<br>(1).求F的最小函数依赖集。<br>(2).求出关系模式的候选码。<br>(3).此关系模型最高属于哪级范式。</p>
<p><strong>答：<br>(1).Fm={AB→C,D→E,D→G,C→A,BE→C,BC→D,CG→D,CD→B,CE→G}<br>(2).AB,BC,BD,BE,CD,CE,CG<br>(3).3NF</strong></p>
<p>13.关系模型R(U，F)，U={ABCDEG}，F ={AD→E，AC→E，CB→G，BCD→AG，BD→A，AB→G,A→C}<br>(1).求此模型的最小函数依赖集。<br>(2).求出关系模式的候选码。<br>(3).此关系模型最高属于哪级范式。</p>
<p><strong>答：(1).Fm={A→E，BC→G，BD→A，A→C}<br>(2).BD<br>(3).R中每一个非主属性完全函数依赖于R的候选键BD；但C,G都传递依赖于R的候选键BD，也就是说，R满足2NF的要求，而不满足3NF的要求。此关系模型最高属于2NF。</strong></p>
<h1 id="数据库作业12-17"><a href="#数据库作业12-17" class="headerlink" title="数据库作业12.17"></a>数据库作业12.17</h1><hr>
<p>一、选择题<br>1.概念结构设计是整个数据库设计的关键，它通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的（<strong>B</strong>）。<br> A. 数据模型<br> B.概念模型<br> C.层次模型<br> D.关系模型 </p>
<p>2.数据库设计中，确定数据库存储结构，即确定关系、索引、聚簇、日志、备份等数据的存储安排和存储结构，这是数据库设计的（<strong>D</strong>）。<br> A. 需求分析阶段<br> B. 逻辑设计阶段<br> C. 概念设计阶段<br> D. 物理设计阶段 </p>
<p>3.数据库物理设计完成后，进入数据库实施阶段，下述工作中，（<strong>D</strong>）一般不属于实施阶段的工作。<br> A.建立库结构<br> B.系统调试<br> C.加载数据<br> D.扩充功能</p>
<p>4..数据库设计可划分为六个阶段，每个阶段都有自己的设计内容，“为哪些关系，在哪些属性上建什么样的索引”这一设计内容应该属于（<strong>C</strong>）设计阶段。<br> A.概念设计<br> B.逻辑设计<br> C.物理设计<br> D.全局设计</p>
<p>5.在关系数据库设计中，设计关系模式是数据库设计中（<strong>A</strong>）阶段的任务。<br> A.逻辑设计阶段<br> B.概念设计阶段<br> C.物理设计阶段<br> D.需求分析阶段  </p>
<p>6.在关系数据库设计中，对关系进行规范化处理，使关系达到一定的范式，例如达到3NF，这是（<strong>D</strong>）阶段的任务。<br> A.需求分析阶段<br> B.概念设计阶段<br> C.物理设计阶段<br> D.逻辑设计阶段  </p>
<p> 7.概念模型是现实世界的第一层抽象，这一类最著名的模型是（<strong>D</strong>） 。<br> A.层次模型<br> B.关系模型<br> C.网状模型<br> D.实体-关系模型 </p>
<p>8.在概念模型中的客观存在并可相互区别的事物称（<strong>A</strong>） 。<br> A.实体<br> B.元组<br> C.属性<br> D.节点</p>
<p>9.区分不同实体的依据是（<strong>B</strong>） 。<br> A.名称<br> B.属性<br> C.对象<br> D.概念 </p>
<p>二、填空题或简答题</p>
<p>1 .“三分技术，七分管理，十二分<strong>基础数据</strong>”是数据库建设的基本规律。 </p>
<p>2.数据库设计分为以下六个阶段<strong>需求分析</strong>、<strong>概念结构设计</strong>、<strong>逻辑结构设计</strong>、<strong>数据库物理设计</strong>、<strong>数据库实施</strong>和<strong>数据库运行和维护</strong>。 </p>
<p>3.数据字典的内容和作用是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">数据字典是系统中各类数据描述的集合。</span><br><span class="line">数据字典的内容通常包括：(1)数据项(2)数据结构(3)数据流(4)数据存储(5)处理过程五个部分。</span><br><span class="line">其中数据项是数据的最小组成单位,若干个数据项可以组成一个数据结构。数据字典通过对数据项和数据结构的定义来描述数据流和数据存储的逻辑内容。</span><br></pre></td></tr></table></figure></p>
<p>作用：数据字典是关于数据库中数据的描述,在需求分析阶段建立，是下一步进行概念设计的基础，并在数据库设计过程中不断修改、充实、完善。</p>
<p>4.用<strong>实体-联系方法（E-R）</strong> 方法来设计数据库的概念模型是数据库概念设计阶段广泛采用的方法。</p>
<p>5.客观存在并可相互区别的事物称为<strong>_实体_</strong> ，它可以是具体的人、事、物，也可以是抽象的概念或联系。 </p>
<p>6.什么是E-R图？构成E-R图的基本要素是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">E-R图为实体-联系图，提供了表示实体型、属性和联系的方法，用来描述现实世界的概念模型。构成E-R图的基本要素是实体型、属性和联系，其表示方法为：</span><br><span class="line">	实体型：用矩形表示，矩形框内写明实体名</span><br><span class="line">	属性：用椭圆形表示，并用无向边将其与相应的实体连接起来</span><br><span class="line">	联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1，1:n或m:n）</span><br></pre></td></tr></table></figure></p>
<h1 id="数据库作业12-24"><a href="#数据库作业12-24" class="headerlink" title="数据库作业12.24"></a>数据库作业12.24</h1><hr>
<h2 id="一、选择题-1"><a href="#一、选择题-1" class="headerlink" title="一、选择题"></a>一、选择题</h2><pre><code>1.公司有多个部门和多名职员，每个职员只能属于一个部门，一个部门可以有多名职员，从职员到部门的联系类形是(C) 。 
</code></pre><p> A.多对多<br> B.一对一<br> C.一对多<br> D.  无法确定</p>
<pre><code>2.数据流程图是用于数据库设计中(D)阶段的工具。 
</code></pre><p> A.概要设计<br> B.可行性分析<br> C.程序编码<br> D.需求分析 </p>
<pre><code>3.在数据库设计中，将ER图转换成关系数据模型的过程属于(B)。 
</code></pre><p> A.需求分析阶段<br> B.逻辑设计阶段<br> C.概念设计阶段<br> D.物理设计阶段 </p>
<pre><code>4.数据库设计的概念设计阶段，表示概念结构的常用方法和描述工具(C)。 
</code></pre><p> A. 层次分析法和层次结构图<br> B. 数据流程分析法和数据流程图<br> C. 实体联系方法 (ER图)<br> D.结构分析法和模块结构图 </p>
<pre><code>5.在关系数据库设计中，设计关系模式是数据库设计中(A)阶段的任务 。 
</code></pre><p> A.逻辑设计阶段<br> B.概念设计阶段<br> C.物理设计阶段<br> D.需求分析阶段  </p>
<pre><code>6.关系数据库的规范化理论主要解决的问题是(A)。 
</code></pre><p> A. 如何构造合适的数据逻辑结构<br> B. 如何构造合适的数据物理结构<br> C. 如何构造合适的应用程序界面<br> D. 如何控制不同用户的数据操作权限  </p>
<pre><code>7.从ER图导出关系模型时，如果实体间的联系是M：N的，下列说法中正确的是(C)。 
</code></pre><p> A.将N方码和联系的属性纳入M方的属性中<br> B.将M方码和联系的属性纳入N方的属性中<br> C.增加一个关系表示联系，其中纳入M方和N方的码<br> D.在M方属性和N方属性中均增加一个表示级别的属性  </p>
<pre><code>8.在ER模型中，如果有3个不同的实体型，3个M：N联系，根据ER模型转换为关系模型的规则，转换为关系的数目是(C)。 
</code></pre><p> A.4<br> B.5<br> C.6<br> D.7 </p>
<p>##二、填空题或简答题<br>1.唯一标识实体的属性集称为<code>码</code> 。</p>
<p>2.实体之间的联系有<code>1对1</code>、<code>1对多</code>、<code>多对多</code>三种。</p>
<p>3.什么是数据库的逻辑结构设计？试述其设计步骤。</p>
<pre><code>数据库的逻辑结构设计就是把概念结构设计阶段设计好的基本E-R图转换为与选用的DBMS产品所支持的数据模型相符合的逻辑结构。设计步骤为： (1)将概念结构
转换为一般的关系、网状、层次模型；(2)将转换来的关系、网状、层次模型向特定DBMS支持下的数据模型转换；(3)对数据模型进行优化。 
</code></pre><p>4.如果两个实体之间具有M：N联系，则将它们转换为关系模型的结果是<code>3</code>个关系。</p>
<p>5.ER模型是对现实世界的一种抽象，它的主要成分是<code>实体型</code> 、联系和 <code>属性</code>。 </p>
<p>6.各分E-R图之间的冲突主要有三类：<code>属性突出</code> 、<code>命名冲突</code>和<code>约束冲突</code>。</p>
<p>7.在E-R模型向关系模型转换时，M：N的联系转换为关系模式时，其码包括<code>m方和n方各自的码</code> 。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/数据库/数据库作业合集 无答案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/数据库/数据库作业合集 无答案/" itemprop="url">据库作业合集 无答案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库作业09-17"><a href="#数据库作业09-17" class="headerlink" title="数据库作业09.17"></a>数据库作业09.17</h1><hr>
<h2 id="一、选择题"><a href="#一、选择题" class="headerlink" title="一、选择题"></a>一、选择题</h2><pre><code>1.数据库系统是采用了数据库技术的计算机系统，数据库系统由数据库、数据库管理系统、应用系统和（  ）。 
</code></pre><p> A.系统分析员<br> B.程序员<br> C.数据库管理员<br> D.操作员  </p>
<pre><code>2.数据库（DB），数据库系统（DBS）和数据库管理系统（DBMS）之间的关系是（  ）。 
</code></pre><p> A.DBS包括DB和DBMS<br> B.DBMS包括DB和DBS<br> C.DB包括DBS和DBMS<br> D.DBS就是DB，也就是DBMS  </p>
<pre><code>3.下面列出的数据库管理技术发展的三个阶段中，没有专门的软件对数据进行管理的是（    ）。 
  I．人工管理阶段 II．文件系统阶段 III．数据库阶段 
</code></pre><p> A.I 和 II<br> B.只有 II<br> C.II 和 III<br> D.只有 I  </p>
<pre><code>4.下列四项中，不属于数据库系统特点的是（   ）。 
</code></pre><p> A.数据共享<br> B.数据完整性<br> C.数据冗余度高<br> D.数据独立性高  </p>
<pre><code>5.数据库系统的数据独立性体现在（   ）。 
</code></pre><p> A.不会因为数据的变化而影响到应用程序<br> B.不会因为数据存储结构与数据逻辑结构的变化而影响应用程序<br> C.不会因为存储策略的变化而影响存储结构<br> D.不会因为某些存储结构的变化而影响其他的存储结构  </p>
<pre><code>6.描述数据库全体数据的全局逻辑结构和特性的是（   ）。 
</code></pre><p> A.模式<br> B.内模式<br> C.外模式<br> D.  </p>
<pre><code>7.要保证数据库的数据独立性，需要修改的是（   ）。 
</code></pre><p> A.模式与外模式<br> B.模式与内模式<br> C.三级模式之间的两层映射<br> D.三层模式  </p>
<pre><code>8.要保证数据库的逻辑数据独立性，需要修改的是（   ）。 
</code></pre><p> A.模式与外模式之间的映射<br> B.模式与内模式之间的映射<br> C.模式<br> D.三级模式  </p>
<pre><code>9.用户或应用程序看到的那部分局部逻辑结构和特征的描述是（   ）模式。 
</code></pre><p> A.模式<br> B.物理模式<br> C.子模式<br> D.内模式  </p>
<pre><code>10.下述（    ）不是DBA数据库管理员的职责。 
</code></pre><p> A.完整性约束说明<br> B.定义数据库模式<br> C.数据库安全<br> D.数据库管理系统设计  </p>
<pre><code>11.概念模型是现实世界的第一层抽象，这一类模型中最著名的模型是（  ）。 
</code></pre><p> A.层次模型<br> B.关系模型<br> C.网状模型<br> D.实体-关系模型  </p>
<pre><code>12.区分不同实体的依据是（   ）。 
</code></pre><p> A.名称<br> B.属性<br> C.对象<br> D.概念  </p>
<pre><code>13.关系数据模型是目前最重要的一种数据模型，它的三个要素分别是（  ）。 
</code></pre><p> A.实体完整性、参照完整性、用户自定义完整性<br> B.数据结构、关系操作、完整性约束<br> C.数据增加、数据修改、数据查询<br> D.外模式、模式、内模式  </p>
<pre><code>14.在（  ）中一个结点可以有多个双亲，结点之间可以有多种联系。 
</code></pre><p> A.网状模型<br> B.关系模型<br> C.层次模型<br> D.以上都有  </p>
<pre><code>15.（   ）的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。 
</code></pre><p> A.网状模型<br> B.关系模型<br> C.层次模型<br> D.以上都有</p>
<h2 id="二、填空问答题"><a href="#二、填空问答题" class="headerlink" title="二、填空问答题"></a>二、填空问答题</h2><ol>
<li><p>数据库数据具有<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>三个基本特点。 </p>
</li>
<li><p>试述数据、数据库、数据库系统、数据库管理系统的概念。</p>
<p> <code>数据</code>：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>____</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p> <code>数据库</code>：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>____</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p> <code>数据库系统</code>：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>____</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p> <code>数据库管理系统</code>：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>___</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
</li>
<li><p>使用数据库系统有什么好处？</p>
</li>
</ol>
<ol start="4">
<li><p>数据库管理系统是数据库系统的一个重要组成部分，它的功能包括<strong><strong><strong><strong>___</strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。 </p>
</li>
<li><p>数据库系统是指在计算机系统中引入数据库后的系统，一般由<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>构成。 </p>
</li>
<li><p>数据库管理技术的发展是与计算机技术及其应用的发展联系在一起的，它经历了三个阶段：<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>阶段，<strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong>阶段和<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>阶段。 </p>
</li>
<li><p>DBMS还必须提供<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>保护、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>检查、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>等数据控制功能。 </p>
</li>
<li><p><em>书上p38第12题。</em></p>
<p> 学校中有若干系，每个系有若干班级和教研室，每个教研室有若干教员，其中有的教授和副教授每人各带若干研究生，每个班有若干学生，每个学生选修若干课程，每门课可由若干学生选修。请用E-R图画出此学校的概念模型。</p>
</li>
</ol>
<h1 id="数据库作业09-24"><a href="#数据库作业09-24" class="headerlink" title="数据库作业09.24"></a>数据库作业09.24</h1><hr>
<p>##一、填空问答题</p>
<ol>
<li><p>数据模型的三个要素。</p>
<p> 数据模型通常由数据结构、数据操作和完整性约束三部分组成。 </p>
<p> ① <code>数据结构</code>：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> ② <code>数据操作</code>：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>____</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> ③ <code>数据的约束条件</code>：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>___</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
</li>
</ol>
<ol start="2">
<li><p>三级模式之间的两层映象保证了数据库系统中的数据能够具有较高的<strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong>。 </p>
</li>
<li><p>数据模型的三要素是指<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>，<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>，<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。实际数据库系统中所支持的主要数据模型是<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>，<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>，<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。 </p>
</li>
<li><p>数据模型中的<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>是对数据系统的静态特征描述，包括数据结构和数据间联系的描述，<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>是对数据库系统的动态特征描述，是一组定义在数据上的操作，包括操作的涵义、操作符、运算规则及其语言等。 </p>
</li>
<li><p>试述数据库系统三级模式结构，这种结构的优点是什么？ </p>
<p> 数据库系统的三级模式结构由<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>组成。</p>
</li>
</ol>
<ol start="6">
<li>关系的完整性约束条件包括三大类：<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。 </li>
</ol>
<h1 id="数据库作业10-08"><a href="#数据库作业10-08" class="headerlink" title="数据库作业10.08"></a>数据库作业10.08</h1><hr>
<p>第2章 关系数据库    </p>
<pre><code>1.下面的选项不是关系数据库基本特征的是（      ）。 
</code></pre><p> A. 不同的列应有不同的数据类型<br> B. 不同的列应有不同的列名<br> C. 与行的次序无关<br> D. 与列的次序无关  </p>
<pre><code>2.一个关系只有一个（       ） 。 
</code></pre><p> A. 候选码<br> B.外码<br> C.超码<br> D.主码  </p>
<pre><code>3.关系模型中，一个码是（         ）。 
</code></pre><p> A. 可以由多个任意属性组成<br> B. 至多由一个属性组成<br> C. 由一个或多个属性组成，其值能够惟一标识关系中一个元组<br> D. 以上都不是  </p>
<pre><code>4.现有如下关系：患者（患者编号，患者姓名，性别，出生日期，所在单位）医疗（患者编号，医生编号，医生姓名，诊断日期，诊断结果）其中，医疗关系中的外码是（         ）。 
</code></pre><p> A.患者编号<br> B.患者姓名<br> C.患者编号和患者姓名<br> D.医生编号和患者编号  </p>
<pre><code>5.关系代数运算是以（       ）为基础的运算 。 
</code></pre><p> A.关系运算<br> B.谓词演算<br> C.集合运算<br> D.代数运算  </p>
<pre><code>6.关系数据库管理系统应能实现的专门关系运算包括（         ）。 
</code></pre><p> A.排序、索引、统计<br> B.选择、投影、连接<br> C.关联、更新、排序<br> D.显示、打印、制表  </p>
<pre><code>7.五种基本关系代数运算是（          ）。 
</code></pre><p> A. ∪ － × σ π<br> B.∪ － σ π<br> C. ∪ ∩ × σ π<br> D.∪ ∩ σ π  </p>
<pre><code>8.关系数据库中的投影操作是指从关系中（           ） 。 
</code></pre><p> A. 抽出特定记录<br> B.抽出特定字段<br> C.建立相应的影像<br> D.建立相应的图形  </p>
<pre><code>9.从一个数据库文件中取出满足某个条件的所有记录形成一个新的数据库文件的操作是（          ）操作 。 
</code></pre><p> A.投影<br> B.连接<br> C.选择<br> D.复制  </p>
<pre><code>10.关系代数中的连接操作是由（      ）操作组合而成 。 
</code></pre><p> A.选择和投影<br> B.选择和笛卡尔积<br> C.投影、选择、笛卡尔积<br> D.投影和笛卡尔积  </p>
<pre><code>11.一般情况下，当对关系R和S进行自然连接时，要求R和S含有一个或者多个共有的（   ） 。 
</code></pre><p> A.记录<br> B.行<br> C.属性<br> D.元组  </p>
<pre><code>12.假设有关系R和S，关系代数表达式R－（R－S）表示的是（    ）。 
</code></pre><p> A.R∩S<br> B.R∪S<br> C.R－S<br> D.R×S  </p>
<p>#数据库作业10.15</p>
<p>##第2章 关系数据库    </p>
<p>1.试述关系模型的三个组成部分。 </p>
<p>2.关系数据模型中，二维表的列称为<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>，二维表的行称为<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。</p>
<p>3.等值连接与自然连接的区别是什么？ </p>
<p>4.关系代数运算中，专门的关系运算有<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>，<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>，<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。</p>
<p>5.关系代数中，从两个关系中找出相同元组的运算称为<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>运算。 </p>
<p>6.R∞S表示R与S的<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。 </p>
<p>7.设有学生关系：S（XH，XM，XB，NL，DP）。在这个关系中，XH表示学号，XM表示姓名，XB表示性别，NL表示年龄，DP表示系部。查询学生姓名和所在系的投影操作的关系运算式是<strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong>。 </p>
<p>8.在“学生-选课-课程”数据库中的3个关系如下：<br>S（S#，SNAME，SEX，AGE）；SC（S#，C#，GRADE）;<br>C（C#，CNAME，TEACHER），<br>查找选修“数据库技术”这门课程学生的学生名和成绩，若用关系代数表达式来表示为<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>___</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>9.已知系（系编号，系名称，系主任，电话，地点）和学生（学号，姓名，性别，入学日期，专业，系编号）两个关系，系关系的主码是<strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong>，系关系的外码是<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>，学生关系的主码是<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>，学生关系的外码是<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。 </p>
<h2 id="数据库作业10-22"><a href="#数据库作业10-22" class="headerlink" title="#数据库作业10.22"></a>#数据库作业10.22</h2><blockquote>
<p>   1.SQL语言是（          ）的语言，容易学习 。 </p>
</blockquote>
<p> A. 过程化<br> B.非过程化<br> C.格式化<br> D.导航式  </p>
<blockquote>
<p> 2.在视图上不能完成的操作是（          ） 。 </p>
</blockquote>
<p> A.更新视图<br> B.查询<br> C.在视图上定义新的表<br> D.在视图上定义新的视图  </p>
<blockquote>
<p>  3.SQL语言集数据查询、数据操纵、数据定义和数据控制功能于一体，其中，CREATE、DROP、ALTER语句是实现哪种功能（          ）。 </p>
</blockquote>
<p> A.数据查询<br> B.数据操纵<br> C.数据定义<br> D.数据控制  </p>
<blockquote>
<p> 4.下列的SQL语句中，（          ）不是数据定义语句。 </p>
</blockquote>
<p> A.CREATE TABLE<br> B.DROP VIEW<br> C.CREATE VIEW<br> D.GRANT  </p>
<blockquote>
<p> 5.若要删除数据库中已经存在的表S，可用（          ）。 </p>
</blockquote>
<p> A.DELETE TABLE S<br> B.DELETE S<br> C.DROP TABLE S<br> D.DROP S  </p>
<blockquote>
<p> 6.若要在基本表S中增加一列CN（课程名），可用（          ）。 </p>
</blockquote>
<p> A. ADD TABLE S（CN CHAR（８））<br> B. ADD TABLE S ALTER（CN CHAR（８））<br> C. ALTER TABLE S ADD（CN CHAR（８））<br> D. ALTER TABLE S （ADD CN CHAR（８））  </p>
<blockquote>
<p>  7.学生关系模式 S（ S＃，Sname，Sex，Age），S的属性分别表示学生的学号、姓名、性别、年龄。要在表S中删除一个属性“年龄”，可选用的SQL语句是（          ）。 </p>
</blockquote>
<p> A.DELETE Age from S<br> B.ALTER TABLE S DROP Age<br> C.UPDATE S Age<br> D.ALTER TABLE S ‘Age’  </p>
<blockquote>
<p> 8.若用如下的SQL语句创建了一个表SC： CREATE TABLE SC （S# CHAR（6） NOT NULL，C# CHAR（3） NOT NULL，SCORE INTEGER，NOTE CHAR（20））；向SC表插入如下行时，（          ）行可以被插入 。 </p>
</blockquote>
<p> A. （’201009’，’111’，60，必修）<br> B. （’200823’，’101’，NULL，NULL）<br> C. （NULL，’103’，80，’选修’）<br> D. （’201132’，NULL，86，’ ’）  </p>
<blockquote>
<p>  9.假设学生关系S（S＃，SNAME，SEX），课程关系C（C＃，CNAME），学生选课关系SC（S＃，C＃，GRADE）。要查询选修“Computer”课的男生姓名，将涉及到关系（          ）。 </p>
</blockquote>
<p> A.S<br> B.S，SC<br> C.C，SC<br> D.S，C，SC  </p>
<h1 id="数据库作业10-29"><a href="#数据库作业10-29" class="headerlink" title="数据库作业10.29"></a>数据库作业10.29</h1><hr>
<p>1.以下（          ）不属于实现数据库系统安全性的主要技术和方法。 </p>
<p> A.存取控制技术<br> B.视图技术<br> C.审计技术<br> D.出入机房登记和加防盗门  </p>
<p>2.SQL中的视图机制提高了数据库系统的（          ）。 </p>
<p> A.完整性<br> B.并发控制<br> C.隔离性<br> D.安全性  </p>
<hr>
<p>3.SQL语言的GRANT和REVOKE语句主要是用来维护数据库的（          ）。 </p>
<p> A.完整性<br> B.可靠性<br> C.安全性<br> D.一致性  </p>
<hr>
<p>4.在数据库的安全性控制中，授权的数据对象的（          ），授权子系统就越灵活。 </p>
<p> A.范围越小<br> B.约束越细致<br> C.范围越大<br> D.约束范围大  </p>
<hr>
<p>5.找出下面SQL命令中的数据控制命令（          ）。 </p>
<p> A.GRANT<br> B.COMMIT<br> C.UPDATE<br> D.SELECT  </p>
<hr>
<p>6.试述SQL语言的特点。</p>
<hr>
<p>7.SQL的中文全称是<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。</p>
<hr>
<p>8.什么是基本表？什么是视图？两者的区别和联系是什么？</p>
<hr>
<p>9.视图是从<strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong>中导出的表，数据库中实际存放的是视图的<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。</p>
<hr>
<p>10.试述视图的优点。</p>
<hr>
<p>11.数据库的安全性是指保护数据库以防止不合法的使用所造成的<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>或<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。</p>
<hr>
<p>12.用户标识和鉴别的方法有很多种，而且在一个系统中往往是多种方法并举，以获得更强的安全性。常用的方法有通过输入<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>来鉴别用户。</p>
<hr>
<p>13.<strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong>一起组成了DBMS的安全子系统。</p>
<hr>
<p>14.用户权限是由两个要素组成的：<strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong>。</p>
<hr>
<p>15.在数据库系统中，定义存取权限称为授权。SQL语言用<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>命令向用户授予对数据的操作权限，用<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>命令收回授予的权限。</p>
<h1 id="数据库作业11-19"><a href="#数据库作业11-19" class="headerlink" title="数据库作业11.19"></a>数据库作业11.19</h1><hr>
<p>1.完整性检查和控制的防范对象是（                       ），防止它们进入数据库。安全性控制的防范对象是（                       ），防止他们对数据库数据的存取。 </p>
<p> A.不合语义的数据<br> B.非法用户<br> C.不正确的数据<br> D.非法操作  </p>
<hr>
<pre><code>2.找出下面SQL命令中的数据控制命令（        ）。 
</code></pre><p> A.GRANT<br> B.COMMIT<br> C.UPDATE<br> D.SELECT  </p>
<hr>
<pre><code>3.下述SQL命令中，允许用户定义新关系时，引用其他关系的主码作为外码的是（    ）。 
</code></pre><p> A.INSERT<br> B.DELETE<br> C.REFERENCES<br> D. SELECT  </p>
<hr>
<pre><code>4.下述SQL命令的短语中，定义属性上约束条件的是（      ）。 
</code></pre><p> A.NOT NULL短语<br> B.UNIQUE短语<br> C.CHECK短语<br> D.HAVING短语  </p>
<hr>
<p>5.数据库的安全性是指保护数据库以防止不合法的使用所造成的<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>或<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。</p>
<p>6.计算机系统有三类安全性问题，即<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong> 、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>和 <strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。</p>
<p>7.用户标识和鉴别的方法有很多种，而且在一个系统中往往是多种方法并举，以获得更强的安全性。常用的方法有通过输入<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>和 <strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>来鉴别用户。</p>
<p>8.<strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong>一起组成了DBMS的安全子系统。</p>
<p>9.用户权限是由两个要素组成的：<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong> 。</p>
<p>10.在数据库系统中，定义存取权限称为<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong> 。SQL语言用<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>语句向用户授予对数据的操作权限，用<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>语句收回授予的权限。</p>
<h1 id="数据库作业11-26"><a href="#数据库作业11-26" class="headerlink" title="数据库作业11.26"></a>数据库作业11.26</h1><hr>
<p>1 . 数据库的完整性是指数据的<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。</p>
<hr>
<p>2.SQL标准使用了一系列概念来描述完整性，包括关系模型的<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong> 、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。</p>
<hr>
<p>3.已知关系模式$R$的全部属性集$U=\begin{Bmatrix}<br>A,B,C,D,E,G<br>\end{Bmatrix}$及函数依赖集：$F=\begin{Bmatrix}<br>ABC,CA,BCD,ACDB,D EG,BE C，CG BD,CE AG<br>\end{Bmatrix}$<br>求属性集闭包$(BD)+$</p>
<hr>
<p>4．有关系模式$A（C，T，H，R，S）$，其中各属性的含义是：<br>C：课程 T：教员 H：上课时间 R：教室 S：学生。根据语义有如下函数依赖集：$F=\begin{Bmatrix}<br>C→T，（H，R）→C，（H，T）RC，（H，S）→R<br>\end{Bmatrix}$<br>求关系模式A的候选码</p>
<hr>
<p>5.已知关系模式$R&lt;U,F&gt;$，$U=\begin{Bmatrix}<br>A,B,C,D,E,G<br>\end{Bmatrix}$<br>$F=\begin{Bmatrix}<br>AB→C,D→EG,C→A,BE→C,BC→D,CG→BD,ACD→B,CE→AG<br>\end{Bmatrix}$<br>（1）.求出关系模式的候选码。<br>（2）.此关系模型最高属于哪级范式。</p>
<h1 id="数据库作业12-03"><a href="#数据库作业12-03" class="headerlink" title="数据库作业12.03"></a>数据库作业12.03</h1><hr>
<pre><code>1.规范化理论是关系数据库进行逻辑设计的理论依据，根据这个理论，关系数据库中的关系必须满足：一个属性都是(    )。 
</code></pre><p> A.长度不变的<br> B.不可分解的<br> C.互相关联的<br> D.互不相关的  </p>
<pre><code>2.已知关系模式R(A，B，C，D，E)及其上的函数依赖集合F＝{A→D，B→C ，E→A }，该关系模式的候选码是(    )。 
</code></pre><p> A.AB<br> B.BE<br> C.CD<br> D.DE  </p>
<pre><code>3.关系模式中，满足2NF的模式(    )。 
</code></pre><p> A.可能是1NF<br> B.必定是1NF<br> C.必定是3NF<br> D.必定是BCNF  </p>
<pre><code>4.关系模式R中的属性全是主属性，则R的最高范式必定是(    )。 
</code></pre><p> A.1NF<br> B.2NF<br> C.3NF<br> D.BCNF  </p>
<pre><code>5.消除了部分函数依赖的1NF的关系模式，必定是(    )。 
</code></pre><p> A.1NF<br> B.2NF<br> C.3NF<br> D.BCNF  </p>
<pre><code>6.关系模式的候选码可以有1个或多个，而主码有(    )。 
</code></pre><p> A.多个<br> B.0个<br> C.1个<br> D.1个或多个  </p>
<pre><code>7.候选码的属性可以有(    )。 
</code></pre><p> A.多个<br> B.0个<br> C.1个<br> D.1个或多个  </p>
<pre><code>8.关系数据库规范化是为了解决关系数据库中(    )的问题而引入的。 
</code></pre><p> A.提高查询速度<br> B.插入、删除异常和数据冗余<br> C.保证数据的安全性和完整性<br> D.  </p>
<pre><code>9.学生表(id，name，sex，age，depart_id，depart_name)，存在的函数依赖是id→{name，sex，age，depart_id};dept_id→dept_name，其满足(    )。
</code></pre><p> A.1NF<br> B.2NF<br> C.3NF<br> D.BCNF  </p>
<pre><code>10.设有关系模式R(S，D，M)，其函数依赖集：F＝{S→D，D→M}，则关系模式R的规范化程度最高达(    )。 
</code></pre><p> A.1NF<br> B.2NF<br> C.3NF<br> D.BCNF  </p>
<pre><code>11.设有关系模式R(A，B，C，D)，其数据依赖集：F＝{(A，B)→C，C→D}，则关系模式R的规范化程度最高达到(    )。 
</code></pre><p> A.1NF<br> B.2NF<br> C.3NF<br> D.BCNF  </p>
<p>12.已知关系模式R&lt;U,F&gt;，U={A,B,C,D,E,G}，F={AB→C,D→EG,C→A,BE→C,BC→D,CG→BD,ACD→B,CE→AG}<br>(1).求F的最小函数依赖集。<br>(2).求出关系模式的候选码。<br>(3).此关系模型最高属于哪级范式。</p>
<p>13.关系模型R(U，F)，U={ABCDEG}，F ={AD→E，AC→E，CB→G，BCD→AG，BD→A，AB→G,A→C}<br>(1).求此模型的最小函数依赖集。<br>(2).求出关系模式的候选码。<br>(3).此关系模型最高属于哪级范式。</p>
<h1 id="数据库作业12-17"><a href="#数据库作业12-17" class="headerlink" title="数据库作业12.17"></a>数据库作业12.17</h1><hr>
<p>一、选择题<br>1.概念结构设计是整个数据库设计的关键，它通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的（    ）。<br> A. 数据模型<br> B.概念模型<br> C.层次模型<br> D.关系模型 </p>
<p>2.数据库设计中，确定数据库存储结构，即确定关系、索引、聚簇、日志、备份等数据的存储安排和存储结构，这是数据库设计的（    ）。<br> A. 需求分析阶段<br> B. 逻辑设计阶段<br> C. 概念设计阶段<br> D. 物理设计阶段 </p>
<p>3.数据库物理设计完成后，进入数据库实施阶段，下述工作中，（    ）一般不属于实施阶段的工作。<br> A.建立库结构<br> B.系统调试<br> C.加载数据<br> D.扩充功能</p>
<p>4..数据库设计可划分为六个阶段，每个阶段都有自己的设计内容，“为哪些关系，在哪些属性上建什么样的索引”这一设计内容应该属于（    ）设计阶段。<br> A.概念设计<br> B.逻辑设计<br> C.物理设计<br> D.全局设计</p>
<p>5.在关系数据库设计中，设计关系模式是数据库设计中（    ）阶段的任务。<br> A.逻辑设计阶段<br> B.概念设计阶段<br> C.物理设计阶段<br> D.需求分析阶段  </p>
<p>6.在关系数据库设计中，对关系进行规范化处理，使关系达到一定的范式，例如达到3NF，这是（     ）阶段的任务。<br> A.需求分析阶段<br> B.概念设计阶段<br> C.物理设计阶段<br> D.逻辑设计阶段  </p>
<p> 7.概念模型是现实世界的第一层抽象，这一类最著名的模型是（    ） 。<br> A.层次模型<br> B.关系模型<br> C.网状模型<br> D.实体-关系模型 </p>
<p>8.在概念模型中的客观存在并可相互区别的事物称（    ） 。<br> A.实体<br> B.元组<br> C.属性<br> D.节点</p>
<p>9.区分不同实体的依据是（    ） 。<br> A.名称<br> B.属性<br> C.对象<br> D.概念 </p>
<p>二、填空题或简答题</p>
<p>1 .“三分技术，七分管理，十二分<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>”是数据库建设的基本规律。 </p>
<p>2.数据库设计分为以下六个阶段<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。 </p>
<p>3.数据字典的内容和作用是什么？</p>
<p>4.用<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong> 方法来设计数据库的概念模型是数据库概念设计阶段广泛采用的方法。</p>
<p>5.客观存在并可相互区别的事物称为<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong> ，它可以是具体的人、事、物，也可以是抽象的概念或联系。 </p>
<p>6.什么是E-R图？构成E-R图的基本要素是什么？</p>
<h1 id="数据库作业12-24"><a href="#数据库作业12-24" class="headerlink" title="数据库作业12.24"></a>数据库作业12.24</h1><hr>
<h2 id="一、选择题-1"><a href="#一、选择题-1" class="headerlink" title="一、选择题"></a>一、选择题</h2><pre><code>1.公司有多个部门和多名职员，每个职员只能属于一个部门，一个部门可以有多名职员，从职员到部门的联系类形是(   ) 。 
</code></pre><p> A.多对多<br> B.一对一<br> C.一对多<br> D.  无法确定</p>
<pre><code>2.数据流程图是用于数据库设计中(   )阶段的工具。 
</code></pre><p> A.概要设计<br> B.可行性分析<br> C.程序编码<br> D.需求分析 </p>
<pre><code>3.在数据库设计中，将ER图转换成关系数据模型的过程属于(   )。 
</code></pre><p> A.需求分析阶段<br> B.逻辑设计阶段<br> C.概念设计阶段<br> D.物理设计阶段 </p>
<pre><code>4.数据库设计的概念设计阶段，表示概念结构的常用方法和描述工具(   )。 
</code></pre><p> A. 层次分析法和层次结构图<br> B. 数据流程分析法和数据流程图<br> C. 实体联系方法 (ER图)<br> D.结构分析法和模块结构图 </p>
<pre><code>5.在关系数据库设计中，设计关系模式是数据库设计中(   )阶段的任务 。 
</code></pre><p> A.逻辑设计阶段<br> B.概念设计阶段<br> C.物理设计阶段<br> D.需求分析阶段  </p>
<pre><code>6.关系数据库的规范化理论主要解决的问题是(   )。 
</code></pre><p> A. 如何构造合适的数据逻辑结构<br> B. 如何构造合适的数据物理结构<br> C. 如何构造合适的应用程序界面<br> D. 如何控制不同用户的数据操作权限  </p>
<pre><code>7.从ER图导出关系模型时，如果实体间的联系是M：N的，下列说法中正确的是(   )。 
</code></pre><p> A.将N方码和联系的属性纳入M方的属性中<br> B.将M方码和联系的属性纳入N方的属性中<br> C.增加一个关系表示联系，其中纳入M方和N方的码<br> D.在M方属性和N方属性中均增加一个表示级别的属性  </p>
<pre><code>8.在ER模型中，如果有3个不同的实体型，3个M：N联系，根据ER模型转换为关系模型的规则，转换为关系的数目是(   )。 
</code></pre><p> A.4<br> B.5<br> C.6<br> D.7 </p>
<p>##二、填空题或简答题<br>1.唯一标识实体的属性集称为<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong> 。</p>
<p>2.实体之间的联系有<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>三种。</p>
<p>3.什么是数据库的逻辑结构设计？试述其设计步骤。</p>
<p>4.如果两个实体之间具有M：N联系，则将它们转换为关系模型的结果是<strong><strong>___</strong></strong>个关系。</p>
<p>5.ER模型是对现实世界的一种抽象，它的主要成分是<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>、联系和 <strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。 </p>
<p>6.各分E-R图之间的冲突主要有三类：<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong> 、<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>和<strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong>。</p>
<p>7.在E-R模型向关系模型转换时，M：N的联系转换为关系模式时，其码包括<strong><strong><strong><strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong></strong></strong></strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/深搜/专题 简单搜索（bfs+dfs)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/深搜/专题 简单搜索（bfs+dfs)/" itemprop="url">专题 简单搜索（bfs+dfs)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深搜/" itemprop="url" rel="index">
                    <span itemprop="name">深搜</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>##A POJ 1321<br>思路：这条题目给定棋盘，要求横竖不能放，按行数开始dfs，按列数循环，深搜进入下一层，本行测试完成后，直接进入下一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">//回溯法</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//定义棋盘</span><br><span class="line">char qipan[8][8];</span><br><span class="line"></span><br><span class="line">//从行扫描，所以仅记录列数是否被占用，</span><br><span class="line">bool col[8];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//m是需要填充的个数</span><br><span class="line">//n是棋盘规模</span><br><span class="line">//cur是当前已填充个数</span><br><span class="line">int m,n;</span><br><span class="line">int cur;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//r为行数，k代表已经填充的棋子数，cur代表方案数</span><br><span class="line">void dfs(int r, int k)</span><br><span class="line">&#123;</span><br><span class="line">	if (k == m)</span><br><span class="line">	&#123;</span><br><span class="line">		cur++;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (r &gt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//若第i列没有放且qipan[r][i] == &apos;#&apos;，若不能填，直接进入下一次循环</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!col[i] &amp;&amp; qipan[r][i] == &apos;#&apos;)</span><br><span class="line">		&#123;</span><br><span class="line">			col[i] = 1;</span><br><span class="line">			dfs(r + 1, k + 1);</span><br><span class="line">			col[i] = 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//本行已经全部测试完成，直接进入下一行</span><br><span class="line">	dfs(r + 1, k);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while (cin&gt;&gt;m&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		if (n == -1 &amp;&amp; m == -1) break;</span><br><span class="line">		cur = 0;</span><br><span class="line">		for (int i = 0; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			for (int j = 0; j &lt; n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				cin &gt;&gt; qipan[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		memset(col, false, sizeof(col));</span><br><span class="line">		dfs(0, 0);</span><br><span class="line">		cout &lt;&lt; cur &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##B POJ 2251<br>3DBFS，扩展而已。水题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int L, R, C;</span><br><span class="line">const int maxn = 32;</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int l, r, c;</span><br><span class="line">    int path;</span><br><span class="line">    //-1 = #     1 = .   2 = E</span><br><span class="line">    int own;</span><br><span class="line">    void assign(int x, int y, int z)</span><br><span class="line">    &#123;</span><br><span class="line">        l = x; r = y; c = z;</span><br><span class="line">        path = -1;</span><br><span class="line">        own = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[maxn][maxn][maxn];</span><br><span class="line">queue&lt;Node&gt; Q;</span><br><span class="line"></span><br><span class="line">int bfs()</span><br><span class="line">&#123;</span><br><span class="line">    Node temp;</span><br><span class="line">    while (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp = Q.front();</span><br><span class="line">        if (temp.own == 2)return temp.path;</span><br><span class="line">        for (int dl = -1; dl &lt; 2; dl++)</span><br><span class="line">            for (int dr = -1; dr &lt; 2; dr++)</span><br><span class="line">                for (int dc = -1; dc &lt; 2; dc++)</span><br><span class="line">                &#123;</span><br><span class="line">                    int a[3] = &#123; dl, dr, dc &#125;;</span><br><span class="line">                    sort(a, a + 3);</span><br><span class="line">                    if (!((a[0] == 0 &amp;&amp; a[1] == 0) || (a[1] == 0 &amp;&amp; a[2] == 0)))continue;</span><br><span class="line">                    if (temp.l + dl &gt; 0 &amp;&amp; temp.l + dl &lt;= L &amp;&amp; temp.r + dr &gt; 0 &amp;&amp; temp.r + dr &lt;= R &amp;&amp; temp.c + dc &gt; 0 &amp;&amp; temp.c + dc &lt;= C &amp;&amp; node[temp.l + dl][temp.r + dr][temp.c + dc].own &gt; 0 &amp;&amp; node[temp.l + dl][temp.r + dr][temp.c + dc].path &lt; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        node[temp.l + dl][temp.r + dr][temp.c + dc].path = node[temp.l][temp.r][temp.c].path + 1;</span><br><span class="line">                        Q.push(node[temp.l + dl][temp.r + dr][temp.c + dc]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        Q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    while (cin &gt;&gt; L &gt;&gt; R &gt;&gt; C)</span><br><span class="line">    &#123;</span><br><span class="line">        if (L == 0 &amp;&amp; R == 0 &amp;&amp; C == 0)break;</span><br><span class="line">        while (!Q.empty())Q.pop();</span><br><span class="line">        string tmp;</span><br><span class="line">        for (int i = 1; i &lt;= L; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 1; j &lt;= R; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; tmp;</span><br><span class="line">                for (int k = 1; k &lt;= C; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    node[i][j][k].assign(i, j, k);</span><br><span class="line">                    switch (tmp[k - 1])</span><br><span class="line">                    &#123;</span><br><span class="line">                    case &apos;.&apos;:node[i][j][k].own = 1; break;</span><br><span class="line">                    case &apos;S&apos;:node[i][j][k].own = 1; node[i][j][k].path = 0; Q.push(node[i][j][k]); break;</span><br><span class="line">                    case &apos;E&apos;:node[i][j][k].own = 2; break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = bfs();</span><br><span class="line">        if (ans == 0)cout &lt;&lt; &quot;Trapped!\n&quot;;</span><br><span class="line">        else cout &lt;&lt; &quot;Escaped in &quot; &lt;&lt; ans &lt;&lt; &quot; minute(s).\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##C POJ 3278<br>隐式bfs。水题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 100001;</span><br><span class="line"></span><br><span class="line">int N, K;</span><br><span class="line">queue&lt;int&gt; Q;</span><br><span class="line">int path[maxn];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    memset(path, -1, sizeof(path));</span><br><span class="line">    path[N] = 0;</span><br><span class="line">    Q.push(N);</span><br><span class="line">    int temp;</span><br><span class="line">    while (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        if (temp == K) &#123; cout &lt;&lt; path[temp] &lt;&lt; endl; &#125;</span><br><span class="line">        if (temp &gt; 0 &amp;&amp; path[temp - 1] &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Q.push(temp - 1);</span><br><span class="line">            path[temp - 1] = path[temp] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp &lt; 100000 &amp;&amp; path[temp + 1] &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Q.push(temp + 1);</span><br><span class="line">            path[temp + 1] = path[temp] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp * 2 &lt; maxn &amp;&amp; path[temp * 2] &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Q.push(temp * 2);</span><br><span class="line">            path[temp * 2] = path[temp] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##D POJ 3279<br>值得注意的是第一行一旦确定后面行也确定。从这点出发的暴力运算量就可以AC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">//显然每个位置只能为0或1，不可能为2</span><br><span class="line">//而当第一行一旦确定，后面的m-1行也就确定</span><br><span class="line">//因此只要穷举第一行的情况，1&lt;&lt;16的运算量，再选字典序最小即可</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int M, N;</span><br><span class="line">int m[17][17];</span><br><span class="line">int map[17][17];</span><br><span class="line">int ans[17][17];</span><br><span class="line">int minans[17][17];</span><br><span class="line">int minp = (1 &lt;&lt; 30);</span><br><span class="line">int minv = (1 &lt;&lt; 30);</span><br><span class="line">const int dx[] = &#123; 1, -1, 0, 0 &#125;;</span><br><span class="line">const int dy[] = &#123; 0, 0, 1, -1 &#125;;</span><br><span class="line"></span><br><span class="line">void flip(int row, int col)</span><br><span class="line">&#123;</span><br><span class="line">    if (map[row][col] == 0)map[row][col] = 1;</span><br><span class="line">    else map[row][col] = 0;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (row + dx[i] &lt; 0 || row + dx[i] &gt; M - 1 || col + dy[i] &lt; 0 || col + dy[i] &gt; N - 1)continue;</span><br><span class="line">        if (map[row + dx[i]][col + dy[i]] == 0)map[row + dx[i]][col + dy[i]] = 1;</span><br><span class="line">        else map[row + dx[i]][col + dy[i]] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; M &gt;&gt; N;</span><br><span class="line">    memset(m, -1, sizeof(m));</span><br><span class="line">    for (int i = 0; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; j++)</span><br><span class="line">            cin &gt;&gt; m[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    bool fuck = false;</span><br><span class="line">    for (int i = 0; i &lt; (1 &lt;&lt; N); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(ans, 0, sizeof(ans));</span><br><span class="line">        for (int x = 0; x &lt; M; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int y = 0; y &lt; N; y++)</span><br><span class="line">                map[x][y] = m[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[0][j] = (i &amp; (1 &lt;&lt; j));</span><br><span class="line">            if (ans[0][j] &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[0][j] = 1;</span><br><span class="line">                flip(0, j);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt; M; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int k = 0; k &lt; N; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (map[j - 1][k] == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    flip(j, k);</span><br><span class="line">                    ans[j][k] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        bool zz = true;</span><br><span class="line">        for (int j = 0; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (map[M - 1][j] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                zz = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (zz)</span><br><span class="line">        &#123;</span><br><span class="line">            fuck = true;</span><br><span class="line">            int p = 0;</span><br><span class="line">            for (int k = 0; k &lt; M; k++)</span><br><span class="line">                for (int j = 0; j &lt; N; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    p += ans[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            if (p &lt; minv || (p == minv &amp;&amp; minp &gt; i))</span><br><span class="line">            &#123;</span><br><span class="line">                minv = p;</span><br><span class="line">                minp = i;</span><br><span class="line">                memcpy(minans, ans, sizeof(ans));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!fuck)cout &lt;&lt; &quot;IMPOSSIBLE\n&quot;;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; N - 1; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; minans[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; minans[i][N - 1] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##E POJ 1426<br>隐式bfs剪枝，从最高位1开始。利用数论的知识来优化就不会爆炸<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//第一位必定为1 选最小的即可</span><br><span class="line">//从最高位开始向后bfs，补0或1</span><br><span class="line">//剪枝：对于完全剩余系0-n-1</span><br><span class="line">//比如在第3位出现了k，而到第9位为0，结束</span><br><span class="line">//那么我在第6位又出现k，显然到12位就会为0</span><br><span class="line">//因此可以直接把又出现k的情况直接扔掉</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N;</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int value;</span><br><span class="line">    int pos;</span><br><span class="line">    int store[205];</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">    Node(int a) :pos(a), value(1) &#123; memset(store, 0, sizeof(store)); store[a] = 1; &#125;</span><br><span class="line">    Node(Node n, int p)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = n.pos + 1;</span><br><span class="line">        value = (n.value * 10 + p) % N;</span><br><span class="line">        memcpy(store, n.store, sizeof(store));</span><br><span class="line">        store[pos] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 1; i &lt;= pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; store[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node first;</span><br><span class="line">queue&lt;Node&gt; Q;</span><br><span class="line">int visited[205];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (cin &gt;&gt; N &amp;&amp; N &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(visited, 0, sizeof(visited));</span><br><span class="line">        while (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        first = Node(1);</span><br><span class="line">        Q.push(first);</span><br><span class="line">        while (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            first = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            if (visited[first.value] == 1)continue;</span><br><span class="line">            else visited[first.value] = 1;</span><br><span class="line">            if (first.value == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                first.print();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            Q.push(Node(first, 0));</span><br><span class="line">            Q.push(Node(first, 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##F POJ 3126<br>注意素数的判别不要弄错，小于等于根号n<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">//注意判断素数那里小于等于根号i</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int M;</span><br><span class="line">bool prime[10005];</span><br><span class="line">int path[10005];</span><br><span class="line">queue&lt;int&gt; Q;</span><br><span class="line"></span><br><span class="line">void primebuild()</span><br><span class="line">&#123;</span><br><span class="line">    memset(prime, 0, sizeof(prime));</span><br><span class="line">    for (int i = 1001; i &lt; 10000; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int temp = floor(sqrt(1.0*i) + 0.5);</span><br><span class="line">        bool fuck = true;</span><br><span class="line">        for (int j = 2; j &lt;= temp; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i % j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                fuck = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prime[i] = fuck;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int bfs(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    memset(path, -1, sizeof(path));</span><br><span class="line">    while (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    path[a] = 0;</span><br><span class="line">    Q.push(a);</span><br><span class="line">    int first;</span><br><span class="line">    while (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        first = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        if (first == b)return path[first];</span><br><span class="line">        int p = first % 1000;</span><br><span class="line">        for (int i = 1; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p += 1000;</span><br><span class="line">            if (path[p] &lt; 0 &amp;&amp; prime[p])</span><br><span class="line">            &#123;</span><br><span class="line">                Q.push(p);</span><br><span class="line">                path[p] = path[first] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p = (first / 1000) * 1000 + (first % 100);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (path[p] &lt; 0 &amp;&amp; prime[p])</span><br><span class="line">            &#123;</span><br><span class="line">                Q.push(p);</span><br><span class="line">                path[p] = path[first] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            p += 100;</span><br><span class="line">        &#125;</span><br><span class="line">        p = first - (first % 100) + (first % 10);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (path[p] &lt; 0 &amp;&amp; prime[p])</span><br><span class="line">            &#123;</span><br><span class="line">                Q.push(p);</span><br><span class="line">                path[p] = path[first] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            p += 10;</span><br><span class="line">        &#125;</span><br><span class="line">        p = first - (first % 10);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (path[p] &lt; 0 &amp;&amp; prime[p])</span><br><span class="line">            &#123;</span><br><span class="line">                Q.push(p);</span><br><span class="line">                path[p] = path[first] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    primebuild();</span><br><span class="line">    cin &gt;&gt; M;</span><br><span class="line">    while (M--)</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        cout &lt;&lt; bfs(a, b) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##G POJ 3087<br>模拟题，注意某一状态第二次出现时剪枝。水题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//纯模拟题，注意两副牌重复交叉一定次数一定会循环到开始</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int M, C;</span><br><span class="line">string a, b, c;</span><br><span class="line">map&lt;string, int&gt; mm;</span><br><span class="line"></span><br><span class="line">string change()</span><br><span class="line">&#123;</span><br><span class="line">    string ret = &quot;&quot;;</span><br><span class="line">    for (int i = 0; i &lt; (C &lt;&lt; 1); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i &amp; 1) ret += a[i&gt;&gt;1];</span><br><span class="line">        else ret += b[i&gt;&gt;1];</span><br><span class="line">    &#125;</span><br><span class="line">    a = ret.substr(0, C);</span><br><span class="line">    b = ret.substr(C, C);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; M;</span><br><span class="line">    for (int kase = 0; kase &lt; M; kase++)</span><br><span class="line">    &#123;</span><br><span class="line">        mm.clear();</span><br><span class="line">        cin &gt;&gt; C &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        cout &lt;&lt; kase + 1 &lt;&lt; &quot; &quot;;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp = change();</span><br><span class="line">            ans++;</span><br><span class="line">            if (temp == c)break;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (mm[temp] == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = -1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    mm[temp] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##H POJ 3414<br>细节上别弄错。bfs水题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">//类的构造函数的形参类型为该类必须用引用</span><br><span class="line">//注意set放结构体的时候必须要重载&lt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a, b, c;</span><br><span class="line"></span><br><span class="line">struct State</span><br><span class="line">&#123;</span><br><span class="line">    int la, lb;</span><br><span class="line">    bool ok() &#123; if (la == c || lb == c)return true; return false; &#125;</span><br><span class="line">    int path;</span><br><span class="line">    string way;</span><br><span class="line">    State() :path(-1), la(0), lb(0), way(&quot;&quot;) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int la, lb;</span><br><span class="line">    Node(State a):la(a.la), lb(a.lb) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool operator &lt; (Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a.la != b.la)return a.la &lt; b.la;</span><br><span class="line">    else return a.lb &lt; b.lb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set&lt;Node&gt; S;</span><br><span class="line">queue&lt;State&gt; Q;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    State first;</span><br><span class="line">    first.path++;</span><br><span class="line">    Q.push(first);</span><br><span class="line">    bool fuck = false;</span><br><span class="line">    while (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        first = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        Node node(first);</span><br><span class="line">        if (S.count(node))continue;</span><br><span class="line">        else S.insert(node);</span><br><span class="line">        if (first.ok())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; first.path &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; first.way;</span><br><span class="line">            fuck = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            first.path++;</span><br><span class="line">            State temp = first;</span><br><span class="line">            if (first.la &lt; a)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.way += &quot;FILL(1)\n&quot;;</span><br><span class="line">                temp.la = a;</span><br><span class="line">                Q.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = first;</span><br><span class="line">            if (first.lb &lt; b)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.way += &quot;FILL(2)\n&quot;;</span><br><span class="line">                temp.lb = b;</span><br><span class="line">                Q.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = first;</span><br><span class="line">            if (first.la &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.way += &quot;DROP(1)\n&quot;;</span><br><span class="line">                temp.la = 0;</span><br><span class="line">                Q.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = first;</span><br><span class="line">            if (first.lb &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.way += &quot;DROP(2)\n&quot;;</span><br><span class="line">                temp.lb = 0;</span><br><span class="line">                Q.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = first;</span><br><span class="line">            if (first.la &lt; a &amp;&amp; first.lb &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.way += &quot;POUR(2,1)\n&quot;;</span><br><span class="line">                int cc = a - first.la;</span><br><span class="line">                if (cc &gt; first.lb)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.la += first.lb;</span><br><span class="line">                    temp.lb = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.lb -= cc;</span><br><span class="line">                    temp.la = a;</span><br><span class="line">                &#125;</span><br><span class="line">                Q.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = first;</span><br><span class="line">            if (first.lb &lt; b &amp;&amp; first.la &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.way += &quot;POUR(1,2)\n&quot;;</span><br><span class="line">                int cc = b - first.lb;</span><br><span class="line">                if (cc &gt; first.la)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.lb += first.la;</span><br><span class="line">                    temp.la = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.la -= cc;</span><br><span class="line">                    temp.lb = b;</span><br><span class="line">                &#125;</span><br><span class="line">                Q.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!fuck) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##I FZU 2150<br>dfs穷举组合数+bfs。注意笔误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">//dfs穷举组合数+bfs暴力</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int map[12][12];</span><br><span class="line">int grass[12][12];</span><br><span class="line">int T, n, m;</span><br><span class="line">int px[105], py[105];</span><br><span class="line">int tot;</span><br><span class="line">int fire[3];</span><br><span class="line">int ans;</span><br><span class="line">int dx[] = &#123; -1, 0, 1, 0 &#125;;</span><br><span class="line">int dy[] = &#123; 0, 1, 0, -1 &#125;;</span><br><span class="line">int visited[12][12];</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    int path;</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">    Node(int x, int y, int path) :x(x), y(y), path(path) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; Q;</span><br><span class="line"></span><br><span class="line">void dfs(int cur, int num)</span><br><span class="line">&#123;</span><br><span class="line">    if (cur == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        memcpy(grass, map, sizeof(map));</span><br><span class="line">        memset(visited, 0, sizeof(visited));</span><br><span class="line">        int t = -1;</span><br><span class="line">        Node t1 = Node(px[fire[0]], py[fire[0]], 0), t2 = Node(px[fire[1]], py[fire[1]], 0);</span><br><span class="line">        Q.push(t1);</span><br><span class="line">        Q.push(t2);</span><br><span class="line">        while (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            Node temp = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            if (grass[temp.x][temp.y] == 0)continue;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                t = max(t, temp.path);</span><br><span class="line">                grass[temp.x][temp.y] = 0;</span><br><span class="line">                for (int i = 0; i &lt; 4; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (temp.x + dx[i] &lt; 0 || temp.x + dx[i] &gt; n - 1)continue;</span><br><span class="line">                    if (temp.y + dy[i] &lt; 0 || temp.y + dy[i] &gt; m - 1)continue;</span><br><span class="line">                    if (visited[temp.x + dx[i]][temp.y + dy[i]] == 1)continue;</span><br><span class="line">                    Q.push(Node(temp.x + dx[i], temp.y + dy[i], temp.path + 1));</span><br><span class="line">                    visited[temp.x + dx[i]][temp.y + dy[i]] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bool fuck = true;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            bool cc = true;</span><br><span class="line">            for (int j = 0; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (grass[i][j] == 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    cc = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!cc)</span><br><span class="line">            &#123;</span><br><span class="line">                fuck = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fuck)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = min(ans, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = num; i &lt; tot; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fire[cur] = i;</span><br><span class="line">            dfs(cur + 1, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    for (int kase = 0; kase &lt; T; kase++)</span><br><span class="line">    &#123;</span><br><span class="line">        tot = 0;</span><br><span class="line">        ans = (1 &lt;&lt; 30);</span><br><span class="line">        memset(map, 0, sizeof(map));</span><br><span class="line">        memset(px, -1, sizeof(px));</span><br><span class="line">        memset(py, -1, sizeof(py));</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        char chTmp;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; chTmp;</span><br><span class="line">                if (chTmp == &apos;#&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = 1;</span><br><span class="line">                    px[tot] = i;</span><br><span class="line">                    py[tot] = j;</span><br><span class="line">                    tot++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    map[i][j] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            cin.ignore();</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, 0);</span><br><span class="line">        if (ans == (1 &lt;&lt; 30))ans = -1;</span><br><span class="line">        cout &lt;&lt; &quot;Case &quot; &lt;&lt; kase + 1 &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##J UVA 11624<br>注意状态的先后变化。bfs水题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int T;</span><br><span class="line">int R, C;</span><br><span class="line">int fr, fc;</span><br><span class="line">int map[1005][1005];</span><br><span class="line">int visited[1005][1005];</span><br><span class="line">const int dr[] = &#123; 0, 1, 0, -1 &#125;;</span><br><span class="line">const int dc[] = &#123; 1, 0, -1, 0 &#125;;</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int row, col;</span><br><span class="line">    int path;</span><br><span class="line">    bool fire;</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">    Node(int row, int col, int path, bool fire) :row(row), col(col), path(path), fire(fire) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; Q;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        while (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        memset(map, -1, sizeof(map));</span><br><span class="line">        memset(visited, 0, sizeof(visited));</span><br><span class="line">        cin &gt;&gt; R &gt;&gt; C;</span><br><span class="line">        char chTmp;</span><br><span class="line">        for (int i = 1; i &lt;= R; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 1; j &lt;= C; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; chTmp;</span><br><span class="line">                if (chTmp == &apos;#&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = -1;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    if (chTmp == &apos;.&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        map[i][j] = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (chTmp == &apos;F&apos;)</span><br><span class="line">                        &#123;</span><br><span class="line">                            map[i][j] = -2;</span><br><span class="line">                            Q.push(Node(i, j, -1, true));</span><br><span class="line">                        &#125;</span><br><span class="line">                        else</span><br><span class="line">                        &#123;</span><br><span class="line">                            map[i][j] = 1;</span><br><span class="line">                            fr = i;</span><br><span class="line">                            fc = j;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cin.ignore();</span><br><span class="line">        &#125;</span><br><span class="line">        Q.push(Node(fr, fc, 0, false));</span><br><span class="line">        bool fuck = true;</span><br><span class="line">        Node first;</span><br><span class="line">        while (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            first = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            if (!first.fire)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int i = 0; i &lt; 4; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (first.row + dr[i] &lt; 1 || first.row + dr[i] &gt; R || first.col + dc[i] &lt; 1 || first.col + dc[i] &gt; C)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fuck = false;</span><br><span class="line">                        cout &lt;&lt; first.path + 1 &lt;&lt; endl;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (visited[first.row + dr[i]][first.col + dc[i]] == 0 &amp;&amp; map[first.row + dr[i]][first.col + dc[i]] &gt; 0)</span><br><span class="line">                        &#123;</span><br><span class="line">                            visited[first.row + dr[i]][first.col + dc[i]] = 1;</span><br><span class="line">                            Q.push(Node(first.row + dr[i], first.col + dc[i], first.path + 1, false));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!fuck)break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                for (int i = 0; i &lt; 4; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (first.row + dr[i] &lt; 1 || first.row + dr[i] &gt; R || first.col + dc[i] &lt; 1 || first.col + dc[i] &gt; C)continue;</span><br><span class="line">                    if (map[first.row + dr[i]][first.col + dc[i]] &gt; 0 &amp;&amp; visited[first.row + dr[i]][first.col + dc[i]] == 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Q.push(Node(first.row + dr[i], first.col + dc[i], -1, true));</span><br><span class="line">                        map[first.row + dr[i]][first.col + dc[i]] = -2;</span><br><span class="line">                        visited[first.row + dr[i]][first.col + dc[i]] = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fuck)cout &lt;&lt; &quot;IMPOSSIBLE&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##K POJ 3984<br>本专题最简单的水题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int map[5][5];</span><br><span class="line">int visited[5][5];</span><br><span class="line">const int dr[] = &#123; -1, 0, 1, 0 &#125;;</span><br><span class="line">const int dc[] = &#123; 0, -1, 0, 1 &#125;;</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int row, col;</span><br><span class="line">    int path;</span><br><span class="line">    string way;</span><br><span class="line">    Node(int row, int col, int path) :row(row), col(col), path(path) &#123; way = &quot;&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;Node&gt; Q;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++)</span><br><span class="line">        for (int j = 0; j &lt; 5; j++)</span><br><span class="line">            cin &gt;&gt; map[i][j];</span><br><span class="line">    Node first = Node(0, 0, 0);</span><br><span class="line">    first.way = &quot;(0, 0)\n&quot;;</span><br><span class="line">    visited[0][0] = 1;</span><br><span class="line">    Q.push(first);</span><br><span class="line">    while (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        first = Q.front(); Q.pop();</span><br><span class="line">        if (first.row == 4 &amp;&amp; first.col == 4)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; first.way;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (first.row + dr[i] &lt; 0 || first.row + dr[i] &gt; 4 || first.col + dc[i] &lt; 0 || first.col + dc[i] &gt; 4)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    if (map[first.row + dr[i]][first.col + dc[i]] == 0 &amp;&amp; visited[first.row + dr[i]][first.col + dc[i]] == 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Node temp = first;</span><br><span class="line">                        temp.row += dr[i];</span><br><span class="line">                        temp.col += dc[i];</span><br><span class="line">                        temp.path++;</span><br><span class="line">                        temp.way += &quot;(&quot;;</span><br><span class="line">                        temp.way += first.row + dr[i] + 48;</span><br><span class="line">                        temp.way += &quot;, &quot;;</span><br><span class="line">                        temp.way += first.col + dc[i] + 48;</span><br><span class="line">                        temp.way += &quot;)\n&quot;;</span><br><span class="line">                        Q.push(temp);</span><br><span class="line">                        visited[first.row + dr[i]][first.col + dc[i]] = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##L HDU 1241<br>紫书例题，八连通图。水题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 105;</span><br><span class="line">const int dr[] = &#123; -1, -1, -1, 0, 0, 1, 1, 1 &#125;;</span><br><span class="line">const int dc[] = &#123; -1, 0, 1, -1, 1, -1, 0, 1 &#125;;</span><br><span class="line"></span><br><span class="line">int ans;</span><br><span class="line">int r, c;</span><br><span class="line">int map[maxn][maxn];</span><br><span class="line">int visited[maxn][maxn];</span><br><span class="line">void dfs(int row, int col);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char chTmp;</span><br><span class="line">    while (cin &gt;&gt; r &gt;&gt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        if (r == 0)break;</span><br><span class="line">        ans = 0;</span><br><span class="line">        memset(map, 0, sizeof(map));</span><br><span class="line">        memset(visited, 0, sizeof(map));</span><br><span class="line">        for (int i = 1; i &lt;= r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 1; j &lt;= c; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; chTmp;</span><br><span class="line">                if (chTmp == &apos;@&apos;)</span><br><span class="line">                    map[i][j] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            cin.ignore();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 1; j &lt;= c; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (map[i][j] == 1 &amp;&amp; visited[i][j] == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    dfs(i, j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int row, int col)</span><br><span class="line">&#123;</span><br><span class="line">    visited[row][col] = 1;</span><br><span class="line">    for (int i = 0; i &lt; 8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (row + dr[i] &lt; 1 || row + dr[i] &gt; r || col + dc[i] &lt; 1 || col + dc[i] &gt; c)continue;</span><br><span class="line">        if (map[row + dr[i]][col + dc[i]] == 1 &amp;&amp; visited[row + dr[i]][col + dc[i]] == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(row + dr[i], col + dc[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##M HDU 1495<br>和上面某题极其相似。水题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int s, n, m;</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int a, b, c;</span><br><span class="line">    int path;</span><br><span class="line">    Node(int a, int b, int c, int path) :a(a), b(b), c(c), path(path) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct State</span><br><span class="line">&#123;</span><br><span class="line">    int a, b, c;</span><br><span class="line">    State() &#123;&#125;</span><br><span class="line">    State(Node x) :a(x.a), b(x.b), c(x.c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool operator &lt; (const State&amp; x, const State&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    if (x.a != y.a) return x.a &lt; y.a;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (x.b != y.b) return x.b &lt; y.b;</span><br><span class="line">        else return x.c &lt; y.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set&lt;State&gt; S;</span><br><span class="line">queue&lt;Node&gt; Q;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;        </span><br><span class="line">    while (cin &gt;&gt; s &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        while (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        S.clear();</span><br><span class="line">        if (s == 0)break;</span><br><span class="line">        Node first = Node(s, 0, 0, 0);</span><br><span class="line">        State temp;</span><br><span class="line">        Q.push(first);</span><br><span class="line">        bool fuck = true;</span><br><span class="line">        if (s % 2 == 0)</span><br><span class="line">        while (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            first = Q.front(); Q.pop();</span><br><span class="line">            temp = State(first);</span><br><span class="line">            int pp[3] = &#123; first.a, first.b, first.c &#125;;</span><br><span class="line">            sort(pp, pp + 3);</span><br><span class="line">            if (pp[1] == s / 2 &amp;&amp; pp[2] == s / 2)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; first.path &lt;&lt; endl;</span><br><span class="line">                fuck = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (S.count(temp) == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                S.insert(temp);</span><br><span class="line">                if (first.a &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (first.b &lt; n)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Q.push(Node(max(0, first.a - n + first.b), min(n, first.b + first.a), first.c, first.path + 1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (first.c &lt; n)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Q.push(Node(max(0, first.a - m + first.c), first.b, min(m, first.c + first.a), first.path + 1));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (first.b &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    Q.push(Node(first.a + first.b, 0, first.c, first.path + 1));</span><br><span class="line">                    if (first.c &lt; m)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Q.push(Node(first.a, max(0, first.b - m + first.c), min(m, first.c + first.b), first.path + 1));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (first.c &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    Q.push(Node(first.a + first.c, first.b, 0, first.path + 1));</span><br><span class="line">                    if (first.b &lt; m)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Q.push(Node(first.a, min(n, first.b + first.c), max(0, first.c - n + first.b), first.path + 1));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fuck)cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##N HDU 2612<br>注意不能用太暴力的方法，不然会MLE/TLE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">//一开始的思路是穷举每个点到Y M的距离， TLE</span><br><span class="line">//改进了一下，打表，两次BFS求Y\M到每个点的距离，AC</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 205;</span><br><span class="line">const int dr[] = &#123; -1, 0, 1, 0 &#125;;</span><br><span class="line">const int dc[] = &#123; 0, -1, 0, 1 &#125;;</span><br><span class="line">int r, c;</span><br><span class="line">int map[maxn][maxn];</span><br><span class="line">int visited[maxn][maxn];</span><br><span class="line">int tot = 0;</span><br><span class="line">int kr[maxn*maxn], kc[maxn*maxn];</span><br><span class="line">int yr, yc, mr, mc;</span><br><span class="line">int yk[maxn*maxn], mk[maxn*maxn];</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int row, col;</span><br><span class="line">    int path;</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">    Node(int row, int col, int path) :row(row), col(col), path(path) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;Node&gt; Q;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char chTmp;</span><br><span class="line">    while (scanf(&quot;%d %d\n&quot;, &amp;r, &amp;c) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(map, -1, sizeof(map));</span><br><span class="line">        for (int i = 1; i &lt;= r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 1; j &lt;= c; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; chTmp;</span><br><span class="line">                if (chTmp == &apos;.&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    if (chTmp == &apos;@&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        map[i][j] = ++tot;</span><br><span class="line">                        kr[tot] = i;</span><br><span class="line">                        kc[tot] = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (chTmp == &apos;Y&apos;)</span><br><span class="line">                        &#123;</span><br><span class="line">                            map[i][j] = 0;</span><br><span class="line">                            yr = i;</span><br><span class="line">                            yc = j;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else</span><br><span class="line">                        &#123;</span><br><span class="line">                            if (chTmp == &apos;M&apos;)</span><br><span class="line">                            &#123;</span><br><span class="line">                                map[i][j] = 0;</span><br><span class="line">                                mr = i;</span><br><span class="line">                                mc = j;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp;</span><br><span class="line">        memset(visited, 0, sizeof(visited));</span><br><span class="line">        memset(yk, -1, sizeof(yk));</span><br><span class="line">        Q.push(Node(yr, yc, 0));</span><br><span class="line">        visited[yr][yc] = 1;</span><br><span class="line">        while (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            temp = Q.front(); Q.pop();</span><br><span class="line">            if (map[temp.row][temp.col] &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                yk[map[temp.row][temp.col]] = temp.path;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (temp.row + dr[i] &lt; 1 || temp.row + dr[i] &gt; r || temp.col + dc[i] &lt; 1 || temp.col + dc[i] &gt; c)continue;</span><br><span class="line">                if (visited[temp.row + dr[i]][temp.col + dc[i]] == 0 &amp;&amp; map[temp.row + dr[i]][temp.col + dc[i]] &gt;= 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[temp.row + dr[i]][temp.col + dc[i]] = 1;</span><br><span class="line">                    Q.push(Node(temp.row + dr[i], temp.col + dc[i], temp.path + 1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(visited, 0, sizeof(visited));</span><br><span class="line">        memset(mk, -1, sizeof(mk));</span><br><span class="line">        Q.push(Node(mr, mc, 0));</span><br><span class="line">        visited[mr][mc] = 1;</span><br><span class="line">        while (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            temp = Q.front(); Q.pop();</span><br><span class="line">            if (map[temp.row][temp.col] &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                mk[map[temp.row][temp.col]] = temp.path;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 0; i &lt; 4; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (temp.row + dr[i] &lt; 1 || temp.row + dr[i] &gt; r || temp.col + dc[i] &lt; 1 || temp.col + dc[i] &gt; c)continue;</span><br><span class="line">                if (visited[temp.row + dr[i]][temp.col + dc[i]] == 0 &amp;&amp; map[temp.row + dr[i]][temp.col + dc[i]] &gt;= 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[temp.row + dr[i]][temp.col + dc[i]] = 1;</span><br><span class="line">                    Q.push(Node(temp.row + dr[i], temp.col + dc[i], temp.path + 1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = (1 &lt;&lt; 30);</span><br><span class="line">        for (int i = 1; i &lt;= tot; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (yk[i] == -1 || mk[i] == -1)continue;</span><br><span class="line">            ans = min(ans, yk[i] + mk[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, ans * 11);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/深度学习问题集合/问题集合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/深度学习问题集合/问题集合/" itemprop="url">问题集合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习问题集合/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习问题集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>##1<br> python 3以上版本使用pickle.load读取文件报UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0x8b in position 6<br>2017年03月18日 17:53:061832人阅读 评论(1) 收藏  举报<br>原本代码是这样的</p>
<pre><code>fo = open(file, &apos;rb&apos;)
dict = pickle.load(fo)
</code></pre><p>修改之后只需要在打开的时候指定编码</p>
<p> fo = open(file, ‘rb’)<br>   dict = pickle.load(fo,encoding=’iso-8859-1’)</p>
<p> ##<br> import time</p>
<p>time_start=time.time()<br>time_end=time.time()<br>print(‘totally cost’,time_end-time_start)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/设计模式/设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/设计模式/设计模式/" itemprop="url">设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<blockquote>
<ul>
<li>①用户手机的验证及注册（信息保留在服务器上面，服务器采用     lamp环境）</li>
<li>②用户登录软件</li>
<li>③    我的主页的显示（模拟，未与网络通信）</li>
<li>④    发布资源</li>
<li>⑤    浏览资源按</li>
<li>⑥    点赞，收藏，分享</li>
</ul>
</blockquote>
<hr>
<p>表示层为用户提供交互操作界面<br>业务逻辑层负责关键业务的处理和数据传递<br>数据访问层实现数据访问（通过网络等） </p>
<blockquote>
<ul>
<li>表现层（UI）：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。</li>
<li>业务逻辑层（BLL）：针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。</li>
<li>数据访问层（DAL）：该层所做事务访问网络服务器，请求数据操作。</li>
</ul>
</blockquote>
<p>+——————————————————————————————————————</p>
<blockquote>
<ul>
<li><strong>单例模式的uesrbean</strong>：为了便于各个层次调用信息，采用单例模式，整个进程中只有一个实例，通过get方法返回实例，该类在用户登陆成功的时候加载，保存用户的信息，其他层次，可以通过此类的实例，访问登陆用户的信息，本类还可保存其他一些需要调用的信息，此外，本app的模拟数据也在此加载。</li>
<li><strong>抽象工厂和反射加配置文件：为了是BLL层与DAL完全分离，通过抽象工厂加反射返回一个接口,D层去实现接口,体现了D层的可移植性。</strong><br>①U层负责数据的输入以及验证用户名和密码是否合法<br>②B层负责逻辑处理,用户名和密码的验证逻辑，<br>③工厂负责数据库的选择和创建接口（这里利用工厂有两个作用,一个是数据库的选择,另一个是表的选择,利用工厂可以以很方便的对数据库进行选择,只需要更改配置文件中的内容就好了,不需要更改其它地方,很好的体现了开放封闭原则);<br>④IDAL层负责放置接口<br>⑤D层负责实例化接口，和数据库打交道</li>
<li><strong>抽象工厂，生产BLL逻辑层接口</strong>：同样的方法，我们也可以把BLL层给抽象出来，便于以后的修改</li>
<li><strong>listview的适配器模式：</strong>由于系统提供的listview功能很少，所以需要写自定义控件，所谓的适配器模式，我的理解是类似电源适配器或者转接头之类的转换器。电源适配器将不适合机器工作的电压输出为机器适合的电压。转接头就更好理解了，将不配套的插头和插座连接在一起。适配器模式跟这个类似，将两个不相干的类作用在一起，使它们能配套适用。<br>①我们知道，作为最重要的ListView控件，要能显示各式各样的视图，每个人需要的显示效果都不一样。那么我们要做的就是隔离这种不一样的需求。<br>②在Android的解决方法是增加一个Adapter层来应对变化，将ListView需要的接口抽象到Adapter对象中，这样只要用户实现了Adapter的接口，ListView就可以按照用户设定的显示效果、数量、数据来显示特定的Item View。<br>③通过代理数据集来告知ListView数据的个数以及每个数据的类型，最重要的是要解决ItemView的输出。ItemView可以说因人而异，但它其实就是View类型，Adapter统一将ItemView输出为View (通过重写getView函数 )，这样就很好的应对了ItemView的可变性。</li>
<li>andriod自带的监听者模式  </li>
</ul>
</blockquote>
<p>未实现：</p>
<blockquote>
<ul>
<li><strong>外观模式：</strong>为了减少UI层与BLL层的耦合度，我们可以在U层和B层之间加入了外观模式,使U层和B层分离,为系统提供一个简单的接口、减少了它们之间的依赖，这样就做到了大幅度减少了耦合度</li>
<li><strong>抽象工厂：</strong>除了前面介绍的，还可以用于换肤，更换一整套按钮按<br>钮的分割</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ViewHolder viewHolder;</span><br><span class="line"><span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">       …………</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    …………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/软件分析与测试/第一次作业/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/软件分析与测试/第一次作业/" itemprop="url">第一次作业</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件分析与测试/" itemprop="url" rel="index">
                    <span itemprop="name">软件分析与测试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>#第一章 软件测试概述</p>
<p>##1、    怎么看待如下看似矛盾的测试观点：</p>
<p>###Q：程序中遗留的缺陷数量和检测出的缺陷数量成正比，请用自己的语言解释为什么在程序测试中会产生这种现象。</p>
<p>###A:每个程序员有自己编写代码产生缺陷的概率，而检测缺陷同样也是有概率发现的，一般来说，由于两方面都有缺陷，所以检测出来的缺陷越多，说明原来缺陷越多。 比如改完一个函数，与这个函数调用相关的缺陷，会受到影响。</p>
<p>##2、PIE Model 请构造一个简单的包含一行故障代码小程序，分别给出三个测试输入：</p>
<p>###1．    能够执行到故障代码E，但没有产生错误的中间状态I； </p>
<p>###2．    能够执行到故障代码E，并且产生了错误的中间状态I，但错误的中间状态没有传播出去P；<br>能够满足PIE三个条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">程序很简单，要求输入一个数字，得到屏幕显示“no error”</span><br><span class="line">程序错误点在数组越界，内存占用，导致程序析构时候失败。</span><br><span class="line">当输入在0~50 跳过不执行错误代码。</span><br><span class="line">当输入在51~200,这边定义char数组，越界但是不导致奔溃</span><br><span class="line">当输入在201~400 定义int数组，越界，析构时候奔溃。</span><br><span class="line">其他时候，直接输出no error</span><br></pre></td></tr></table></figure></p>
<p>代码样例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">	char a[N];</span><br><span class="line">	for (char i=0;i&lt;N+1 ;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=97;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;no error!&quot;&lt;&lt;endl;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">	int a[N];</span><br><span class="line">	for (int i=0;i&lt;N+1 ;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]=97;	</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;no error!&quot;&lt;&lt;endl;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test0(int flag)</span><br><span class="line">&#123;</span><br><span class="line">	if (flag&lt;50  &amp;&amp; flag &gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		int a[N];</span><br><span class="line">		for (int i=0;i&lt;N+1 ;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i]=97;	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;no error!&quot;&lt;&lt;endl;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;	</span><br><span class="line">	int flag;</span><br><span class="line">	cin&gt;&gt;flag;</span><br><span class="line">	if (flag&gt;=0&amp;&amp;flag&lt;=50)</span><br><span class="line">	&#123;</span><br><span class="line">		test0(100);//选择性执行</span><br><span class="line">	&#125;</span><br><span class="line">	else if(flag&gt;=51 &amp;&amp; flag&lt;=200)</span><br><span class="line">	&#123;</span><br><span class="line">		test1();//有错，执行，不崩溃。//第二种</span><br><span class="line">	&#125;</span><br><span class="line">	else if(flag&gt;=201 &amp;&amp; flag&lt;=400)</span><br><span class="line">	&#123;</span><br><span class="line">		test2();//有错，执行，崩溃。//第三种</span><br><span class="line">	&#125;</span><br><span class="line">	else	</span><br><span class="line">		cout&lt;&lt;&quot;no error&quot;&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/软件分析与测试/基于输入域的测试实验报告——三角形程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/软件分析与测试/基于输入域的测试实验报告——三角形程序/" itemprop="url">基于输入域的测试实验报告——三角形程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件分析与测试/" itemprop="url" rel="index">
                    <span itemprop="name">软件分析与测试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>#一、实验目的</p>
<blockquote>
<ul>
<li>（1）巩固基于输入域的测试技术，能熟练、灵活地应用多种基于输入域的测试方法设计测试用例；</li>
<li>（2）学习测试用例的书写。</li>
</ul>
</blockquote>
<hr>
<p>#二、实验内容</p>
<p>##判断三角形类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入三个整数a、b、c，分别作为三角形的三条边，通过程序判断这三条边是否能构成三角形？如果能构成三角形，则判断三角形的类型（等边三角形、等腰三角形、一般三角形）。要求输入三个整数a、b、c，必须满足以下条件：1≤a≤200；1≤b≤200；1≤c≤200。</span><br></pre></td></tr></table></figure></p>
<p>要求：</p>
<blockquote>
<ul>
<li>（1）    尝试使用随机测试的方法，随机生成5~8个测试用例；</li>
<li>（2）    分析程序输入域，结合程序输出结果，进行等价类划分，并给出详细测试用例；</li>
<li>（3）    结合（2）所划分的等价类，进行边界值分析（适当考虑程序的健壮性），并给出具体的测试用例；</li>
<li>（4）  利用因果图描述程序各输入、输出分量之间的因果关系以及约束； </li>
<li>（5）  采用决策表的方法，为程序设计完备且无冗余的测试用例</li>
<li>（6）  通过你的测试，请简单比较、总结你所使用的不同测试方法的特点。 </li>
</ul>
</blockquote>
<hr>
<p>#三、实验要求</p>
<blockquote>
<ul>
<li>（1）根据题目要求编写测试用例 </li>
<li>（2）撰写实验报告</li>
<li>（3）实验报告命名规则：学号后两位+姓名</li>
</ul>
</blockquote>
<hr>
<p>#四、实验报告</p>
<p>##（1）随机测试<br>![10.png-58.8kB][1]</p>
<hr>
<p>##（2）等价类划分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①分析程序的规格说明，列出输入变量a、 b、 c的有效等价类、无效等价类； </span><br><span class="line">②给出等价类表（每个等价类编号）</span><br><span class="line">③覆盖等价类表中的所有等价类，编写测试用例</span><br></pre></td></tr></table></figure></p>
<p>###2.1.等价类划分</p>
<p>####2.1.1.给定的输入条件要求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数量要求：3个数</span><br><span class="line">大小范围：1-200之间</span><br><span class="line">类型要求：整数</span><br><span class="line">功能要求：a+b&gt;c；a+c&gt;b；c+b&gt;a</span><br></pre></td></tr></table></figure></p>
<p>####2.1.2.给出等价类表<br>![01.png-37.7kB][2]</p>
<p>####2.1.3设计测试用例<br>覆盖上表的等价类，如下表所示：</p>
<p>#####2.1.3.1无效等价类<br>![02.png-181.6kB][3]</p>
<p>#####2.1.3.2有效等价类<br>![03.PNG-25.4kB][4]</p>
<hr>
<p>##（3）边界值分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">①根据（2）中所获得的等价类，分析输入变量的边界，给出边界测试用例</span><br><span class="line">②考虑程序的健壮性，适当补充健壮性测试用例</span><br></pre></td></tr></table></figure>
<p>###3.1边界值分析测试用例表<br>![04.png-58.2kB][5]</p>
<hr>
<p>##（4）因果图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①分析程序的规格说明，列出原因和结果</span><br><span class="line">②标明原因间、结果间的约束</span><br><span class="line">③适当增加中间节点，绘制因果图</span><br></pre></td></tr></table></figure></p>
<p>###4.1.原因和结果<br>![05.png-21.8kB][6]</p>
<p>###4.2.标明原因间、结果间的约束<br>原因间无明显约束，结果间，等腰与等边之间有着M约束关系。</p>
<p>###4.3.绘制因果图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">编号为 10， 11， 12 的中间节点是导出结果的进一步原因</span><br><span class="line">10:可以构成三角形</span><br><span class="line">11:任意两条边相等</span><br><span class="line">12：三条边两两相等</span><br></pre></td></tr></table></figure></p>
<p>![09.png-156.3kB][7]</p>
<hr>
<p>##（5）决策表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①分析程序的规格说明，列出条件桩、动作桩</span><br><span class="line">②分析条件项、动作项之间的约束，剔除无效或无意义的条件项</span><br><span class="line">③给出决策表（简化）</span><br><span class="line">④根据决策表，给出详细测试用例</span><br></pre></td></tr></table></figure></p>
<p>###5.1列出所有条件桩和动作桩<br>![06.png-16.6kB][8]</p>
<p>###5.2计算规则数<br>共6个条件，每个条件取值$y/n$，因此有$2^6=64$条规则  </p>
<p>###5.3填入条件项,填入动作项<br>        由于条件数目太多，把互斥的条件作简化</p>
<p>###5.4化简合并后的决策表<br>![07.png-26.8kB][9]</p>
<p>###5.5依照决策表生成测试用例<br>![08.png-25.3kB][10]</p>
<hr>
<p>##（6） 通过你的测试，请简单比较、总结你所使用的不同测试方法的特点。</p>
<blockquote>
<ul>
<li>①随机测试：<strong>随机</strong>选取用例，检测正确性</li>
<li>②等价类划分：等价类划分就是解决<strong>如何选择适当的数据子集</strong>来代表<strong>整</strong>个数据集的问题，通过<strong>降低测试的数目</strong>去实现“合理的”覆盖，覆盖了更多的可能数据，以发现更多的软件缺陷。</li>
<li>③边界值分析；边界分析是指对输入或输出的边界值进行的一种方法。所说的<strong>边界值是指输入等价类和输出等价类的边界值</strong>。经验证明大量的程序<strong>错误</strong>是<strong>发生</strong>在输入或输出范围的<strong>边界</strong>上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。</li>
<li>④因果图；从用自然语言书写的程序规格说明的描述中找出因（<strong>输入条件</strong>）和果（<strong>输出或程序状态的改变</strong>），可以通过因果图转换为判定表。其将质量问题与原因之间的关系表示出来，是分析影响产品质量的诸因素之间关系的一种工具。</li>
<li>⑤决策表；决策表又称判断表，是一种呈表格状的图形工具，适用于描述<strong>处理判断条件较多</strong>，各条件又相互组合、有多种决策方案的情况。</li>
</ul>
</blockquote>
<p>完成时间：2015年11月26日<br>  [1]: <a href="http://static.zybuluo.com/rg070836rg/ko02lafsgm5ineholwwjusew/10.png" target="_blank" rel="noopener">http://static.zybuluo.com/rg070836rg/ko02lafsgm5ineholwwjusew/10.png</a><br>  [2]: <a href="http://static.zybuluo.com/rg070836rg/8ncpbj67rtivxpub23fhs7ni/01.png" target="_blank" rel="noopener">http://static.zybuluo.com/rg070836rg/8ncpbj67rtivxpub23fhs7ni/01.png</a><br>  [3]: <a href="http://static.zybuluo.com/rg070836rg/3y4dksvyxoiw1mpqwoh1vaje/02.png" target="_blank" rel="noopener">http://static.zybuluo.com/rg070836rg/3y4dksvyxoiw1mpqwoh1vaje/02.png</a><br>  [4]: <a href="http://static.zybuluo.com/rg070836rg/d9m30d08z7ett21t4op7ekn2/03.PNG" target="_blank" rel="noopener">http://static.zybuluo.com/rg070836rg/d9m30d08z7ett21t4op7ekn2/03.PNG</a><br>  [5]: <a href="http://static.zybuluo.com/rg070836rg/2zueg610bjqvpk6qvhgx8qgh/04.png" target="_blank" rel="noopener">http://static.zybuluo.com/rg070836rg/2zueg610bjqvpk6qvhgx8qgh/04.png</a><br>  [6]: <a href="http://static.zybuluo.com/rg070836rg/pouij8ygjb4ggpvudt16hyu1/05.png" target="_blank" rel="noopener">http://static.zybuluo.com/rg070836rg/pouij8ygjb4ggpvudt16hyu1/05.png</a><br>  [7]: <a href="http://static.zybuluo.com/rg070836rg/l48c6o04t8xxdr8cnnjjqfkw/09.png" target="_blank" rel="noopener">http://static.zybuluo.com/rg070836rg/l48c6o04t8xxdr8cnnjjqfkw/09.png</a><br>  [8]: <a href="http://static.zybuluo.com/rg070836rg/x7kczecuywgmo1etlca1u9af/06.png" target="_blank" rel="noopener">http://static.zybuluo.com/rg070836rg/x7kczecuywgmo1etlca1u9af/06.png</a><br>  [9]: <a href="http://static.zybuluo.com/rg070836rg/90hz8zlygvuwhs70c884mwzl/07.png" target="_blank" rel="noopener">http://static.zybuluo.com/rg070836rg/90hz8zlygvuwhs70c884mwzl/07.png</a><br>  [10]: <a href="http://static.zybuluo.com/rg070836rg/zkfs4dzfxwaorrfxks6e4sv7/08.png" target="_blank" rel="noopener">http://static.zybuluo.com/rg070836rg/zkfs4dzfxwaorrfxks6e4sv7/08.png</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/软件分析与测试/基于组合与优化的测试方法——正交表测试示例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/软件分析与测试/基于组合与优化的测试方法——正交表测试示例/" itemprop="url">基于组合与优化的测试方法——正交表测试示例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件分析与测试/" itemprop="url" rel="index">
                    <span itemprop="name">软件分析与测试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>#示例：部门邮件发送问题</p>
<p>##1、问题描述<br>部门邮件发送问题<br><img src="http://static.zybuluo.com/rg070836rg/7edh6ergk8pjnp5igos0hk6f/01.png" alt="01.png-22.3kB"><br>测试可能取值如下表：<br><img src="http://static.zybuluo.com/rg070836rg/2sqqgwf7vzg9406bh2n0yv9y/02.png" alt="02.png-84.2kB"></p>
<p>##2、提取需求中的因子</p>
<blockquote>
<ul>
<li>（1）收件方</li>
<li>（2）主题    </li>
<li>（3）邮件内容</li>
<li>（4）落款人</li>
<li>（5）附件</li>
</ul>
</blockquote>
<p>##3、分析各因子状态</p>
<blockquote>
<ul>
<li>（1）收件方A：1=收件人，2=接收部门</li>
<li>（2）主题B：1=填写主题，2=主题为空</li>
<li>（3）邮件内容C：1=填写内容，2=内容为空</li>
<li>（4）落款人D：1=填写落款人，2=不填写落款人</li>
<li>（5）附件E：1=添加普通附件，2=添加超大附件，3=不添加附件</li>
</ul>
</blockquote>
<p>##4、选择正交表</p>
<blockquote>
<p>分析上面各因子状态数，可知，只有因子5有3各状态，其他因子都是2各状态。所以将因子五后面的2、3状态合并。采用5因子2状态正交表：$L_6(2^5)$，然后再拆分。</p>
</blockquote>
<p><img src="http://static.zybuluo.com/rg070836rg/zt45l92yxsy9hwrwggjqg972/03.png" alt="03.png-41.5kB"></p>
<p>##5、拆分正交表<br><img src="http://static.zybuluo.com/rg070836rg/f59q8eo9jyaakbmk1tz21js0/05.png" alt="05.png-41kB"></p>
<p>##6、替换正交表<br><img src="http://static.zybuluo.com/rg070836rg/pniy8l6yb35bymcgaekqyony/04.png" alt="04.png-65kB"></p>
<p>##7、正交表测试用例<br><img src="http://static.zybuluo.com/rg070836rg/np9oqv6uvriluu325z8fv5of/06.png" alt="06.png-140.8kB"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/软件分析与测试/9.17 软件测试作业/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/软件分析与测试/9.17 软件测试作业/" itemprop="url">9.17 软件测试作业</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件分析与测试/" itemprop="url" rel="index">
                    <span itemprop="name">软件分析与测试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题目要求：</span><br><span class="line">一、请构造一个尽可能简单的数值计算小程序P和两个测试用例t1和t2以及两个Fault(F1, F2)满足以下要求： </span><br><span class="line">1、在P中注入F1得到程序P1，使得t1 fail；</span><br><span class="line">2、在P中注入F2得到程序P2，使得t2 fail；</span><br><span class="line">3、在P中注入F1和F2得到程序P3，使得t1和t2都pass。</span><br></pre></td></tr></table></figure>
<p>分析：设计一个累加正数的程序，读到正数就累加，最后输出</p>
<p>##1 正确程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream.h&gt;</span><br><span class="line">/*</span><br><span class="line">* 程序用来求4个数中 大于0部分的和，下面是正确程序</span><br><span class="line">* 用例1： &#123;-1，-2，1，2&#125;  结果3</span><br><span class="line">* 用例2： &#123;-7，-1，8，0&#125;  结果8</span><br><span class="line">*/</span><br><span class="line">void main()</span><br><span class="line">&#123;   </span><br><span class="line">	int a[4];</span><br><span class="line">	int s=0;</span><br><span class="line">	for(int i=0;i&lt;4;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		if(a[i]&gt;0)</span><br><span class="line">			s+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试截图：</p>
<h2 id="2-fault1："><a href="#2-fault1：" class="headerlink" title="2 fault1："></a>2 fault1：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 程序用来求4个数中 大于0部分的和，下面是fault1程序,修改if部分小于号</span><br><span class="line">* 用例1： &#123;-1，-2，1，2&#125;  结果-3 错误</span><br><span class="line">* 用例2： &#123;-7，-1，8，0&#125;  结果-8 错误</span><br><span class="line">*/</span><br><span class="line">void main()</span><br><span class="line">&#123;   </span><br><span class="line">	int a[4];</span><br><span class="line">	int s=0;</span><br><span class="line">	for(int i=0;i&lt;4;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		if(a[i]&lt;0)</span><br><span class="line">			s+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-fault2："><a href="#3-fault2：" class="headerlink" title="3 fault2："></a>3 fault2：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 程序用来求4个数中 大于0部分的和，下面是fault2程序,修改累加部分符号</span><br><span class="line">* 用例1： &#123;-1，-2，1，2&#125;  结果-3 错误</span><br><span class="line">* 用例2： &#123;-7，-1，8，0&#125;  结果-8 错误</span><br><span class="line">*/</span><br><span class="line">void main()</span><br><span class="line">&#123;   </span><br><span class="line">	int a[4];</span><br><span class="line">	int s=0;</span><br><span class="line">	for(int i=0;i&lt;4;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		if(a[i]&gt;0)</span><br><span class="line">			s-=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-fault1与fault2："><a href="#3-fault1与fault2：" class="headerlink" title="3 fault1与fault2："></a>3 fault1与fault2：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 程序用来求4个数中 大于0部分的和，fault1 fault2 全改</span><br><span class="line">* 用例1： &#123;-1，-2，1，2&#125;  结果3</span><br><span class="line">* 用例2： &#123;-7，-1，8，0&#125;  结果8</span><br><span class="line">*/</span><br><span class="line">void main()</span><br><span class="line">&#123;   </span><br><span class="line">	int a[4];</span><br><span class="line">	int s=0;</span><br><span class="line">	for(int i=0;i&lt;4;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		if(a[i]&lt;0)</span><br><span class="line">			s-=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/Vendetta.jpg" alt="Chens">
            
              <p class="site-author-name" itemprop="name">Chens</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">198</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chens</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

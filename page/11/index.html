<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Chens">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="Chens">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chens">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/11/">





  <title>Chens</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chens</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/软件分析与测试/10.15软件测试作业--计算星期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/软件分析与测试/10.15软件测试作业--计算星期/" itemprop="url">10.15软件测试作业--计算星期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件分析与测试/" itemprop="url" rel="index">
                    <span itemprop="name">软件分析与测试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>#<strong>基于代码的测试实验报告——计算星期</strong> </p>
<hr>
<p>##<strong>一、实验目的</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）巩固基于代码的测试技术，能熟练应用控制流覆盖方法、逻辑覆盖方法等设计测试用例；</span><br><span class="line">（2）学习测试用例的书写。</span><br></pre></td></tr></table></figure></p>
<hr>
<p>##<strong>二、实验内容</strong></p>
<p>###计算日期是星期几<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已知公元1年1月1日是星期一。请编写一个程序，只要输入年月日，就能自动回答当天是星期几。</span><br></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">要求：</span><br><span class="line">为测试该程序的方便，请将计算星期的算法尽量放入一个函数中，输入和输出检查可用其它函数来处理。为简单起见，不考虑公元前的日期。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">（a）	解答思路：计算输入日期与公元1年1月1日所相差的天数，具体如下：</span><br><span class="line">总天数=公元1年到输入日期上一年年底天数+输入年份的1月到上月月底天数+输入日期的天数</span><br><span class="line">（b）	闰年满足条件：(year%4==0)&amp;&amp;(year%100!=0)||(year%400==0)</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）画出程序的流图；</span><br><span class="line">（2）分别以判定覆盖、条件覆盖、MC/DC覆盖标准设计测试用例，并写出每个测试用例的执行路径；</span><br><span class="line">（3）请采用基本路径覆盖（兼顾循环）、数据流覆盖标准对程序进行测试，并给出具体测试用例信息。</span><br><span class="line">（4）请采用变异测试的方法对你的原程序进行适当变异，获得3~4个变异体，执行上述（2）~（3）中的测试用例集，分析变异体的存活率，评估测试用例集的故障敏感度。</span><br><span class="line">（5）通过你的测试，请总结你所使用测试方法发现的Bug。</span><br><span class="line">要求：设计测试用例时，每种覆盖方法的覆盖率尽可能达到100%</span><br></pre></td></tr></table></figure>
<hr>
<p>##<strong>三、实验要求</strong></p>
<blockquote>
<ul>
<li>（1）根据题目要求编写测试用例 </li>
<li>（2）撰写实验报告</li>
<li>（3）有关的实现程序请附到实验报告中</li>
<li>（4）实验报告命名规则：学号后两位+姓名_基于代码的测试（计算星期）¬</li>
</ul>
</blockquote>
<hr>
<p>##<strong>四、实验报告</strong></p>
<p>###<strong>（1）程序代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool leapYear(int year);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;请输入年月日:&quot; &lt;&lt; endl;</span><br><span class="line">	int a, b, c;</span><br><span class="line">	string day;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">	int i, result = 0;</span><br><span class="line">	for(i=1;i&lt;=a-1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		result+=(leapYear(i)+365)%7;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i=1;i&lt;=b-1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(i==1||i==3||i==5||i==7||i==8||i==10||i==12)</span><br><span class="line">			result+=31;</span><br><span class="line">		else if(i==4||i==6||i==9||i==11)</span><br><span class="line">			result+=30;</span><br><span class="line">		else if(i==2)</span><br><span class="line">			result+=(28+leapYear(a));</span><br><span class="line">	&#125;</span><br><span class="line">	result+=c;</span><br><span class="line">	result%=7;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt;a&lt;&lt;&quot;年&quot;&lt;&lt;b&lt;&lt;&quot;月&quot;&lt;&lt;c&lt;&lt;&quot;日是星期&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool leapYear(int year)</span><br><span class="line">&#123;</span><br><span class="line">	return year%400==0 || year%100!=0 &amp;&amp; year%4==0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>###<strong>（2）程序控制流图</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">重要节点对应代码</span><br><span class="line">Node2   for(i=1;i&lt;=a-1;i++)</span><br><span class="line">Node4   for(i=1;i&lt;=b-1;i++)</span><br><span class="line">Node5   if(i==1||i==3||i==5||i==7||i==8||i==10||i==12)</span><br><span class="line">Node7   if(i==4||i==6||i==9||i==11)</span><br><span class="line">Node9   if(i==2)</span><br><span class="line">Node11  year%400==0 || year%100!=0 &amp;&amp; year%4==0;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start:  start</span><br><span class="line">op_00=&gt;operation: 1 </span><br><span class="line">cond_for_0=&gt;condition: 2 </span><br><span class="line">op_for_0=&gt;operation: 3 </span><br><span class="line"></span><br><span class="line">cond_for_1=&gt;condition: 4 </span><br><span class="line"></span><br><span class="line">cond_if_1=&gt;condition: 5</span><br><span class="line">cond_if_2=&gt;condition: 7 </span><br><span class="line">cond_if_3=&gt;condition: 9</span><br><span class="line"></span><br><span class="line">op_0=&gt;operation: 6</span><br><span class="line">op_1=&gt;operation: 8</span><br><span class="line">op_2=&gt;operation: 10</span><br><span class="line">op_3=&gt;operation: For</span><br><span class="line"></span><br><span class="line">op_4=&gt;operation: 12</span><br><span class="line">op_5=&gt;operation: 11 leap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st-&gt;op_00-&gt;cond_for_0</span><br><span class="line">cond_for_0(yes)-&gt;op_for_0-&gt;cond_for_0</span><br><span class="line">cond_for_0(no)-&gt;cond_for_1</span><br><span class="line">cond_for_1(yes)-&gt;cond_if_1</span><br><span class="line">cond_for_1(no)-&gt;op_4</span><br><span class="line">cond_if_1(yes)-&gt;op_0-&gt;op_3</span><br><span class="line">cond_if_1(no)-&gt;cond_if_2</span><br><span class="line">cond_if_2(yes)-&gt;op_1-&gt;op_3</span><br><span class="line">cond_if_2(no)-&gt;cond_if_3</span><br><span class="line">cond_if_3(yes)-&gt;op_2-&gt;op_5-&gt;op_3</span><br><span class="line">cond_if_3(no)-&gt;op_3-&gt;cond_for_1</span><br></pre></td></tr></table></figure>
<hr>
<p>###<strong>（3）判定覆盖</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P1  year%400==0 || year%100!=0 &amp;&amp; year%4==0;    闰年判定</span><br><span class="line">注释:由于for循环的不确定性，在此，执行路径省略</span><br></pre></td></tr></table></figure></p>
<hr>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>覆盖判定</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2008 8 8</td>
<td>P1</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>2007 7 8</td>
<td>-P1</td>
<td>7</td>
</tr>
</tbody>
</table>
<hr>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>闰年判定</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2008 8 8</td>
<td>True</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>2007 7 8</td>
<td>False</td>
<td>7</td>
</tr>
</tbody>
</table>
<hr>
<p>###<strong>（4）条件覆盖</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T3 year%400==0 </span><br><span class="line">T2 year%100!=0 </span><br><span class="line">T3 year%4==0;    闰年判定</span><br><span class="line">注释:由于for循环的不确定性，在此，执行路径省略</span><br></pre></td></tr></table></figure></p>
<hr>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>条件覆盖</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2000 8 8</td>
<td>T1 -T2 T3</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>2008 8 8</td>
<td>-T1 T2 T3</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>2001 8 8</td>
<td>-T1 T2 -T3</td>
<td>3</td>
</tr>
</tbody>
</table>
<hr>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>year%400==0</th>
<th>year%100!=0</th>
<th>year%4==0</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2000 8 8</td>
<td>True</td>
<td>False</td>
<td>True</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>2008 8 8</td>
<td>False</td>
<td>True</td>
<td>True</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>2001 8 8</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>3</td>
</tr>
</tbody>
</table>
<hr>
<p>###<strong>（5）MC/DC覆盖</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P1 year%400==0 || year%100!=0 &amp;&amp; year%4==0;    闰年判定</span><br><span class="line">T1 year%400==0 </span><br><span class="line">T2 year%100!=0 </span><br><span class="line">T3 year%4==0   </span><br><span class="line"></span><br><span class="line">注释:由于for循环的不确定性，在此，执行路径省略</span><br><span class="line">根据MC/DC特性，编写下述用例</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>T1</th>
<th>T2</th>
<th>T3</th>
<th>闰年判定</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1900 8 8</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>2001 8 8</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>2008 8 8</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>2000 8 8</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>2</td>
</tr>
</tbody>
</table>
<hr>
<p>###<strong>（6）基本路径覆盖</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start:  start</span><br><span class="line">op_00=&gt;operation: 1 </span><br><span class="line">cond_for_0=&gt;condition: 2 </span><br><span class="line">op_for_0=&gt;operation: 3 </span><br><span class="line"></span><br><span class="line">cond_for_1=&gt;condition: 4 </span><br><span class="line"></span><br><span class="line">cond_if_1=&gt;condition: 5</span><br><span class="line">cond_if_2=&gt;condition: 7 </span><br><span class="line">cond_if_3=&gt;condition: 9</span><br><span class="line"></span><br><span class="line">op_0=&gt;operation: 6</span><br><span class="line">op_1=&gt;operation: 8</span><br><span class="line">op_2=&gt;operation: 10</span><br><span class="line">op_3=&gt;operation: For</span><br><span class="line"></span><br><span class="line">op_4=&gt;operation: 12</span><br><span class="line">op_5=&gt;operation: 11 leap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st-&gt;op_00-&gt;cond_for_0</span><br><span class="line">cond_for_0(yes)-&gt;op_for_0-&gt;cond_for_0</span><br><span class="line">cond_for_0(no)-&gt;cond_for_1</span><br><span class="line">cond_for_1(yes)-&gt;cond_if_1</span><br><span class="line">cond_for_1(no)-&gt;op_4</span><br><span class="line">cond_if_1(yes)-&gt;op_0-&gt;op_3</span><br><span class="line">cond_if_1(no)-&gt;cond_if_2</span><br><span class="line">cond_if_2(yes)-&gt;op_1-&gt;op_3</span><br><span class="line">cond_if_2(no)-&gt;cond_if_3</span><br><span class="line">cond_if_3(yes)-&gt;op_2-&gt;op_5-&gt;op_3</span><br><span class="line">cond_if_3(no)-&gt;op_3-&gt;cond_for_1</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">圈复杂度：18（条边）-14（个节点）+ 2 = 6</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本路径集</span><br><span class="line">若测试年份大于1，那么所有路径都会被走过一遍，所以基本路径的长度与输入年份成正比，下罗列一种路径：</span><br><span class="line">S-1-2-3-2-4-5-6-4-5-7-8-4-5-7-9-10-11-4-5-7-9-4-12-E</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设计测试用例</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2000 8 8</td>
<td>2</td>
</tr>
</tbody>
</table>
<hr>
<p>###<strong>（7）数据流覆盖</strong></p>
<h4 id="程序的控制流图"><a href="#程序的控制流图" class="headerlink" title="程序的控制流图"></a><strong>程序的控制流图</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start:  start</span><br><span class="line">op_00=&gt;operation: 1 </span><br><span class="line">cond_for_0=&gt;condition: 2 </span><br><span class="line">op_for_0=&gt;operation: 3 </span><br><span class="line"></span><br><span class="line">cond_for_1=&gt;condition: 4 </span><br><span class="line"></span><br><span class="line">cond_if_1=&gt;condition: 5</span><br><span class="line">cond_if_2=&gt;condition: 7 </span><br><span class="line">cond_if_3=&gt;condition: 9</span><br><span class="line"></span><br><span class="line">op_0=&gt;operation: 6</span><br><span class="line">op_1=&gt;operation: 8</span><br><span class="line">op_2=&gt;operation: 10</span><br><span class="line">op_3=&gt;operation: For</span><br><span class="line"></span><br><span class="line">op_4=&gt;operation: 12</span><br><span class="line">op_5=&gt;operation: 11 leap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st-&gt;op_00-&gt;cond_for_0</span><br><span class="line">cond_for_0(yes)-&gt;op_for_0-&gt;cond_for_0</span><br><span class="line">cond_for_0(no)-&gt;cond_for_1</span><br><span class="line">cond_for_1(yes)-&gt;cond_if_1</span><br><span class="line">cond_for_1(no)-&gt;op_4</span><br><span class="line">cond_if_1(yes)-&gt;op_0-&gt;op_3</span><br><span class="line">cond_if_1(no)-&gt;cond_if_2</span><br><span class="line">cond_if_2(yes)-&gt;op_1-&gt;op_3</span><br><span class="line">cond_if_2(no)-&gt;cond_if_3</span><br><span class="line">cond_if_3(yes)-&gt;op_2-&gt;op_5-&gt;op_3</span><br><span class="line">cond_if_3(no)-&gt;op_3-&gt;cond_for_1</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="计算相关定义、引用集合、DU-定义-引用-路径"><a href="#计算相关定义、引用集合、DU-定义-引用-路径" class="headerlink" title="计算相关定义、引用集合、DU(定义/引用)路径"></a><strong>计算相关定义、引用集合、DU(定义/引用)路径</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结点的定义、引用变量</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Node</th>
<th>Def</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>{a,b,c,i,result}</td>
</tr>
<tr>
<td>2</td>
<td>{i}</td>
<td>{a}</td>
</tr>
<tr>
<td>3</td>
<td>{result}</td>
<td>{i}</td>
</tr>
<tr>
<td>4</td>
<td>{i}</td>
<td>{b}</td>
</tr>
<tr>
<td>5</td>
<td>{i}</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>{result}</td>
</tr>
<tr>
<td>7</td>
<td>{i}</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>{result}</td>
</tr>
<tr>
<td>9</td>
<td>{i}</td>
</tr>
<tr>
<td>10</td>
<td></td>
<td>{result,a}</td>
</tr>
<tr>
<td>11</td>
<td>{year}</td>
<td>{year}</td>
</tr>
<tr>
<td>12</td>
<td>{result}</td>
<td>{a,b,c,result}</td>
</tr>
</tbody>
</table>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边的引用变量</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Edge</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1,2)</td>
<td>{a,i}</td>
</tr>
<tr>
<td>(2,3)</td>
<td>{i}</td>
</tr>
<tr>
<td>(3,2)</td>
</tr>
<tr>
<td>(2,4)</td>
</tr>
<tr>
<td>(4,5)</td>
<td>{i,b}</td>
</tr>
<tr>
<td>(5,7)</td>
<td>{i}</td>
</tr>
<tr>
<td>(7,9)</td>
<td>{i}</td>
</tr>
<tr>
<td>(5,6)</td>
<td>{result}</td>
</tr>
<tr>
<td>(7,8)</td>
<td>{result}</td>
</tr>
<tr>
<td>(9,10)</td>
<td>{result}</td>
</tr>
<tr>
<td>(10,11)</td>
<td>{a}</td>
</tr>
<tr>
<td>(4,12)</td>
<td>{a,b,c,result}</td>
</tr>
</tbody>
</table>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DU(定义/引用)路径</span><br></pre></td></tr></table></figure>
<p><table><br>  <tr><br>    <th colspan="3">DU(定义/引用)路径</th><br>  </tr><br>  <tr><br>        <th>Variable</th><br>        <th>DU Pairs</th><br>        <th>DU Paths</th><br>    </tr></table></p>
  <tr><br>    <td rowspan="3">a</td><br>    <td>(1,2)</td><br>    <td>[1,2]</td><br>  </tr><br>  <tr><br>    <td>(1,10)<br></td><br>    <td>[1,2,4,5,7,9,10]</td><br>  </tr><br>  <tr><br>    <td>(1,12)</td><br>    <td>[1,2,4,5,7,9,10,11,12]</td><br>  </tr>


   <tr><br>    <td rowspan="2">b</td><br>    <td>(1,4)</td><br>    <td>[1,2]</td><br>  </tr><br>    <tr><br>    <td>(1,12)<br></td><br>    <td>[1,2,4,5,7,9,10,11,12]</td><br>  </tr>

   <tr><br>    <td rowspan="1">c</td><br>    <td>(1,12)</td><br>    <td>[1,2,4,5,7,9,10,11,12]</td><br>  </tr>

<p>   <tr><br>    <td rowspan="5">result<br>    </td><br>    <td>(3,6)</td><br>    <td>[3,2,4,5,6]</td><br>  </tr><br>    <tr><br>    <td>(3,8)<br></td><br>    <td>[3,2,4,5,7,8]</td><br>  </tr><br>  <tr><br>    <td>(3,10)</td><br>    <td>[3,2,4,5,7,9,10]</td><br>  </tr><br>  <tr><br>    <td>(3,12)</td><br>    <td>[3,2,4,5,7,9,10,11,4,12]</td><br>  </tr><br>  <tr><br>    <td>(12,12)</td><br>    <td>[12]</td><br>  </tr></p>
<h2 id><a href="#" class="headerlink" title></a></h2><h4 id="基于代码的覆盖——数据流覆盖"><a href="#基于代码的覆盖——数据流覆盖" class="headerlink" title="基于代码的覆盖——数据流覆盖"></a><strong>基于代码的覆盖——数据流覆盖</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">共11条DU路径，8条唯一</span><br><span class="line">[1,2]</span><br><span class="line">[1,2,4,5,7,9,10]</span><br><span class="line">[1,2,4,5,7,9,10,11,12]</span><br><span class="line">[3,2,4,5,6]</span><br><span class="line">[3,2,4,5,7,8]</span><br><span class="line">[3,2,4,5,7,9,10]</span><br><span class="line">[3,2,4,5,7,9,10,11,4,12]</span><br><span class="line">[12]</span><br></pre></td></tr></table></figure>
<hr>
<p>###<strong>（8）变异测试</strong></p>
<p>####<strong>变异体一</strong>：<br>与源代码相比改变闰年判定条件中的常数值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool leapYear_1(int year)</span><br><span class="line">&#123;</span><br><span class="line">    return year%40==0 || year%100!=0 &amp;&amp; year%4==0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>####<strong>变异体二</strong>：<br>与源代码相比改变闰年判定条件中的或条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool leapYear_2(int year)</span><br><span class="line">&#123;</span><br><span class="line">    return year%400==0 &amp;&amp; year%100!=0 &amp;&amp; year%4==0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>####<strong>变异体三</strong>：<br>与源代码相比，改变闰年判定条件中的等式判定条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool leapYear_3(int year)</span><br><span class="line">&#123;</span><br><span class="line">    return year%400==0 &amp;&amp; year%100==0 &amp;&amp; year%4==0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>####<strong>变异体四</strong>：</p>
<p>与源代码相比，省略闰年判定中的某个条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool leapYear_4(int year)</span><br><span class="line">&#123;</span><br><span class="line">    return year%400==0 || year%100!=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>####<strong>变异体改变汇总</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P:return year%400==0 || year%100!=0 &amp;&amp; year%4==0;</span><br><span class="line">M1:return year%40==0 || year%100!=0 &amp;&amp; year%4==0;</span><br><span class="line">M2:return year%400==0 &amp;&amp; year%100!=0 &amp;&amp; year%4==0;</span><br><span class="line">M3:return year%400==0 &amp;&amp; year%100==0 &amp;&amp; year%4==0;</span><br><span class="line">M4:return year%400==0 || year%100!=0;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>#####<strong>测试用例集</strong><br>| 编号 |  a |b |c<br>|—| —– | —- | —- |<br>|t1|2008|8|8<br>|t2|2007|7|8<br>|t3|2000 |8| 8<br>|t4|2001| 8| 8<br>|t5|1900| 8| 8</p>
<hr>
<p>#####<strong>测试执行结果</strong><br>| 测试编号 | P |M1|M2|M3|M4|杀死的变异体<br>|— | —– | —- | —- | —- | —- |—-|<br>|t1|5|5|4|4|5|M2 M3<br>|t2|7|7|7|7|1|M4<br>|t3|2|2|1|2|2|M2<br>|t4|3|3|3|3|4|M4<br>|t5|3|3|3|3|3|无</p>
<hr>
<p>#####<strong>测试用例集的充分性</strong><br>| 测试用例| 测试用例集的充分性|<br>|——-| —- |— | —– |<br>|t1|50%|<br>|t2|25%|<br>|t3|25%|<br>|t4|25%|<br>|t5|0%|</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/软件分析与测试/10.15软件测试作业--三角形/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/软件分析与测试/10.15软件测试作业--三角形/" itemprop="url">10.15软件测试作业--三角形</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件分析与测试/" itemprop="url" rel="index">
                    <span itemprop="name">软件分析与测试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="白盒测试实验报告——三角形"><a href="#白盒测试实验报告——三角形" class="headerlink" title="#白盒测试实验报告——三角形 "></a>#<strong>白盒测试实验报告——三角形</strong> </h2><p>##<strong>一、实验目的</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）巩固白盒测试技术，能熟练应用控制流覆盖方法设计测试用例；</span><br><span class="line">（2）学习测试用例的书写。</span><br></pre></td></tr></table></figure></p>
<hr>
<p>##<strong>二、实验内容</strong></p>
<p>###判断三角形类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入三个整数a、b、c，分别作为三角形的三条边，通过程序判断这三条边是否能构成三角形？如果能构成三角形，则判断三角形的类型（等边三角形、等腰三角形、一般三角形）。要求输入三个整数a、b、c，必须满足以下条件：1≤a≤200；1≤b≤200；1≤c≤200。</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>要求：</strong><br>为测试该程序的方便，请将三角形判断的算法尽量放入一个函数中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）画出程序的控制流图；</span><br><span class="line">（2）分别以判定覆盖、条件覆盖、判定/条件覆盖、全条件覆盖、MC/DC覆盖设计测试用例，并写出每个测试用例的执行路径（全覆盖满足困难时，可适当简化）；</span><br><span class="line">（3）请采用基本路径测试方法（兼顾循环测试）对程序进行测试用例的设计；</span><br><span class="line">（4）通过你的测试，请总结你所使用测试方法发现的Bug。</span><br><span class="line">要求：设计测试用例时，每种覆盖方法的覆盖率应尽可能达到100%</span><br></pre></td></tr></table></figure></p>
<hr>
<p>##<strong>三、实验要求</strong></p>
<blockquote>
<ul>
<li>根据题目要求编写测试用例 </li>
<li>撰写实验报告</li>
<li>有关的实现程序请附到实验报告中</li>
<li>实验报告命名规则：学号后两位+姓名_白盒实验¬</li>
</ul>
</blockquote>
<hr>
<p>##<strong>四、实验报告</strong></p>
<p>###<strong>（1）程序代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_tir</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(a&lt;<span class="number">1</span>||a&gt;<span class="number">200</span>||b&lt;<span class="number">1</span>||b&gt;<span class="number">200</span>||c&lt;<span class="number">1</span>||c&gt;<span class="number">200</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"输入的值不符合条件，请重新输入："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((a+b&lt;=c)||(b+c&lt;=a)||(a+c&lt;=b))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"非三角形"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a==b&amp;&amp;b==c)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"等边三角形"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((a==b)||(b==c)||(a==c))</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"等腰三角形"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"是三角形"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a,b,c;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入三条边"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">	test_tir(a,b,c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>###<strong>（2）程序控制流图</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数字代表行数</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 4 start</span><br><span class="line">cond_while_0=&gt;condition: 6 合法性</span><br><span class="line">op_while_1=&gt;operation: 8 非法提示</span><br><span class="line">op_while_2=&gt;operation: 9 输入abc</span><br><span class="line"></span><br><span class="line">cond_if_0=&gt;condition: 11 </span><br><span class="line">cond_if_1=&gt;condition: 17 </span><br><span class="line">cond_if_2=&gt;condition: 19 </span><br><span class="line"></span><br><span class="line">op_cout_0=&gt;operation: 13 非三角形</span><br><span class="line">op_cout_1=&gt;operation: 18 等边三角形</span><br><span class="line">op_cout_2=&gt;operation: 20 等腰三角形</span><br><span class="line">op_cout_3=&gt;operation: 22 三角形</span><br><span class="line"></span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;cond_while_0</span><br><span class="line">cond_while_0(yes)-&gt;op_while_1-&gt;op_while_2-&gt;cond_while_0</span><br><span class="line">cond_while_0(no)-&gt;cond_if_0</span><br><span class="line">cond_if_0(yes)-&gt;op_cout_0-&gt;e</span><br><span class="line">cond_if_0(no)-&gt;cond_if_1</span><br><span class="line">cond_if_1(yes)-&gt;op_cout_1-&gt;e</span><br><span class="line">cond_if_1(no)-&gt;cond_if_2</span><br><span class="line">cond_if_2(yes)-&gt;op_cout_2-&gt;e</span><br><span class="line">cond_if_2(no)-&gt;op_cout_3-&gt;e</span><br></pre></td></tr></table></figure>
<hr>
<p>###<strong>（3）判定覆盖</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P1:覆盖判定 6: while(a&lt;1||a&gt;200||b&lt;1||b&gt;200||c&lt;1||c&gt;200) 合法性</span><br><span class="line">P2:覆盖判定11: if((a+b&lt;=c)||(b+c&lt;=a)||(a+c&lt;=b))          三角形判定</span><br><span class="line">P3:覆盖判定17: if(a==b&amp;&amp;b==c)                            等边三角形判定</span><br><span class="line">P4:覆盖判定19: else if((a==b)||(b==c)||(b==c))           等腰三角形判定</span><br></pre></td></tr></table></figure></p>
<hr>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>执行路径</th>
<th>覆盖判定</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0 0 0</td>
<td>4-6-8-9-6</td>
<td>-P1    </td>
</tr>
<tr>
<td>2</td>
<td>1 2 3</td>
<td>4-6-11-13-E</td>
<td>P1 P2</td>
<td>非三角形        </td>
</tr>
<tr>
<td>3</td>
<td>6 6 6</td>
<td>4-6-11-17-18-E</td>
<td>P1 -P2 P3</td>
<td>等边三角形</td>
</tr>
<tr>
<td>4</td>
<td>6 6 7</td>
<td>4-6-11-17-19-20-E</td>
<td>P1 -P2 -P3 P4</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>5</td>
<td>3 4 5</td>
<td>4-6-11-17-19-22-E</td>
<td>P1 -P2 -P3 -P4</td>
<td>三角形</td>
</tr>
</tbody>
</table>
<hr>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>执行路径</th>
<th>数据合法性判定</th>
<th>三角形判定</th>
<th>等边判定</th>
<th>等腰判定</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0 0 0</td>
<td>4-6-8-9-6</td>
<td>False</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>1 2 3</td>
<td>4-6-11-13-E</td>
<td>True</td>
<td>True</td>
<td></td>
<td></td>
<td>非三角形        </td>
</tr>
<tr>
<td>3</td>
<td>6 6 6</td>
<td>4-6-11-17-18-E</td>
<td>True</td>
<td>False</td>
<td>True</td>
<td></td>
<td>等边三角形</td>
</tr>
<tr>
<td>4</td>
<td>6 6 7</td>
<td>4-6-11-17-19-20-E</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>5</td>
<td>3 4 5</td>
<td>4-6-11-17-19-22-E</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>三角形</td>
</tr>
</tbody>
</table>
<hr>
<p>###<strong>（4）条件覆盖</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">条件如下：</span><br><span class="line">T1：a+b&lt;=c</span><br><span class="line">T2：b+c&lt;=a</span><br><span class="line">T3：a+c&lt;=b </span><br><span class="line">T4：a==b</span><br><span class="line">T5：b==c</span><br><span class="line">T6：a==c</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>执行路径</th>
<th>条件覆盖</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1 1 2</td>
<td>4-6-8-9-6</td>
<td>T1</td>
<td>非三角形</td>
</tr>
<tr>
<td>2</td>
<td>3 1 1</td>
<td>4-6-8-9-6</td>
<td>-T1 T2</td>
<td>非三角形    </td>
</tr>
<tr>
<td>3</td>
<td>1 3 1</td>
<td>4-6-8-9-6</td>
<td>-T1 -T2 T3</td>
<td>非三角形</td>
</tr>
<tr>
<td>4</td>
<td>6 6 6</td>
<td>4-6-11-17-18-E</td>
<td>-T1 -T2 -T3 T4 T5</td>
<td>等边三角形</td>
</tr>
<tr>
<td>5</td>
<td>6 6 7</td>
<td>4-6-11-17-19-20-E</td>
<td>-T1 -T2 -T3 T4 -T5 -T6</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>6</td>
<td>3 4 4</td>
<td>4-6-11-17-19-20-E</td>
<td>-T1 -T2 -T3 -T4 T5 -T6</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>7</td>
<td>4 3 4</td>
<td>4-6-11-17-19-20-E</td>
<td>-T1 -T2 -T3 -T4 -T5 T6</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>8</td>
<td>3 4 5</td>
<td>4-6-11-17-19-22-E</td>
<td>-T1 -T2 -T3 -T4 -T5 -T6</td>
<td>三角形</td>
</tr>
</tbody>
</table>
<hr>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>执行路径</th>
<th>a+b&lt;=c</th>
<th>b+c&lt;=a</th>
<th>a+c&lt;=b</th>
<th>a==b</th>
<th>b==c</th>
<th>a==c</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1 1 2</td>
<td>4-6-8-9-6</td>
<td>True</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>非三角形</td>
</tr>
<tr>
<td>2</td>
<td>3 1 1</td>
<td>4-6-8-9-6</td>
<td>False</td>
<td>True</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>非三角形    </td>
</tr>
<tr>
<td>3</td>
<td>1 3 1</td>
<td>4-6-8-9-6</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td></td>
<td></td>
<td></td>
<td>非三角形</td>
</tr>
<tr>
<td>4</td>
<td>6 6 6</td>
<td>4-6-11-17-18-E</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>True</td>
<td></td>
<td>等边三角形</td>
</tr>
<tr>
<td>5</td>
<td>6 6 7</td>
<td>4-6-11-17-19-20-E</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>False</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>6</td>
<td>3 4 4</td>
<td>4-6-11-17-19-20-E</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>7</td>
<td>4 3 4</td>
<td>4-6-11-17-19-20-E</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>8</td>
<td>3 4 5</td>
<td>4-6-11-17-19-22-E</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>三角形</td>
</tr>
</tbody>
</table>
<hr>
<p>###<strong>（5）判定/条件覆盖</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简化掉输入检测与三角形判定。</span><br><span class="line">T1:a==b</span><br><span class="line">T2:b==c</span><br><span class="line">T3:a==c</span><br><span class="line">P1:if(a==b&amp;&amp;b==c)                   等边三角形判定 </span><br><span class="line">P2:else if((a==b)||(b==c)||(b==c))  等腰三角形判定</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>执行路径</th>
<th>覆盖判定/条件</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3 3 4</td>
<td>4-6-11-17-19-20-E</td>
<td>T1 -T2 -T3 -P1 P2</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>2</td>
<td>4 3 3</td>
<td>4-6-11-17-19-20-E</td>
<td>-T1 T2 -T3 -P1 P2</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>3</td>
<td>3 4 3</td>
<td>4-6-11-17-19-20-E</td>
<td>-T1 -T2 T3 -P1 P2</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>4</td>
<td>3 3 3</td>
<td>4-6-11-17-18-20-E</td>
<td>T1 T2  P1</td>
<td>等边三角形    </td>
</tr>
<tr>
<td>5</td>
<td>3 4 5</td>
<td>4-6-11-17-19-22-E</td>
<td>-T1 -T2 -T3 -P1 -P2</td>
<td>三角形</td>
</tr>
</tbody>
</table>
<hr>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>执行路径</th>
<th>a==b</th>
<th>b==c</th>
<th>a==c</th>
<th>等边三角形判定</th>
<th>等腰三角形判定</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3 3 4</td>
<td>4-6-11-17-19-20-E</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>2</td>
<td>4 3 3</td>
<td>4-6-11-17-19-20-E</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>3</td>
<td>3 4 3</td>
<td>4-6-11-17-19-20-E</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>4</td>
<td>3 3 3</td>
<td>4-6-11-17-18-20-E</td>
<td>true</td>
<td>true</td>
<td></td>
<td>true</td>
<td></td>
<td>等边三角形    </td>
</tr>
<tr>
<td>5</td>
<td>3 4 5</td>
<td>4-6-11-17-19-22-E</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>三角形</td>
</tr>
</tbody>
</table>
<hr>
<p>###<strong>（6）全条件覆盖（可适当简化）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">同样，省略前面的判定，只保留最后几步判定</span><br><span class="line">T1:a==b</span><br><span class="line">T2:b==c</span><br><span class="line">T3:a==c</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>执行路径</th>
<th>覆盖全条件</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3 4 5</td>
<td>4-6-11-17-19-22-E</td>
<td>-T1 -T2 -T3</td>
<td>三角形</td>
</tr>
<tr>
<td>2</td>
<td>3 4 3</td>
<td>4-6-11-17-19-20-E</td>
<td>-T1 -T2 T3</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>3</td>
<td>4 3 3</td>
<td>4-6-11-17-19-20-E</td>
<td>-T1 T2 -T3</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>4</td>
<td>不存在</td>
<td></td>
<td>-T1 T2 T3</td>
</tr>
<tr>
<td>5</td>
<td>3 3 4</td>
<td>4-6-11-17-19-20-E</td>
<td>T1 -T2 -T3</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>6</td>
<td>不存在</td>
<td></td>
<td>T1 -T2 T3</td>
</tr>
<tr>
<td>7</td>
<td>不存在</td>
<td></td>
<td>T1 T2 -T3</td>
</tr>
<tr>
<td>8</td>
<td>3 3 3</td>
<td>4-6-11-17-18-20-E</td>
<td>T1 T2 T3</td>
<td>等边三角形</td>
</tr>
</tbody>
</table>
<hr>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>执行路径</th>
<th>a==b</th>
<th>b==c</th>
<th>a==c</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3 4 5</td>
<td>4-6-11-17-19-22-E</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>三角形</td>
</tr>
<tr>
<td>2</td>
<td>3 4 3</td>
<td>4-6-11-17-19-20-E</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>3</td>
<td>4 3 3</td>
<td>4-6-11-17-19-20-E</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>4</td>
<td>不存在</td>
<td></td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>5</td>
<td>3 3 4</td>
<td>4-6-11-17-19-20-E</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>6</td>
<td>不存在</td>
<td></td>
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>7</td>
<td>不存在</td>
<td></td>
<td>true</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>8</td>
<td>3 3 3</td>
<td>4-6-11-17-18-20-E</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>等边三角形</td>
</tr>
</tbody>
</table>
<hr>
<p>###<strong>（7）MC/DC覆盖</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MC/DC是修改的条件/判定覆盖</span><br><span class="line">简化掉输入检测与三角形判定。</span><br><span class="line">T1:a==b</span><br><span class="line">T2:b==c</span><br><span class="line">T3:a==c</span><br><span class="line">P1:if(a==b&amp;&amp;b==c)                   等边三角形判定 </span><br><span class="line">P2:else if((a==b)||(b==c)||(a==c))  等腰三角形判定</span><br></pre></td></tr></table></figure></p>
<hr>
<p>下面就P1:if(a==b&amp;&amp;b==c)  进行MC/DC覆盖<br>| 编号 | 测试用例  |a==b|b==c|等边三角形判定|输出结果|<br>|—| —– | —- | —- | —- | —- | —- |<br>| 1|3 3 3|T|T|T|等边三角形|<br>| 2|3 4 4|F|T|F|等腰三角形|<br>| 3|3 3 4|T|F|F|等腰三角形|</p>
<hr>
<p>下面就P2:else if((a==b)||(b==c)||(a==c))  进行MC/DC覆盖</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>测试用例</th>
<th>a==b</th>
<th>b==c</th>
<th>a==c</th>
<th>等腰三角形判定</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3 4 5</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>三角形</td>
</tr>
<tr>
<td>2</td>
<td>3 4 3</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>3</td>
<td>3 4 4</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>4</td>
<td>3 3 4</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>等腰三角形</td>
</tr>
</tbody>
</table>
<hr>
<p>###<strong>（8）基本路径覆盖</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: S</span><br><span class="line">cond_while_0=&gt;condition: 1 </span><br><span class="line">op_while_1=&gt;operation: 2 </span><br><span class="line">op_while_2=&gt;operation: 3 </span><br><span class="line"></span><br><span class="line">cond_if_0=&gt;condition: 4 </span><br><span class="line">cond_if_1=&gt;condition: 6</span><br><span class="line">cond_if_2=&gt;condition: 8</span><br><span class="line"></span><br><span class="line">op_cout_0=&gt;operation: 5</span><br><span class="line">op_cout_1=&gt;operation: 7 </span><br><span class="line">op_cout_2=&gt;operation: 9 </span><br><span class="line">op_cout_3=&gt;operation: 10 </span><br><span class="line"></span><br><span class="line">e=&gt;end: E</span><br><span class="line"></span><br><span class="line">st-&gt;cond_while_0</span><br><span class="line">cond_while_0(yes)-&gt;op_while_1-&gt;op_while_2-&gt;cond_while_0</span><br><span class="line">cond_while_0(no)-&gt;cond_if_0</span><br><span class="line">cond_if_0(yes)-&gt;op_cout_0-&gt;e</span><br><span class="line">cond_if_0(no)-&gt;cond_if_1</span><br><span class="line">cond_if_1(yes)-&gt;op_cout_1-&gt;e</span><br><span class="line">cond_if_1(no)-&gt;cond_if_2</span><br><span class="line">cond_if_2(yes)-&gt;op_cout_2-&gt;e</span><br><span class="line">cond_if_2(no)-&gt;op_cout_3-&gt;e</span><br></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">圈复杂度：15（条边）-12（个节点）+ 2 = 5</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基本路径集</span><br><span class="line">路径1：1—2—3—4—10</span><br><span class="line">路径2：1—2—3—5—6—10</span><br><span class="line">路径3：1—2—3—5—7—8—10</span><br><span class="line">路径4：1—2—3—5—7—9—10</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设计测试用例</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>编号</th>
<th>执行路径</th>
<th>测试用例</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>S-1-2-3-1</td>
<td>-1 -1 -1</td>
<td>不符合条件</td>
</tr>
<tr>
<td>2</td>
<td>S-1-4-5-E</td>
<td>1 2 3</td>
<td>非三角形</td>
</tr>
<tr>
<td>3</td>
<td>S-1-4-6-7-E</td>
<td>6 6 6</td>
<td>等边三角形</td>
</tr>
<tr>
<td>4</td>
<td>S-1-4-6-8-9-E</td>
<td>3 3 4</td>
<td>等腰三角形</td>
</tr>
<tr>
<td>5</td>
<td>S-1-4-6-8-10-E</td>
<td>3 4 5</td>
<td>普通三角形</td>
</tr>
</tbody>
</table>
<hr>
<p>###<strong>（9）数据流覆盖</strong></p>
<h4 id="程序的控制流图"><a href="#程序的控制流图" class="headerlink" title="程序的控制流图"></a><strong>程序的控制流图</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 1 start</span><br><span class="line">cond_while_0=&gt;condition: 2 合法性</span><br><span class="line">op_while_1=&gt;operation: 3 非法提示</span><br><span class="line">op_while_2=&gt;operation: 4 输入abc</span><br><span class="line"></span><br><span class="line">cond_if_0=&gt;condition: 5 </span><br><span class="line">cond_if_1=&gt;condition: 7 </span><br><span class="line">cond_if_2=&gt;condition: 9 </span><br><span class="line"></span><br><span class="line">op_cout_0=&gt;operation: 6 非三角形</span><br><span class="line">op_cout_1=&gt;operation: 8 等边三角形</span><br><span class="line">op_cout_2=&gt;operation: 10 等腰三角形</span><br><span class="line">op_cout_3=&gt;operation: 11 三角形</span><br><span class="line"></span><br><span class="line">e=&gt;end: 12 end</span><br><span class="line"></span><br><span class="line">st-&gt;cond_while_0</span><br><span class="line">cond_while_0(yes)-&gt;op_while_1-&gt;op_while_2-&gt;cond_while_0</span><br><span class="line">cond_while_0(no)-&gt;cond_if_0</span><br><span class="line">cond_if_0(yes)-&gt;op_cout_0-&gt;e</span><br><span class="line">cond_if_0(no)-&gt;cond_if_1</span><br><span class="line">cond_if_1(yes)-&gt;op_cout_1-&gt;e</span><br><span class="line">cond_if_1(no)-&gt;cond_if_2</span><br><span class="line">cond_if_2(yes)-&gt;op_cout_2-&gt;e</span><br><span class="line">cond_if_2(no)-&gt;op_cout_3-&gt;e</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="计算相关定义、引用集合、DU-定义-引用-路径"><a href="#计算相关定义、引用集合、DU-定义-引用-路径" class="headerlink" title="计算相关定义、引用集合、DU(定义/引用)路径"></a><strong>计算相关定义、引用集合、DU(定义/引用)路径</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结点的定义、引用变量</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Node</th>
<th>Def</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>{a,b,c}</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>{a,b,c}</td>
</tr>
<tr>
<td>3</td>
<td>{a,b,c}</td>
</tr>
<tr>
<td>4</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>{a,b,c}</td>
</tr>
<tr>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>{a,b,c}</td>
</tr>
<tr>
<td>8</td>
</tr>
<tr>
<td>9</td>
<td></td>
<td>{a,b,c}</td>
</tr>
<tr>
<td>10</td>
</tr>
<tr>
<td>11</td>
</tr>
<tr>
<td>12</td>
</tr>
</tbody>
</table>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">边的引用变量</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Edge</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1,2)</td>
</tr>
<tr>
<td>(2,3)</td>
<td>{a,b,c}</td>
</tr>
<tr>
<td>(3,4)</td>
</tr>
<tr>
<td>(2,5)</td>
<td>{a,b,c}</td>
</tr>
<tr>
<td>(5,7)</td>
<td>{a,b,c}</td>
</tr>
<tr>
<td>(7,9)</td>
<td>{a,b,c}</td>
</tr>
<tr>
<td>(9,11)</td>
<td>{a,b,c}</td>
</tr>
<tr>
<td>(5,6)</td>
</tr>
<tr>
<td>(7,8)</td>
</tr>
<tr>
<td>(9,10)</td>
</tr>
</tbody>
</table>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DU(定义/引用)路径</span><br></pre></td></tr></table></figure>
<p><table><br>  <tr><br>    <th colspan="3">DU(定义/引用)路径</th><br>  </tr><br>  <tr><br>        <th>Variable</th><br>        <th>DU Pairs</th><br>        <th>DU Paths</th><br>    </tr></table></p>
  <tr><br>    <td rowspan="5">a</td><br>    <td>(1,2)</td><br>    <td>[1,2]</td><br>  </tr><br>  <tr><br>    <td>(3,2)<br></td><br>    <td>[3,4,2]</td><br>  </tr><br>  <tr><br>    <td>(1,5)</td><br>    <td>[1,2,5]</td><br>  </tr><br>  <tr><br>    <td>(1,7)</td><br>    <td>[1,2,5,7]</td><br>  </tr><br>  <tr><br>    <td>(1,9)</td><br>    <td>[1,2,5,7,9]</td><br>  </tr>

<p>   <tr><br>    <td rowspan="5">b</td><br>    <td>(1,2)</td><br>    <td>[1,2]</td><br>  </tr><br>    <tr><br>    <td>(3,2)<br></td><br>    <td>[3,4,2]</td><br>  </tr><br>  <tr><br>    <td>(1,5)</td><br>    <td>[1,2,5]</td><br>  </tr><br>  <tr><br>    <td>(1,7)</td><br>    <td>[1,2,5,7]</td><br>  </tr><br>  <tr><br>    <td>(1,9)</td><br>    <td>[1,2,5,7,9]</td><br>  </tr><br>   <tr><br>    <td rowspan="5">c</td><br>    <td>(1,2)</td><br>    <td>[1,2]</td><br>  </tr><br>    <tr><br>    <td>(3,2)<br></td><br>    <td>[3,4,2]</td><br>  </tr><br>  <tr><br>    <td>(1,5)</td><br>    <td>[1,2,5]</td><br>  </tr><br>  <tr><br>    <td>(1,7)</td><br>    <td>[1,2,5,7]</td><br>  </tr><br>  <tr><br>    <td>(1,9)</td><br>    <td>[1,2,5,7,9]</td><br>  </tr></p>
<h2 id><a href="#" class="headerlink" title></a></h2><h4 id="基于代码的覆盖——数据流覆盖"><a href="#基于代码的覆盖——数据流覆盖" class="headerlink" title="基于代码的覆盖——数据流覆盖"></a><strong>基于代码的覆盖——数据流覆盖</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">共15条DU路径，5条唯一</span><br><span class="line">[1,2]</span><br><span class="line">[3,4,2]</span><br><span class="line">[1,2,5]</span><br><span class="line">[1,2,5,7]</span><br><span class="line">[1,2,5,7,9]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试用例:0 0 0</span><br><span class="line">测试路径：1-2-3-4-2</span><br><span class="line">覆盖的DU路径：[1,2] [3,4,2]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试用例:3 4 5</span><br><span class="line">测试路径：1-2-5-7-9-11-12</span><br><span class="line">覆盖的DU路径：[1,2,5] [1,2,5,7] [1,2,5,7,9]</span><br></pre></td></tr></table></figure>
<hr>
<p>###<strong>（10）变异覆盖</strong></p>
<p>####<strong>变异体一</strong>：<br>与源代码相比，第3行被改变，即由<code>a&lt;1||a&gt;200||b&lt;1||b&gt;200||c&lt;1||c&gt;200</code>变成<code>a&gt;200||b&lt;1||b&gt;200||c&lt;1||c&gt;200</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void test_tir_by4(int a,int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">    while(a&gt;200||b&lt;1||b&gt;200||c&lt;1||c&gt;200)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;输入的值不符合条件，请重新输入：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    &#125;</span><br><span class="line">    if((a+b&lt;=c)||(b+c&lt;=a)||(a+c&lt;=b))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;非三角形&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(a==b&amp;&amp;b==c)</span><br><span class="line">            cout&lt;&lt;&quot;等边三角形&quot;&lt;&lt;endl;</span><br><span class="line">        else if((a==b)||(b==c)||(a==c))</span><br><span class="line">            cout&lt;&lt;&quot;等腰三角形&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;&quot;是三角形&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>####<strong>变异体二</strong>：<br>与源代码相比，第8行的第一个条件被改变，即<code>a+b&lt;=c</code>变成<code>a+b&gt;=c</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void test_tir_by1(int a,int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">    while(a&lt;1||a&gt;200||b&lt;1||b&gt;200||c&lt;1||c&gt;200)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;输入的值不符合条件，请重新输入：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    &#125;</span><br><span class="line">    if((a+b&gt;=c)||(b+c&lt;=a)||(a+c&lt;=b))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;非三角形&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(a==b&amp;&amp;b==c)</span><br><span class="line">            cout&lt;&lt;&quot;等边三角形&quot;&lt;&lt;endl;</span><br><span class="line">        else if((a==b)||(b==c)||(a==c))</span><br><span class="line">            cout&lt;&lt;&quot;等腰三角形&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;&quot;是三角形&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>####<strong>变异体三</strong>：<br>与源代码相比，第14行被改变，即由<code>a==b&amp;&amp;b==c</code>变成<code>a==b&amp;&amp;b==c&amp;&amp;c==a</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void test_tir_by2(int a,int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">    while(a&lt;1||a&gt;200||b&lt;1||b&gt;200||c&lt;1||c&gt;200)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;输入的值不符合条件，请重新输入：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    &#125;</span><br><span class="line">    if((a+b&lt;=c)||(b+c&lt;=a)||(a+c&lt;=b))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;非三角形&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(a==b&amp;&amp;b==c&amp;&amp;c==a)</span><br><span class="line">            cout&lt;&lt;&quot;等边三角形&quot;&lt;&lt;endl;</span><br><span class="line">        else if((a==b)||(b==c)||(a==c))</span><br><span class="line">            cout&lt;&lt;&quot;等腰三角形&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;&quot;是三角形&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>####<strong>变异体四</strong>：<br>与源代码相比，第16行被改变，即由<code>(a==b)||(b==c)||(a==c)</code>变成<code>(a==b)||(b==c)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void test_tir_by3(int a,int b,int c)</span><br><span class="line">&#123;</span><br><span class="line">    while(a&lt;1||a&gt;200||b&lt;1||b&gt;200||c&lt;1||c&gt;200)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;输入的值不符合条件，请重新输入：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    &#125;</span><br><span class="line">    if((a+b&lt;=c)||(b+c&lt;=a)||(a+c&lt;=b))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;非三角形&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(a==b&amp;&amp;b==c)</span><br><span class="line">            cout&lt;&lt;&quot;等边三角形&quot;&lt;&lt;endl;</span><br><span class="line">        else if((a==b)||(b==c))</span><br><span class="line">            cout&lt;&lt;&quot;等腰三角形&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;&quot;是三角形&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>####<strong>变异体改变汇总</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M1:第03行由     a&lt;1||a&gt;200..            变成    a&gt;200..</span><br><span class="line">M2:第08行由     a+b&lt;=c                  变成    a+b&gt;=c</span><br><span class="line">M3:第14行由     a==b&amp;&amp;b==c              变成    a==b&amp;&amp;b==c&amp;&amp;c==a</span><br><span class="line">M4:第16行由     (a==b)||(b==c)||(a==c)  变成    (a==b)||(b==c)</span><br></pre></td></tr></table></figure></p>
<hr>
<p>#####<strong>测试用例集</strong><br>| 编号 |  a |b |c<br>|—| —– | —- | —- |<br>|t1|0|1|1<br>|t2|1|2|3<br>|t3|6|6|6<br>|t4|6|6|7<br>|t5|3|4|5<br>|t6|1|1|2<br>|t7|3|1|1<br>|t8|1|3|1<br>|t9|3|4|4<br>|t10|4|3|4<br>|t11|4|3|3</p>
<hr>
<p>#####<strong>测试执行结果</strong><br>| 测试编号 | P |M1|M2|M3|M4|杀死的变异体<br>|— | —– | —- | —- | —- | —- |—-|<br>|t1|不符合|非三角形|不符合|不符合|不符合|M1<br>|t2|非三角形|非三角形|非三角形|非三角形|非三角形|无<br>|t3|等边三角形|等边三角形|非三角形|等边三角形|等边三角形|M2<br>|t4|等腰三角形|等腰三角形|非三角形|等腰三角形|等腰三角形|M2<br>|t5|三角形|三角形|非三角形|三角形|三角形|M2<br>|t6|非三角形|非三角形|非三角形|非三角形|非三角形|无<br>|t7|非三角形|非三角形|非三角形|非三角形|非三角形|无<br>|t8|非三角形|非三角形|非三角形|非三角形|非三角形|无<br>|t9|等腰三角形|等腰三角形|非三角形|等腰三角形|等腰三角形|M2<br>|t10|等腰三角形|等腰三角形|非三角形|等腰三角形|三角形|M2 M4<br>|t11|等腰三角形|等腰三角形|非三角形|等腰三角形|等腰三角形|M2</p>
<hr>
<p>#####<strong>测试用例集的充分性</strong><br>| 测试用例| 测试用例集的充分性| 测试用例| 测试用例集的充分性<br>|——-| —- |— | —– |<br>|t1|25%|t2|0%<br>|t3|25%|t4|25%<br>|t5|25%|t6|0%<br>|t7|0%|t8|0%<br>|t9|25%|t10|50%<br>|t11|25%</p>
<hr>
<p>####<strong>变异体分析</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变异体M1:</span><br><span class="line">源程序(a&lt;1||a&gt;200..)变成a&gt;200少了对于a&lt;1的判定，所以当b、c满足条件时,会产生错误，对于测试用例0 3 4产生影响。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变异体M2:</span><br><span class="line">源程序(a+b&lt;=c)变成(a+b&gt;=c)改变了判定条件，使得大多是的三角形判定失败，对很多用例产生了影响。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变异体M3:</span><br><span class="line">源程序(a==b&amp;&amp;b==c)变成(a==b&amp;&amp;b==c&amp;&amp;c==a)，但是由于前两个条件保证了第三个条件的成立性，所以变异体程序对结果没有影响，是等价变异体</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变异体M4:</span><br><span class="line">源程序((a==b)||(b==c)||(a==c))变成((a==b)||(b==c))，对于某些等腰三角形的判定产生了影响，比如用例4 3 4 会被误判为普通三角形。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/软件安全/软件安全复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/软件安全/软件安全复习/" itemprop="url">软件安全复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件安全/" itemprop="url" rel="index">
                    <span itemprop="name">软件安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>12.26 悬疑</p>
<p>第一章：<br>软件安全怎么理解？什么是软件安全？p5不给分<br>回答安全属性 cia保密 完整 可用性<br>用信息安全的属性来解释软件安全<br>书上的只是讲了为什么要研究软件安全</p>
<p>版权<br>还要看资料，记录等补充的东西？</p>
<p>第二章<br>没怎么讲</p>
<p>第三章<br>提到了很多的漏洞以及产生的原因，有四个大题目<br>比如web三层架构存在的漏洞以及存在的问题<br>每一块要分析，跟我们的作业有关<br>web三层架构是什么？<br>每一块 前端后端传输存在的问题有哪些<br>要分析</p>
<p>还与威胁建模有关系</p>
<p>什么叫缓冲区溢出？按照书/课上讲的<br>首先缓冲区是什么<br>什么是堆栈，跟第四张4.1.1/.2/.3/.4<br>名词解释，<br>格式化串漏洞  （给你一段代码，问问题）课上都讲过的<br>（sql注入，缓冲区一处，格式化串）</p>
<p>4.2 跨站脚本xss<br>跨站请求伪造csrf</p>
<p>也会在大题目用到，在前端还是后端？<br>xss？前端？后端</p>
<p>什么叫模糊测试<br>什么叫渗透测试</p>
<p>或者什么叫静态/动态分析</p>
<p>第六章肯定会考</p>
<p>windows下面 安全防护机制有哪些？<br>/gs   dep（数据执行保护）<br>地址空间分布随机化<br>/safe？？不能只写名字，要写意思，要解释</p>
<p>第七章<br>拆成了好几章，<br>开发<br>题目多<br>比如说<br>安全开发周期模型sdl，什么是sdl<br>威胁建模中的作业 stride是什么  五类威胁的缩写？<br>s欺骗。。</p>
<p>sd3原则  安全设计原则<br>sd3+c（conmunication）（书上的不对）是沟通</p>
<p>渗透模糊静态动态测试</p>
<p>身份认证+访问控制<br>比如用户名密码属于身份认证的什么<br>身份认证一般分为三大类<br>what you konw/have/are<br>口令属于你知道什么know<br>校园卡，U盾之类的叫have<br>安全性稍微高一点<br>are，刷指纹之类的</p>
<p>验证码起到什么作用1.区分人机2.otp一次性口令认证哈希加盐为什么要哈希加盐<br>不能用什么对称?/非对称区别</p>
<p>访问控制指的是你能干什么<br>考rbac基于角色的访问控制<br>合并同类项？1W人可能只有4类权限<br>例如 管理员一类，教务，学生，教师</p>
<p>第八章<br>什么是恶意代码  概念<br>恶意代码的种类  分类<br>防护的主要技术  模型<br>特征可信<br>身份可信 identity<br>能力 行为可信<br>环境可信</p>
<p>8-11  四章   考简答题</p>
<p>第四部分<br>软件自我保护<br>简答题：软件知识产权面临什么样的威胁以及常用的技术保护措施</p>
<p>有序列号验证<br>keyfile验证<br>网络验证<br>光盘验证<br>加密锁验证<br>软件狗 safenet<br>代码</p>
<p>几个名词解释<br>堆栈 xss 说过的4个-5个20分</p>
<p>没有选择 填空 判断</p>
<p>谈谈对软件安全的理解</p>
<p>四个大题目 40分<br>比如说 程序题一个 问题（注入，缓冲区溢出）<br>材料分析 例子<br>京东泄露12G信息，请你从软件开发者角度来谈谈你对这个事件的认识<br>要有技术性 从模型开始介绍，那前面的内容来答</p>
<p>美国大规模断网–什么是ddos攻击<br>怎么实施ddos攻击   大规模请求超出了负荷，  什么请求？什么东西瘫痪的<br>dns查询攻击   硬件漏洞<br>攻击原理的分析</p>
<p>威胁建模分析  更具体</p>
<p>世纪佳缘被逮<br>月饼们事件<br>绝对控制？电影<br>1.谈个人修养<br>2.谈漏洞管理 挖到漏洞以后 从国家公司层面 应该怎么管理？法律制度<br>技术 道德 法律 个人修养</p>
<p>10分<br>问这学期做了哪些实验，看了什么书，包括电影，谈谈自己的体会什么的</p>
<p>红帽子 黑帽子 灰帽子</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/人流量/活动、移动联合建模/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/人流量/活动、移动联合建模/" itemprop="url">活动、移动联合建模</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/人流量/" itemprop="url" rel="index">
                    <span itemprop="name">人流量</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Who-Where-When-and-What-Discover-Spatio-Temporal-Topics-for-Twitter-Users"><a href="#Who-Where-When-and-What-Discover-Spatio-Temporal-Topics-for-Twitter-Users" class="headerlink" title="Who, Where, When and What: Discover Spatio-Temporal Topics for Twitter Users"></a>Who, Where, When and What: Discover Spatio-Temporal Topics for Twitter Users</h3><p><em>KDD’13, August 11–14, 2013, Chicago, Illinois, USA.</em><br><em>Quan Yuan, Gao Cong, Zongyang Ma, Aixin Sun, Nadia Magnenat-Thalmann</em></p>
<h4 id="模型与方法："><a href="#模型与方法：" class="headerlink" title="模型与方法："></a><strong>模型与方法：</strong></h4><ul>
<li><p>四个直觉想法：</p>
<ul>
<li>(1)人的移动可以被区分在不同的区域，比如生活区域和工作区域，在不同时间段会待在不同区域</li>
<li>(2)用户在一个区域的目的收到用户个人兴趣和位置区域功能类型的双重影响 </li>
<li>(3)当用户选择去什么地方的时候，自己的兴趣需求和当前所处的位置会被综合考虑 </li>
<li>(4)用户推特中的文字信息会随着地理区域和兴趣主题的不同而变化</li>
</ul>
</li>
<li><p>特征选取与生成过程：</p>
<ul>
<li>日期状态s，$p(s|u)$ 服从工作日和休息日两个状态的二项分布</li>
<li>时间t，$p(t|u,s)$ 服从均匀分布/高斯混合分布</li>
<li>区域r，$p(r|u,s,t)$ 服从多项分布</li>
<li>活动主题z，$p(z|u,r)$ 服从多项分布</li>
<li>具体位置l，$p(l|r,z)=κp(l|z)+(1-κ)p(l|r)$ ，其中p(l|r)是经过转换后的高斯分布</li>
<li>推特单词w，$p(w|r,z)=λp(w|z)+(1-λ)p(w|r)$ </li>
</ul>
</li>
<li><p>推特的联合概率分布$$p(u,r,z,s,t,l,w)  \=p(u)p(s|u)p(t|u,s)p(r|u,s,t)p(z|u,r)p(l|r,z)p(w|r,z)\=p(u)p(s|u)p(r|u,s)p(t|u,s,r)p(z|u,r)p(l|r,z)p(w|r,z) $$  </p>
<p>其中$p(r|u,s)$、$p(z|u,r)$等参数用EM算法根据历史数据进行对数似然估计</p>
</li>
<li><p>有了联合概率分布，就可以预测其中的任何一项条件概率</p>
</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>语义信息用关键词表示，语义信息和位置信息联合建模</li>
<li>只考虑随时间变化</li>
<li>都采用了常见的概率分布</li>
</ul>
<h3 id="What’s-Your-Next-Move-User-Activity-Prediction-in-Location-based-Social-Networks"><a href="#What’s-Your-Next-Move-User-Activity-Prediction-in-Location-based-Social-Networks" class="headerlink" title="What’s Your Next Move: User Activity Prediction in Location-based Social Networks"></a>What’s Your Next Move: User Activity Prediction in Location-based Social Networks</h3><p><em>Proceedings of the 2013 SIAM International Conference on Data Mining</em><br><em>Jihang Ye, Zhe Zhu, Hong Cheng</em></p>
<h4 id="模型与方法：-1"><a href="#模型与方法：-1" class="headerlink" title="模型与方法："></a><strong>模型与方法：</strong></h4><ul>
<li>用HMM刻画用户在位置类型间的转移来代表活动规律，将活动信息视为观察变量</li>
<li>考虑到用户的活动规律依赖于当时的情景，添加了时间-位置协同变量，将HMM变成了Mixed HMM</li>
<li>对相似用户做了聚类，用HMM刻画了用户类在位置类型上的转移规律</li>
<li>预测到下一步用户要去的位置类型后，再预测具体位置，提出4种给位置排序的方法，分别是基于总签到次数，用户数，用户数*签到数，用户最大签到数。</li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>活动信息用POI的类型来表示，对活动信息进行独立建模</li>
<li>在活动的转移规律的基础上，考虑了时间-位置协同作用</li>
<li>对具体位置预测直接采用排序方式</li>
</ul>
<h3 id="Lifting-the-Predictability-of-Human-Mobility-on-Activity-Trajectories"><a href="#Lifting-the-Predictability-of-Human-Mobility-on-Activity-Trajectories" class="headerlink" title="Lifting the Predictability of Human Mobility on Activity Trajectories"></a>Lifting the Predictability of Human Mobility on Activity Trajectories</h3><p><em>2015 IEEE 15th International Conference on Data Mining Workshops</em><br><em>Xianming Li, Defu Lian, Xing Xie and Guangzhong Sun</em></p>
<h4 id="模型与方法：-2"><a href="#模型与方法：-2" class="headerlink" title="模型与方法："></a><strong>模型与方法：</strong></h4><ul>
<li>假设用户下一个访问的位置只取决于之前访问的位置序列$Г$以及下一次访问时间和准备要进行的活动:$$P(l_{n+1},t_{n+1},a_{n+1}|Г<em>u) = P(l</em>{n+1}|l_{1:n},t_{n+1},a_{n+1})*P(t_{n+1},a_{n+1}|Г_u)$$（1）</li>
<li>不同时间的不同活动之间是有内在联系的，并且这种潜在的联系在不同用户之间是共享的，同时用户有各自的属性，相似属性的用户很可能有相似的移动规律。选用主题模型来对活动的规律进行建模。</li>
<li>将时间-活动元组当作单词，将活动轨迹当作文档，用户的属性为文档的元数据。</li>
<li>使用随机EM算法和吉布森采样来估计主体模型相关参数，包括每个用户的活动主题分布$p(k|u)$，每个主题上的单词分布$φ_{k,w}$，前后状态的依赖$p(z_i|z_{i-1})$</li>
<li>使用隐马尔科夫模型来建立活动间的转移模型，即可得出(1)式右端第二项$P(t_{n+1},a_{n+1}|Г<em>u)$，活动主题作为隐变量，用户的活动作为观测值，初始状态是$p(k|u)$，发射概率是$φ</em>{k,w}$，状态转移概率是$p(z_i|z_{i-1})$</li>
<li>(1)式右端第一项不容易直接估计，可以将其转换成3个条件概率的混合$$P(l_{n+1}|l_{1:n},t_{n+1},a_{n+1}) = λ<em>lP(l</em>{n+1}|l_{1:n}) + λ<em>tP(l</em>{n+1}|t_{n+1}) + λ<em>aP(l</em>{n+1}|a_{n+1})$$</li>
<li>$P(l_{n+1}|l_{1:n})$可以使用马尔科夫模型来估计</li>
<li>另外两项可以使用EM算法做极大似然估计</li>
</ul>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>活动信息用词汇向量表示，活动规律单独建模</li>
<li>用户和活动的关系用主题模型建模，转移规律用隐马模型建模，把时间也当作预测的输出之一</li>
<li>移动规律转化成3个条件概率的混合</li>
</ul>
<h3 id="Personalized-Point-of-Interest-Recommendation-by-Mining-Users’-Preference-Transition"><a href="#Personalized-Point-of-Interest-Recommendation-by-Mining-Users’-Preference-Transition" class="headerlink" title="Personalized Point-of-Interest Recommendation by Mining Users’ Preference Transition"></a>Personalized Point-of-Interest Recommendation by Mining Users’ Preference Transition</h3><p><em>CIKM’13， Xin Liu, Yong Liu and Karl Aberer</em></p>
<h4 id="模型与方法：-3"><a href="#模型与方法：-3" class="headerlink" title="模型与方法："></a>模型与方法：</h4><ul>
<li>将相隔时间在一定范围内的活动组成一个序列，称为story，认为story内的活动是相关的，关注与story内的活动转移规律；</li>
<li>根据用户签到相似性，对用户进行聚类，减轻数据稀疏的影响。抽取了用户在每种类型的POI上签到的时间片分布，用k-means进行聚类；</li>
<li>用协同过滤的方法对用户组在POI类型上的转移做预测，通过对用户-转移概率矩阵做分解，得到用户特征向量和转移概率特征向量。在矩阵分解时采用了正则化方法；</li>
<li>得到了POI类型转移规律，综合考虑用户的活动目的和地理空间的影响。利用前面得到的结果得出活动的概率分布，假设地理空间的影响服从幂律分布，最终选择一个POI的概率为类型概率*地理空间影响。</li>
</ul>
<h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>活动目的用POI的类型表示，活动规律单独建模</li>
<li>不考虑时间因素，只考虑转移概率，对位置预测考虑了地理空间影响</li>
<li>活动规律建模时，考虑了用户行为的相似性，进行了聚类和协同过滤</li>
</ul>
<h3 id="Location-Recommendation-Based-on-Periodicity-of-Human-Activities-and-Location-Categories"><a href="#Location-Recommendation-Based-on-Periodicity-of-Human-Activities-and-Location-Categories" class="headerlink" title="Location Recommendation Based on Periodicity of Human Activities and Location Categories"></a>Location Recommendation Based on Periodicity of Human Activities and Location Categories</h3><p><em>PAKDD 2013, Seyyed Mohammadreza Rahimi and Xin Wang</em></p>
<h4 id="模型与方法：-4"><a href="#模型与方法：-4" class="headerlink" title="模型与方法："></a>模型与方法：</h4><ul>
<li>将用户在同一时间窗口内访问相同类型位置的行为划分到一个子集</li>
<li>利用每个子集内用户签到的平均时刻来估计用户活动的时间分布，建立起以时间为随机变量，用户进行各种类型活动的概率分布</li>
<li>在此基础上，进行位置推荐时，综合考虑该时刻用户活动目的，以及位置因素影响，具体由该位置和用户家所在地的距离相关</li>
</ul>
<h4 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>活动目的用POI的类型表示，活动规律单独建模</li>
<li>只考虑时间因素，不考虑转移概率，对位置预测考虑了地理空间影响</li>
</ul>
<h3 id="Collaborative-Filtering-Meets-Mobile-Recommendation-A-User-centered-Approach"><a href="#Collaborative-Filtering-Meets-Mobile-Recommendation-A-User-centered-Approach" class="headerlink" title="Collaborative Filtering Meets Mobile Recommendation: A User-centered Approach"></a>Collaborative Filtering Meets Mobile Recommendation: A User-centered Approach</h3><p><em>AAAI 2010, Vincent W. Zheng, Bin Cao, Yu Zheng, Xing Xie and Qiang Yang</em></p>
<h4 id="模型与方法：-5"><a href="#模型与方法：-5" class="headerlink" title="模型与方法："></a>模型与方法：</h4><ul>
<li>将用户-位置-活动三个维度构成一个张量，通过张量分解，分解出用户特征向量、位置特征向量和活动特征向量</li>
<li>用协同过滤的方式进行位置推荐</li>
</ul>
<h4 id="特点：-4"><a href="#特点：-4" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>活动目的用POI的类型表示，活动规律和位置规律联合建模</li>
<li>没有考虑地理空间的因素，也没有考虑时间特征影响</li>
</ul>
<h4 id="Inferring-and-Exploiting-Categories-for-Next-Location-Prediction"><a href="#Inferring-and-Exploiting-Categories-for-Next-Location-Prediction" class="headerlink" title="Inferring and Exploiting Categories for Next Location Prediction"></a>Inferring and Exploiting Categories for Next Location Prediction</h4><p><em>Www’15 Companion: Proceedings of the 24th International Conference on World Wide Web</em> </p>
<p><em>Likhyani A. ,  Padmanabhan D. , Bedathur S. , Mehta, S.</em></p>
<h4 id="模型与方法：-6"><a href="#模型与方法：-6" class="headerlink" title="模型与方法："></a>模型与方法：</h4><ul>
<li>将用户下一步进行的活动概率用用户自己的活动转移概率和所有用户的活动转移概率线性结合表示</li>
<li>由用户的活动目的再得到他下一步到访位置的概率</li>
<li>将活动目的的概率结合一个现有的考虑了时间、历史记录和社交关系的模型线性结合</li>
</ul>
<h4 id="特点：-5"><a href="#特点：-5" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>活动目的用POI的类型表示，类型和位置不需要一一对应</li>
<li>活动规律和位置规律分别建模</li>
<li>最后和其它因素线性结合考虑</li>
</ul>
<h4 id="TOPTRAC-Topical-Trajectory-Pattern-Mining"><a href="#TOPTRAC-Topical-Trajectory-Pattern-Mining" class="headerlink" title="TOPTRAC: Topical Trajectory Pattern Mining"></a>TOPTRAC: Topical Trajectory Pattern Mining</h4><p><em>2015, Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</em></p>
<p><em>Kim Younghoon, Han  Jiawei, Yuan Cangzhou</em></p>
<p><strong>模型与方法:</strong></p>
<ul>
<li>生成模型，位置生成主题，主题生成关键词，生成推文和位置的主体是否相关</li>
<li>位置间的转移pattern由频繁模式挖掘来发现？</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>活动信息由推文表示，位置和语义联合建模</li>
<li>只挖掘2阶的频繁区域转移</li>
<li>不考虑时间因素</li>
</ul>
<p>[16]</p>
<h3 id="Spatial-topic-modeling-in-online-social-media-for-location-recommendation"><a href="#Spatial-topic-modeling-in-online-social-media-for-location-recommendation" class="headerlink" title="Spatial topic modeling in online social media for location recommendation"></a>Spatial topic modeling in online social media for location recommendation</h3><p><em>RecSys’13, Hu Bo, Ester Martin</em></p>
<p><strong>模型与方法：</strong></p>
<ul>
<li>生成模型，区域生成主题，区域主题生成位置，主题生成推文</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>活动信息由推文表示，位置和语义联合建模</li>
<li>只根据当前背景状态生成用户最感兴趣的位置，因此不用考虑时间因素</li>
</ul>
<h3 id="GeoSoCa-Exploiting-Geographical-Social-and-Categorical-Correlations-for-Point-of-Interest-Recommendations"><a href="#GeoSoCa-Exploiting-Geographical-Social-and-Categorical-Correlations-for-Point-of-Interest-Recommendations" class="headerlink" title="GeoSoCa: Exploiting Geographical, Social and Categorical Correlations for Point-of-Interest Recommendations"></a>GeoSoCa: Exploiting Geographical, Social and Categorical Correlations for Point-of-Interest Recommendations</h3><p><em>SIGIR’15 , Zhang Jia-Dong , Chow Chi-Yin</em></p>
<h4 id="模型与方法：-7"><a href="#模型与方法：-7" class="headerlink" title="模型与方法："></a>模型与方法：</h4><ul>
<li>综合考虑了地理距离、社交关系和POI的类型，采用计分的方法，分别对三个方面打分</li>
<li>用核密度估计来估计地理距离的影响</li>
<li>朋友对POI的影响用幂律分布来刻画</li>
<li>同时考虑用户对POI类型的爱好和位置的流行度</li>
</ul>
<h4 id="特点：-6"><a href="#特点：-6" class="headerlink" title="特点："></a>特点：</h4><ul>
<li>活动信息由POI类型表示，一个POI可能对应几个类型</li>
<li>位置和语义分别建模</li>
<li>综合考虑了多种影响</li>
</ul>
<h4 id="参考内容："><a href="#参考内容：" class="headerlink" title="参考内容："></a>参考内容：</h4><p>Related work</p>
<h1 id="位置预测研究总结"><a href="#位置预测研究总结" class="headerlink" title="位置预测研究总结"></a>位置预测研究总结</h1><p>标签（空格分隔）： References</p>
<hr>
<h2 id="What’s-Your-Next-Move-User-Activity-Prediction-in-Location-based-Social-Networks-1"><a href="#What’s-Your-Next-Move-User-Activity-Prediction-in-Location-based-Social-Networks-1" class="headerlink" title="What’s Your Next Move: User Activity Prediction in Location-based Social Networks"></a>What’s Your Next Move: User Activity Prediction in Location-based Social Networks</h2><p><em>Proceedings of the 2013 SIAM International Conference on Data Mining</em><br><em>Jihang Ye, Zhe Zhu, Hong Cheng</em></p>
<h4 id="模型与方法：-8"><a href="#模型与方法：-8" class="headerlink" title="模型与方法："></a><strong>模型与方法：</strong></h4><ul>
<li>位置用POI表示（name,longitude,latitude,category）</li>
<li>用HMM刻画用户在位置类型间的转移来代表活动规律</li>
<li>考虑到用户的活动规律依赖于当时的情景，添加了时间-位置协同变量</li>
<li>对相似用户做了聚类，用HMM刻画了用户类在位置类型上的转移规律</li>
<li>预测到下一步用户要去的位置类型后，再预测具体位置，提出4种给位置排序的方法，分别是基于总签到次数，用户数，用户数*签到数，用户最大签到数。</li>
</ul>
<h4 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a><strong>存在的问题：</strong></h4><ul>
<li>没有利用到地理空间的任何信息，时间段作为输入</li>
<li>对没有历史记录的场所，在预测好位置类型后，无法给出排名</li>
</ul>
<p>##Who, Where, When and What: Discover Spatio-Temporal Topics for Twitter Users<br><em>KDD’13, August 11–14, 2013, Chicago, Illinois, USA.</em><br><em>Quan Yuan, Gao Cong, Zongyang Ma, Aixin Sun, Nadia Magnenat-Thalmann</em></p>
<h4 id="模型与方法：-9"><a href="#模型与方法：-9" class="headerlink" title="模型与方法："></a><strong>模型与方法：</strong></h4><ul>
<li>四个直觉想法：<ul>
<li>(1)人的移动可以被区分在不同的区域，比如生活区域和工作区域，在不同时间段会待在不同区域</li>
<li>(2)用户在一个区域的目的收到用户个人兴趣和位置区域功能类型的双重影响 </li>
<li>(3)当用户选择去什么地方的时候，自己的兴趣需求和当前所处的位置会被综合考虑 </li>
<li>(4)用户推特中的文字信息会随着地理区域和兴趣主题的不同而变化</li>
</ul>
</li>
<li><p>特征选取与生成过程：</p>
<ul>
<li>日期状态s，p(s|u)服从工作日和休息日两个状态的二项分布</li>
<li>时间t，p(t|u,s)服从均匀分布/高斯混合分布</li>
<li>区域r，p(r|u,s,t)服从多项分布</li>
<li>活动主题z，p(z|u,r)服从多项分布</li>
<li>具体位置l，p(l|r,z)=κp(l|z)+(1-κ)p(l|r)，其中p(l|r)是经过转换后的高斯分布</li>
<li>推特单词w，p(w|r,z)=λp(w|z)+(1-λ)p(w|r)</li>
</ul>
</li>
<li><p>推特的联合概率分布 $$p(u,r,z,s,t,l,w)  \= p(u)p(s|u)p(t|u,s)p(r|u,s,t)p(z|u,r)p(l|r,z)p(w|r,z)\<br>=p(u)p(s|u)p(r|u,s)p(t|u,s,r)p(z|u,r)p(l|r,z)p(w|r,z)$$其中p(r|u,s)、p(z|u,r)等参数用EM算法根据历史数据进行对数似然估计</p>
</li>
<li>有了联合概率分布，就可以预测其中的任何一项条件概率</li>
</ul>
<p>####<strong>存在的问题：</strong></p>
<ul>
<li>没有利用人移动和活动的转移关系，只利用了时间特征</li>
<li>对于没有历史记录的位置，无法估计p(l|z)，p(l|r)按高斯分布估计</li>
</ul>
<h2 id="When-and-Where-Predicting-Human-Movements-Based-on-Social-Spatial-Temporal-Events"><a href="#When-and-Where-Predicting-Human-Movements-Based-on-Social-Spatial-Temporal-Events" class="headerlink" title="When and Where: Predicting Human Movements Based on Social Spatial-Temporal Events"></a>When and Where: Predicting Human Movements Based on Social Spatial-Temporal Events</h2><p><em>N Yang, X Kong, F Wang, SY Philip - SDM, 2014</em></p>
<h4 id="模型与方法：-10"><a href="#模型与方法：-10" class="headerlink" title="模型与方法："></a><strong>模型与方法：</strong></h4><ul>
<li>用SSTE来建模用户的社交关系，用户SSTE是用户社交关系网络的子图，带有时间-位置属性，表示该社交互动发生的时间和位置。SSTE的规律性可以用来表示用户移动规律背后的社交行为规律。</li>
<li>用ARMA模型刻画SSTE的变化，用卡尔曼过滤来动态更新ARMA参数</li>
<li>利用ARMA模型预测两次SSTE间的时间间隔，进而得到下一次SSTE发生的时间</li>
<li>在预测出的时间，预测用户所处的位置。首先用用户历史记录中，该时间段所处位置的频率分布得出P(L<sub>u</sub>=λ|T<sub>u</sub>=τ)，然后考虑用户的社交关系影响，用户的朋友曾经在这个时间出现过的位置的频率分布，然后线性相加得出最终的概率公式。</li>
</ul>
<h4 id="存在的问题：-1"><a href="#存在的问题：-1" class="headerlink" title="存在的问题："></a><strong>存在的问题：</strong></h4><ul>
<li>没有利用人移动和活动的转移关系，也没有利用地理位置和活动信息</li>
<li>引入社交关系将预测方法只局限于check-in</li>
<li>对于没有历史记录的位置，无法预测</li>
</ul>
<p>##Regularity and Conformity: Location Prediction Using Heterogeneous Mobility Data<br><em>KDD’15, August 10-13, 2015, Sydney, NSW, Australia.</em><br><em>YingziWang,Xing Xie, Nicholas Jing Yuan, Enhong Chen, Defu Lian, Yong Rui</em></p>
<h4 id="模型与方法：-11"><a href="#模型与方法：-11" class="headerlink" title="模型与方法："></a><strong>模型与方法：</strong></h4><ul>
<li>用户移动规律既有规律性又有相似性，两者应该被综合考虑</li>
<li>用户u<sub>i</sub>在t时刻到访场所v<sub>j</sub>的概率由规律项和相似项组成：$P_{ij} (t) = R_{ij}(t) + C_{ij}(t)$  (1)</li>
<li>规律项$R_{ij}(t)$<ul>
<li>将地理空间划分为大小相同的格子，每个格子用其中心点的坐标表示，假设v<sub>j</sub>属于格子$d_{k_j}$，假设用户在地理网格间的转移具有马尔科夫性，则用户u<sub>i</sub>从d<sub>k</sub>到v<sub>j</sub>的概率$Pr(v_j|d_k) = Pr(d_{k_j}|d_k)Pr(v_j|d_{k_j})$(2) ，整合从所有格子到v<sub>j</sub>的概率即可得到用户u<sub>i</sub>到访场所v<sub>j</sub>的概率$Pr(v_j|u_i)$</li>
<li>(2)式右端第一项可以用其它的移动数据集使用重力模型来估计，设地理网格$d_i$的出度为$O_i$，$d_j$的入度为$I_j$，$d_i$和$d_j$的距离为$dis_{i,j}$，则$d_i$和$d_j$间的流动性与$O_i$$I_j$成正比，与e的$dis_{i,j}$次方成反比。采用多变量回回归的方法来估计重力模型中的参数。</li>
<li>(2)式右端第二项可以通过统计在$d_{k_j}$中$v_j$的频率来计算。$Pr(d_k|u_i)$可以通过统计用户在格子$d_k$出现的频率来估计</li>
<li>由于用户访问位置的记录有多中心化的特点，将网格集合C聚类为G，用户签到主要集中在一些大热区和小热区，不论是大小热区在地理空间上的分布都很稀疏，采用了一个稀疏组的Lasso-based模型来约束规律项</li>
</ul>
</li>
<li>相似项$C_{ij}(t)$:<ul>
<li>将协同过滤的方式，预测用户对新奇位置的寻找情况。采用矩阵分解的方式，将用户的位置偏好分解成两个低维潜在因素的矩阵U和V，分别表示用户和POI，并且为用户矩阵添加了潜在的时间影响因子U(t)</li>
</ul>
</li>
<li>模型添加了正则项来提高泛化性能，用交替最小化的方法来学习未知的参数</li>
</ul>
<p>####<strong>存在的问题：</strong></p>
<ul>
<li>没有利用活动信息，对位置间的转移采用的是一阶马尔科夫模型</li>
<li>对没有历史记录的位置，$Pr(v_j|d_{k_j})$为0，无法给出预测</li>
</ul>
<h2 id="CEPR-A-Collaborative-Exploration-and-Periodically-Returning-Model-for-Location-Prediction"><a href="#CEPR-A-Collaborative-Exploration-and-Periodically-Returning-Model-for-Location-Prediction" class="headerlink" title="CEPR: A Collaborative Exploration and Periodically Returning Model for Location Prediction"></a>CEPR: A Collaborative Exploration and Periodically Returning Model for Location Prediction</h2><p><em>ACM Transactions on Intelligent Systems and Technology 2015</em><br><em>Lian Defu, Xie Xing, Zheng Vincent W., Yuan Nicholas Jing, Zhang Fuzheng, Chen Enhong</em></p>
<h4 id="模型与方法"><a href="#模型与方法" class="headerlink" title="模型与方法:"></a><strong>模型与方法:</strong></h4><ul>
<li>通过对数据集的分析得出：(1)位置转移上的序列性并不显著，在访问过的地点序列中找下一个位置，有30-50个可能的位置，而在基站的定位数据中，只有2个左右(2)在常规位置的签到有很强的天周期性，但是比基站定位的轨迹数据还是弱很多，(3)新颖率在0.25-0.4左右。</li>
<li>通过对位置推荐和位置预测模型的评估，得出优质的位置推荐算法很难刻画移动模式中的规律性行为，而专门刻画规律性的推荐算法则会在推荐的性能上有所衰退。</li>
<li>探索预测$Pr(Explore)$：给定用户u的位置历史C，关于她的探索预测问题是预测下一个签到位置是否是新颖的。用来进行探索预测的特征分为用户历史特征、位置空间特征和时间特征：<ul>
<li>用户历史特征：不同地点的个数（对94%用户而言，随着地点个数增多，探索概率下降趋势减弱）、用户的地点访问频率分布熵（具有更高熵的用户更倾向于在新颖位置签到）、新颖率（当前以探索的位置）、签到天数（用户签到时间越长、探索概率越低）、上一个状态的新颖性（当前处于探索状态更有可能继续探索）</li>
<li>位置空间特征：距离其它签到位置的平均距离、位置熵（即在该位置附近签到的频率的熵）、访问率（该位置周围被访问过的位置数量）</li>
<li>时间特征：Hour of day，Day of week，Hour of week，距离上一次签到的时间间隔</li>
</ul>
</li>
<li>探索预测模型的训练：采用逻辑回归和分类回归树两个监督模型，分别得出连续概率值和二分类结果</li>
<li>常规位置预测$P_r(l)$：用一阶隐式马尔科夫模型来预测序列性，把位置当作隐状态，把时间信息当作观测值，可以将马尔科夫模型和时间规律性模型在一个模型中同时出现。<ul>
<li>发射概率估计$P(h|l)$和$P(d|l)$：这里的d、h和l分别是一周中的第d天，一天中的的第h小时以及位置l。这两个概率可以用极大似然估计。由于训练数据稀疏，我们用高斯核函数进行平滑，并且要考虑到小时和天数是循环相接的</li>
<li>隐状态的初始概率估计：用户在地点l签到频率的极大似然估计</li>
<li>隐状态的转移概率估计：同样由于训练数据稀疏，使用Kneser-Ney平滑技术来估计，该方法可以和马尔科夫模型的全贝叶斯相对应。</li>
</ul>
</li>
<li>新颖位置的预测$P_n(l)$：基于用户相似性来建立协同过滤模型，并结合地理特征进行预测<ul>
<li>用户相似性：访问位置的相似性和社交网络的相似性</li>
<li>地理特征：对每个人的空间位置分布进行二维核密度估计</li>
</ul>
</li>
<li>综合模型：协同探索周期回归模型的概率输出$P(l) = Pr(Explore)P_n(l)+(1-Pr(Explore))P_r(l)$.</li>
<li>实验评测：(1)离散的分类模型更适合做探索预测 (2)常规位置预测问题上，文中使用的发射概率单独的预测结果比单独状态转移概率的各类马尔科夫模型都要好，两者综合起来的隐式马尔科夫模型效果比发射概率稍有提升 (3)所有位置的预测上，利用$Pr(Explore)$的两种模型都比线性组合获得的结果更好，其中离散模型效果最好，相比只有$P_r(l)$的方法提升准确率达30%</li>
</ul>
<h4 id="存在的问题：-2"><a href="#存在的问题：-2" class="headerlink" title="存在的问题："></a><strong>存在的问题：</strong></h4><ul>
<li>常规位置和新颖位置的预测均未考虑活动信息，考虑了地理位置上的序列规律和周期规律、地理空间的特征以及用户相似性特征</li>
<li>对于完全没有历史记录的位置，用户相似性特征也无法利用</li>
</ul>
<h2 id="Lifting-the-Predictability-of-Human-Mobility-on-Activity-Trajectories-1"><a href="#Lifting-the-Predictability-of-Human-Mobility-on-Activity-Trajectories-1" class="headerlink" title="Lifting the Predictability of Human Mobility on Activity Trajectories"></a>Lifting the Predictability of Human Mobility on Activity Trajectories</h2><p><em>2015 IEEE 15th International Conference on Data Mining Workshops</em><br><em>Xianming Li, Defu Lian, Xing Xie and Guangzhong Sun</em></p>
<h4 id="模型与方法：-12"><a href="#模型与方法：-12" class="headerlink" title="模型与方法："></a><strong>模型与方法：</strong></h4><ul>
<li>假设用户下一个访问的位置只取决于之前访问的位置序列$Г$以及下一次访问时间和准备要进行的活动:$$P(l_{n+1},t_{n+1},a_{n+1}|Г<em>u) = P(l</em>{n+1}|l_{1:n},t_{n+1},a_{n+1})*P(t_{n+1},a_{n+1}|Г_u)$$（1）</li>
<li>不同时间的不同活动之间是有内在联系的，并且这种潜在的联系在不同用户之间是共享的，同时用户有各自的属性，相似属性的用户很可能有相似的移动规律。选用主题模型来对活动的规律进行建模。<ul>
<li>将时间-活动元组当作单词，将活动轨迹当作文档，用户的属性为文档的元数据。</li>
<li>使用随机EM算法和吉布森采样来估计主体模型相关参数，包括每个用户的活动主题分布$p(k|u)$，每个主题上的单词分布$φ_{k,w}$，前后状态的依赖$p(z_i|z_{i-1})$</li>
<li>使用隐马尔科夫模型来建立活动间的转移模型，即可得出(1)式右端第二项$P(t_{n+1},a_{n+1}|Г<em>u)$，活动主题作为隐变量，用户的活动作为观测值，初始状态是$p(k|u)$，发射概率是$φ</em>{k,w}$，状态转移概率是$p(z_i|z_{i-1})$</li>
</ul>
</li>
<li>(1)式右端第一项不容易直接估计，可以将其转换成3个条件概率的混合$$P(l_{n+1}|l_{1:n},t_{n+1},a_{n+1}) = λ<em>lP(l</em>{n+1}|l_{1:n}) + λ<em>tP(l</em>{n+1}|t_{n+1}) + λ<em>aP(l</em>{n+1}|a_{n+1})$$<ul>
<li>$P(l_{n+1}|l_{1:n})$可以使用马尔科夫模型来估计</li>
<li>另外两项可以使用EM算法做极大似然估计</li>
</ul>
</li>
</ul>
<h4 id="存在的问题：-3"><a href="#存在的问题：-3" class="headerlink" title="存在的问题："></a><strong>存在的问题：</strong></h4><ul>
<li>没有利用地理空间的特征，将时间-活动两个维度绑定在了一起用HMM模型刻画，对于周期性有损失</li>
<li>对于没有历史记录的位置，无法预测</li>
</ul>
<h2 id="WhereNext-a-Location-Predictor-on-Trajectory-Pattern-Mining"><a href="#WhereNext-a-Location-Predictor-on-Trajectory-Pattern-Mining" class="headerlink" title="WhereNext: a Location Predictor on Trajectory Pattern Mining"></a>WhereNext: a Location Predictor on Trajectory Pattern Mining</h2><p><em>KDD’09, June 28–July 1, 2009, Paris, France.</em><br><em>Anna Monreale, Fabio Pinelli, Roberto Trasarti</em></p>
<p>####<strong>模型与方法：</strong></p>
<ul>
<li>Trajectory Pattern算法将地理空间划分为统一大小的网格区域，计算经过各区域的轨迹密度，将密度大于阈值σ的区域作为轨迹的模式中的位置，将两个区域间的转移时间作为T-pattern序列中的时间属性。即一个T-pattern是由一对$(S,A)$定义，$S=&lt;R_0,R_1,…,R_n&gt;$是区域的序列，A是区域间转移时间$A=&lt;t_1,t_2,…,t_n&gt;$</li>
<li>通过需要的时空查询选出一组在特定时间限制下经过特定地点的轨迹，为这组轨迹建立相应T-pattern，然后用当前轨迹去匹配构造出来的T-pattern</li>
<li>匹配时T-pattern时需要指定规则来解决冲突，建立一个前缀树T-pattern Tree来实现：$PT = (N,E,Root(PT))$，E是带时间标签的边，时间标签为父节点到子节点的时间间隔范围$[time_min,time_max]$，节点属性为$&lt;id,region,support,children&gt;$</li>
<li>预测策略就是在PT中查找跟当前轨迹最匹配的T-pattern，通过计算所有可能路径上每个可达节点的得分，选出一个最佳的位置。精确得分(Punctual Score)衡量一个已经到达r-1区域的轨迹T到达r区域的可能性，<ul>
<li>定义$WhereNext_{r-1}$来表示经过与r-1到r相应的时间标签[time_min,time_max]后，可能到达的位置[begin,end]，$WhereNext_{r-1}$和r的关系可能有3种:</li>
<li>(1)正好和r相交，则此时的精确得分就是r节点的support值</li>
<li>(2)尚未到达r，需要放大时间间隔$d_t$才能和r相交，这时的精确得分是r节点的$r.support/d_t$</li>
<li>(3)时间间隔放大$d_t$后仍然不能和r相交，还需要放大$WhereNext_{r-1}$的地理覆盖范围$s_t$，此时得分为$r.support/(d_t+s_t)$</li>
</ul>
</li>
<li>T-pattern集合的有效性关系到预测的性能，用空间覆盖率、数据集覆盖率和空间区分度三个指标来评价T-pattern集合的选择</li>
</ul>
<h4 id="存在的问题：-4"><a href="#存在的问题：-4" class="headerlink" title="存在的问题："></a><strong>存在的问题：</strong></h4><ul>
<li>没有活动信息的引入，对当前轨迹完整程度要求高，没有利用马尔科夫性</li>
</ul>
<h2 id="Mining-User-Mobility-Feature-for-next-place-prediction-in-location-based-services"><a href="#Mining-User-Mobility-Feature-for-next-place-prediction-in-location-based-services" class="headerlink" title="Mining User Mobility Feature for next place prediction in location-based services"></a>Mining User Mobility Feature for next place prediction in location-based services</h2><p><em>In ICDM, pages 1038–1043. Citeseer, 2012</em><br><em>A. Noulas, S. Scellato, N. Lathia, and C. Mascolo.</em></p>
<p>####<strong>模型与方法</strong></p>
<ul>
<li>评估了影响个体移动的特征，选择其中最优影响力的几个用正则化的线性模型和M5决策树来预测下一个位置</li>
<li>个人移动特征<ul>
<li>历史访问次数： $\hat{r_k}(u)=|{(l,t)∈C_u:t&lt;t’∧l=k}|$</li>
<li>位置类型的偏好： $\hat{r_k}(u)=|{(l,t)∈C_u:t&lt;t’∧z_l=z_k}|$</li>
<li>社交影响： $Γ_u$是用户$u$的朋友集合， $$\hat{r_k}(u)=\sum_{v\inΓ_u}|{(l,t)∈C_v:t&lt;t’∧l=k}|$$</li>
</ul>
</li>
<li>群体移动特征<ul>
<li>位置流行度：$$\hat{r_k}(U)=\sum_{u\in U}|{(l,t)∈C_u:t&lt;t’∧l=k}|$$</li>
<li>地理距离：$\hat{r_k}(l’)=dist(l’,k)$</li>
<li>距离排名：$\hat{r_k}(l’)=|{w \in L:dist(l’,w)&lt;dist(l’,k)}|$</li>
<li>活动转移：连续两个访问记录的类型为$(m,n)$，$\hat{r_k}(l’)=|{(m,n)∈L_c:z_m=z_{l’}∧z_n=z_k}|$</li>
<li>位置转移：$\hat{r_k}(l’)=|{(m,n)\in L_c:m={l’}∧n=k}|$</li>
</ul>
</li>
<li>时间特征：位置类型和具体位置在一天的每个小时和一周的每个小时中的出现次数</li>
<li>对特征评估结论：<ul>
<li>APR：位置类型偏好可以达到0.84，地理流行度可以达到0.86，具体位置的每小时的时间特征可以达到0.79，每天的时间影响为0.76，地理距离和距离排名为0.78，历史到访次数、社交影响和转移规律影响较低，分别为0.68，0.61和0.60. 相比之下，随机访问可以达到0.5的APR。</li>
<li>Acc@K：在K值比较小（小于50）时，历史访问次数正确率最高，紧接着是社交影响和位置转移。超过50以后，历史访问次数仍然保持最高，同时时间特征、地理距离和流行度开始追平并超过社交影响和位置转移，单纯使用位置的偏好、时间特征和转移特征效果最差。</li>
</ul>
</li>
<li>预测模型：M5树准确率高于正规化线性模型<br>####<strong>存在的问题</strong></li>
<li>没有考虑地理区域特征，每一种特征都刻画的太简单</li>
</ul>
<h2 id="Modelling-Heterogeneous-Location-Habits-in-Human-Populations-for-Location-Prediction-Under-Data-Sparsity"><a href="#Modelling-Heterogeneous-Location-Habits-in-Human-Populations-for-Location-Prediction-Under-Data-Sparsity" class="headerlink" title="Modelling Heterogeneous Location Habits in Human Populations for Location Prediction Under Data Sparsity"></a>Modelling Heterogeneous Location Habits in Human Populations for Location Prediction Under Data Sparsity</h2><p><em>UbiComp’13, September 8–12, 2013, Zurich, Switzerland</em><br><em>James McInerney1, Jiangchuan Zheng2, Alex Rogers1, Nicholas R. Jennings1</em></p>
<h4 id="模型与方法-1"><a href="#模型与方法-1" class="headerlink" title="模型与方法"></a><strong>模型与方法</strong></h4><p>- </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/人流量/地理位置分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/人流量/地理位置分析/" itemprop="url">地理位置分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/人流量/" itemprop="url" rel="index">
                    <span itemprop="name">人流量</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Discovering-Urban-Functional-Zones-Using-Latent-Activity-Trajectories"><a href="#Discovering-Urban-Functional-Zones-Using-Latent-Activity-Trajectories" class="headerlink" title="Discovering Urban Functional Zones Using Latent Activity Trajectories"></a>Discovering Urban Functional Zones Using Latent Activity Trajectories</h3><p><em>Ieee Transactions on Knowledge and Data Engineering, 2015</em></p>
<p><em>Yuan N. J. , Zheng Y. , Xie X.</em></p>
<h4 id="研究问题："><a href="#研究问题：" class="headerlink" title="研究问题："></a>研究问题：</h4><p>​    发现城市的功能区域，并对得出的区域进行解释</p>
<h4 id="模型与方法："><a href="#模型与方法：" class="headerlink" title="模型与方法："></a>模型与方法：</h4><ul>
<li>根据城市道路网络，讲城市划分成区域</li>
<li>从轨迹数据中提取出转移模式立方体，包括两类，离开立方体（三个维度分别是，离开的区域，到达的区域，离开时间）和到达立方体（离开的区域，到达的区域，到达时间）</li>
<li>通过POI类型的TF-IDF来衡量每个区域内各种类型的活动的重要程度，形成R-C矩阵。然后对R-C矩阵进行奇异值分解来解决缺失值和潜在语义规律，分解为POI特征向量和区域特征向量</li>
<li>把区域看作文档，转移立方当作词汇表，转移模式是词汇，区域内的活动是文档的主体，POI特征向量是文档元数据，用LDA来刻画区域内的活动</li>
<li>除了转移模式反应的区域-活动关系，同时考虑了位置的语义，对POI特征向量用DMR建模，然后和LDA结合在一起</li>
<li>利用K-means，根据之前得到的区域的活动主题分布，对由道路网络划分的区域聚类，得到城市的功能区域。用核密度估计的方式对每个功能区域的热度，即人流量，最后根据区域的POI分布，给功能区域进行了解释</li>
</ul>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>[9]</p>
<h3 id="Land-Use-Classification-Using-Taxi-GPS-Traces"><a href="#Land-Use-Classification-Using-Taxi-GPS-Traces" class="headerlink" title="Land-Use Classification Using Taxi GPS Traces"></a>Land-Use Classification Using Taxi GPS Traces</h3><p><em>Ieee Transactions on Intelligent Transportation Systems</em></p>
<p><em>Pan G. , Qi G. D. , Wu Z. H.</em></p>
<h4 id="研究问题：-1"><a href="#研究问题：-1" class="headerlink" title="研究问题："></a>研究问题：</h4><p>​    划分城市区域，并对其进行分类（定义了14种城市区域的类型）</p>
<h4 id="模型与方法：-1"><a href="#模型与方法：-1" class="headerlink" title="模型与方法："></a>模型与方法：</h4><ul>
<li>利用出租车数据，统计出上下客的位置分布。将城市划分为10m*10m的网格，发现上客数据稀疏、上下客有聚集现象，这些聚集的区域大小和人流密度都有各不相同</li>
<li>定义了上下车点周围的密度，然后用DBSCAN对这些点进行聚类，得到了城市的区域划分</li>
<li>对每个区域，定义了6个特征，包括一天内每个时段上下客数量、上下客人数差别、上下客人数比值、一周每天上下客数量。然后根据这6个特征，对之前得到的区域进行了分类</li>
</ul>
<h4 id="College-Towns-Vacation-Spots-and-Tech-Hubs-Using-Geo-Social-Media-to-Model-and-Compare-Locations"><a href="#College-Towns-Vacation-Spots-and-Tech-Hubs-Using-Geo-Social-Media-to-Model-and-Compare-Locations" class="headerlink" title="College Towns, Vacation Spots, and Tech Hubs: Using Geo-Social Media to Model and Compare Locations"></a>College Towns, Vacation Spots, and Tech Hubs: Using Geo-Social Media to Model and Compare Locations</h4><p><em>Proceedings of the Thirtieth AAAI Conference on Artificial Intelligence (AAAI-16)</em></p>
<p><em>Hancheng Ge, James Caverlee</em></p>
<h4 id="研究问题：-2"><a href="#研究问题：-2" class="headerlink" title="研究问题："></a>研究问题：</h4><p>​    对不同的城市进行聚类，找出各城市发展的重心</p>
<h4 id="模型与方法：-2"><a href="#模型与方法：-2" class="headerlink" title="模型与方法："></a>模型与方法：</h4><ul>
<li>给城市定义了一个n-维兴趣向量，文中包含14个维度</li>
<li>首先将推特分为与活动主题有关的和无关的，利用12个二进制特征，还有关键词特征，采用随机森林进行2分类</li>
<li>再用多分类器和活动主题有关的推特划分到14个活动种类中</li>
<li>再根据城市的活动种类向量对城市进行聚类</li>
</ul>
<h4 id="Modeling-User-Mobility-for-Location-Promotion-in-Location-based-Social-Networks"><a href="#Modeling-User-Mobility-for-Location-Promotion-in-Location-based-Social-Networks" class="headerlink" title="Modeling User Mobility for Location Promotion in Location-based Social Networks"></a>Modeling User Mobility for Location Promotion in Location-based Social Networks</h4><p><em>kdd ’15 , Zhu Wen-Yuan, Peng Wen-Chih, Chen Ling-Jyh, Zheng Kai, Zhou Xiaofang</em></p>
<h4 id="研究问题：-3"><a href="#研究问题：-3" class="headerlink" title="研究问题："></a>研究问题：</h4><p>​    对给定位置，找出最有影响力的k个用户</p>
<h4 id="模型与方法：-3"><a href="#模型与方法：-3" class="headerlink" title="模型与方法："></a>模型与方法：</h4><ul>
<li>建立用户-POI的对应图，用户-用户之间有社交关系</li>
<li>在用户-用户图上求社交影响力</li>
<li>估计每个用户到访每个位置的概率，采用基于距离的模型</li>
<li>奖基于距离的用户移动模型和社交关系模型联合建模，以此推导出每个用户对该位置的提升概率</li>
</ul>
<h4 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h4><p>5，6，17，chapter 2.3</p>
<h4 id="Collective-Traffic-Prediction-with-Partially-Observed-Traffic-History-using-Location-Based-Social-Media"><a href="#Collective-Traffic-Prediction-with-Partially-Observed-Traffic-History-using-Location-Based-Social-Media" class="headerlink" title="Collective Traffic Prediction with Partially Observed Traffic History using Location-Based Social Media"></a>Collective Traffic Prediction with Partially Observed Traffic History using Location-Based Social Media</h4><p><em>CIKM’16 , Liu Xinyue, Kong Xiangnan , Li Yanhua</em> </p>
<h4 id="研究问题：-4"><a href="#研究问题：-4" class="headerlink" title="研究问题："></a>研究问题：</h4><p>​    利用LBSN的数据来预测交通状况</p>
<h4 id="模型与方法：-4"><a href="#模型与方法：-4" class="headerlink" title="模型与方法："></a>模型与方法：</h4><ul>
<li>结合LBSN数据和部分观测的历史轨迹数据</li>
<li>将地图划分成网格，从LBSN中统计一定时间窗口内出地理区域的特征向量</li>
<li>对于有交通状况记录数据的区域，结合之前一段时间的交通状况和LBSN特征向量来预测交通状况，对于没有交通状况记录的区域，只试用LBSN特征向量来预测。该特征向量的每一位的值表示在该时间段内，在该区域内发布的堵塞、停车等关键词出现的数量</li>
<li>对某一区域内车流速度，文中指出3种关系：和同一区域内之前时段的车流速度有关系、相邻区域之前时段的车流速度、同一时段附近区域的车流速度。将这三种关系线性结合，得到对该区域当前时段的车流速度的估计</li>
<li>采用迭代分类算法</li>
</ul>
<h3 id="Mining-Significant-Semantic-Locations-From-GPS-Data"><a href="#Mining-Significant-Semantic-Locations-From-GPS-Data" class="headerlink" title="Mining Significant Semantic Locations From GPS Data"></a>Mining Significant Semantic Locations From GPS Data</h3><p><em>VLDB‘10 , Xin Cao, Gao Cong, Christian S. Jensen</em></p>
<h4 id="研究问题：-5"><a href="#研究问题：-5" class="headerlink" title="研究问题："></a>研究问题：</h4><p>​    从GPS数据中挖掘有意义的位置，并为这些位置做重要性排名</p>
<h4 id="模型与方法：-5"><a href="#模型与方法：-5" class="headerlink" title="模型与方法："></a>模型与方法：</h4><ul>
<li>同时建模了位置之间的连通关系和用户-位置的到访关系</li>
</ul>
<h4 id="Improving-Personalized-Trip-Recommendation-by-Avoiding-Crowds"><a href="#Improving-Personalized-Trip-Recommendation-by-Avoiding-Crowds" class="headerlink" title="Improving Personalized Trip Recommendation by Avoiding Crowds"></a>Improving Personalized Trip Recommendation by Avoiding Crowds</h4><p><em>CIKM’16 , Wang Xiaoting , Leckie Christophe</em></p>
<h4 id="研究问题：-6"><a href="#研究问题：-6" class="headerlink" title="研究问题："></a>研究问题：</h4><p>​    结合POI的当前流量，设计一个避开高峰的行程推荐</p>
<h4 id="模型与方法：-6"><a href="#模型与方法：-6" class="headerlink" title="模型与方法："></a>模型与方法：</h4><ul>
<li>POI流量直接用行人数量统计数据</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/人流量/兴趣点推荐总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/人流量/兴趣点推荐总结/" itemprop="url">兴趣点推荐总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/人流量/" itemprop="url" rel="index">
                    <span itemprop="name">人流量</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="GeoMF-Joint-Geographical-Modeling-and-Matrix-Factorization-for-Point-of-Interest-Recommendation"><a href="#GeoMF-Joint-Geographical-Modeling-and-Matrix-Factorization-for-Point-of-Interest-Recommendation" class="headerlink" title="GeoMF: Joint Geographical Modeling and Matrix Factorization for Point-of-Interest Recommendation"></a>GeoMF: Joint Geographical Modeling and Matrix Factorization for Point-of-Interest Recommendation</h2><p><em>KDD’14, August 24–27, 2014, New York, NY, USA</em><br><em>Lian Defu, Zhao Cong, Xie Xing, Sun Guangzhong, Chen Enhong,<br>Rui Yong</em></p>
<h4 id="模型与方法："><a href="#模型与方法：" class="headerlink" title="模型与方法："></a><strong>模型与方法：</strong></h4><ul>
<li>利用协同推荐来进行兴趣点推荐，类比于电影推荐中的用户评分，兴趣点推荐中的用户喜好是隐式的，所以对用户喜好采用0-1矩阵$R_{M,N}$来代表用户是否到访过各个兴趣点，用加权矩阵W来刻画访问频率。</li>
<li>考虑到用户访问兴趣点稀疏情况非常严重，用户和兴趣点映射到一个$K &lt;&lt; min(M,N)$维的联合隐式空间中的两个向量P和Q，使得用户对兴趣点的偏好可以建模成两个向量的点积。通过最小化频率矩阵R和PQ点积的Frobenius范数来得到最佳映射，即$min_{P,Q}||W⊙(R-PQ)^T||^2_F$。为了降低泛化误差，通常会给目标函数添加正则项。</li>
<li>在兴趣点推荐中，还可以利用地理空间的信息，通过空间聚集效应的建模来构造用户活动区域向量和兴趣点影响力向量，先将地理空间划分为L个均匀的网格，$L = {g_1,g_2,…,g_L}$<ul>
<li>用户活动区域向量x：非负向量x中的没有元素$x_l$表示了这个用户在$g_l$中出现的可能性</li>
<li>兴趣点影响力向量y：假设兴趣点的影响力是事先固定的而且是以兴趣点为中心正态分布的，用非负向量y</li>
</ul>
</li>
<li>GeoMF模型的估计偏好矩阵：将所有用户的活动区域向量x和所有兴趣点的影响力向量y分别按行堆积，得到用户活动区域矩阵X和兴趣点影响力矩阵Y，新的矩阵分解过程变为:$$min_{P,Q,X}||W⊙(R-PQ^T-XY^T)||^2_F+γ(||P||_F^2+||Q||_F^2)+λ||X||_1$$</li>
<li>采用交替最小化的方式，交替固定X学习隐向量P、Q和固定隐向量P、Q来对X做加权非负最小二乘来优化。</li>
</ul>
<h2 id="Point-of-Interest-Recommendations-Learning-Potential-Check-ins-from-Friends"><a href="#Point-of-Interest-Recommendations-Learning-Potential-Check-ins-from-Friends" class="headerlink" title="Point-of-Interest Recommendations: Learning Potential Check-ins from Friends"></a>Point-of-Interest Recommendations: Learning Potential Check-ins from Friends</h2><p><em>KDD ’16 San Francisco, USA</em><br><em>Huayu Li, Yong Ge and Hengshu Zhu</em></p>
<h4 id="模型与方法"><a href="#模型与方法" class="headerlink" title="模型与方法"></a><strong>模型与方法</strong></h4><ul>
<li>利用用户间的相似性来为用户推荐未访问过的兴趣点，用户之间的相似性可以从三种“朋友”关系来刻画，包括社交朋友（在LBSN上有社交连接的人），兴趣朋友（签到过的位置相似的人）和邻居朋友（家的位置相似的人）</li>
<li>用户跟位置的关系可以分为三种，已访问过的位置，潜在位置和没有访问的位置。潜在位置：$M_i^f$是用户$i$没有访问过，但是他的朋友$f$访问过的位置集合。兴趣点推荐问题就是找出top S个最可能感兴趣的潜在位置。</li>
<li>用户$i$到访兴趣点$j$的可能性用$p^{pot}<em>{ij}$表示。对$p^{pot}</em>{ij}$的估计用线性整合和随机游走模型来估计<ul>
<li>用$Sim(i,f;j)$来表示用户$i$和他的朋友$f$在位置$j$的喜好相似程度，即$p^{pot}_{ij} ∝ max{Sim(i,f;j)}$. 而$Sim(i,f;j)$受两个方面因素的作用，一个是两人兴趣的相似性，另一个是用户的家离该位置的远近（可以用幂律分布去估计位置远近的影响）。然后将二者线性结合，即 $Sim(i,f;j) = ζSim_u(i,f)+(1-ζ)p^G_{ij}$ </li>
<li>构造一个有向图，包含两类节点，一类是用户节点，另一类是有签到的位置节点。<strong>y</strong>表示随机游走到达节点$i$的概率向量，<strong>A</strong>表示归一化后的从节点$i$到节点$j$转移概率矩阵。概率转移有三种类型(1)用户节点直接用用户相似性(2)用户和位置之间有访问记录则为1，否则为0(3)位置直接用基于距离的幂律分布。然后用（公式略）迭代求出<strong>y</strong></li>
</ul>
</li>
<li>用矩阵分解的方式来计算的推荐结果，潜在的用户特征矩阵和位置特征矩阵分别是$U_{K×N}$和$V_{K×M}$，同时结合了用户对位置类型的偏好矩阵$Q_{N×C}$，用户$i$对位置$j$的偏好可以表示为$p_{ij} = (q_{ic_{j}}+ε)u_i^Tv_j$</li>
<li>对U，K，Q三个矩阵进行学习的损失函数设计时，可以将已访问的位置当作正样本，潜在访问的位置作为低影响力的正样本，未访问的位置当作负样本或负样本和缺失值的合集。并提出了基于平方误差的模型和基于排序误差的模型来学习。在最终进行推荐前，再将矩阵分解计算的结果前乘一个地理距离影响因子$p_{ij}^G$.</li>
<li>在对常规情况进行预测时，就使用前面提到的方法；对用户冷启动的问题进行预测时，朋友关系中没有兴趣朋友，只根据社交朋友和邻居朋友进行推荐；对位置冷启动的问题，选S个跟其最近的位置的加权均值来当作对它的预测。</li>
</ul>
<h2 id="Addressing-the-cold-start-problem-in-location-recommendation-using-geo-social-correlations"><a href="#Addressing-the-cold-start-problem-in-location-recommendation-using-geo-social-correlations" class="headerlink" title="Addressing the cold-start problem in location recommendation using geo-social correlations"></a>Addressing the cold-start problem in location recommendation using geo-social correlations</h2><p><em>CIKM 2012， DMKD 2014</em><br><em>Huiji Gao · Jiliang Tang · Huan Liu</em></p>
<p>####<strong>模型与方法</strong></p>
<ul>
<li>利用人们移动上的相似性来解决位置推荐中的冷启动问题，将人和人的关系分为4种，生活在附近的朋友，生活在附近的陌生人，距离很远的朋友，距离很远的陌生人。人的移动会由这四种关系的人共同影响。所以用户在t时刻到达位置l的概率表示为:$$P_u^t(l) = \Phi_1P_u^t(l|S_{\overline{F}\overline{D}}+\Phi_2P_u^t(l|S_{F\overline{D}})\+\Phi_1P_u^t(l|S_{FD})+\Phi_1P_u^t(l|S_{\overline{F}D})$$</li>
<li>$\Phi_1$用用户$u$以及和他具有四种关系的用户的历史签到数，冷启动位置签到数，签到过的位置数，各类关系的用户数等特征线性组合，再用S型函数归一化为[0,1]之间是值，$\Phi_i$等参数可以用$1-\Phi_{i-1}$再乘以一个系数的方式去估计。$P_u^t(l|S_*)$可以用TF-IDF的方式去估计。</li>
<li>具体涉及到的参数使用最大似然估计，并添加正则项</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/人流量/POI 相关论文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/人流量/POI 相关论文/" itemprop="url">POI 相关论文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/人流量/" itemprop="url" rel="index">
                    <span itemprop="name">人流量</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="POI-相关论文"><a href="#POI-相关论文" class="headerlink" title="POI 相关论文"></a>POI 相关论文</h2><p>###1. POI 流量相关</p>
<h4 id="POI-Recommendation-A-Temporal-Matching-between-POI-Popularity-and-User-Regularity"><a href="#POI-Recommendation-A-Temporal-Matching-between-POI-Popularity-and-User-Regularity" class="headerlink" title="POI Recommendation: A Temporal Matching between POI Popularity and User Regularity"></a>POI Recommendation: A Temporal Matching between POI Popularity and User Regularity</h4><p><em>Zijun Yao, Yanjie Fu, Bin Liu, Yanchi Liu, Hui Xiong, ICDM 2016</em></p>
<ul>
<li>Problem：给定用户签到历史，为用户推荐POI</li>
<li>Motivation：<ul>
<li>POI 流行度随时间变化</li>
<li>用户活动兴趣随时间变化</li>
<li>如何在推荐时将二者相匹配</li>
</ul>
</li>
<li>Method：<ul>
<li><strong>POI 热度</strong>：用 taxi 数据定义区域热度，用 check-in 数据定义类别热度，混合得到 POI 热度<ul>
<li>统计 POI 附近100m内下客数 在时间片 $t$ 的分布占比作为区域热度 $D_{j,t}$</li>
<li>统计 POI 类别所有访问数，时间片 $t$ 的分布作为类别热度 $C_{v,t}$</li>
<li>POI 的时间统计热度为 $q_{j,t} = \varphi D_{j,t}i + \varphi C_{c{j},t}$，$\varphi$ 是超参，作者定义 0.6</li>
<li>用 GMM 来平滑 POI 热度</li>
</ul>
</li>
<li>计算用户活跃度的时间分布，跟 POI 分布进行匹配。</li>
</ul>
</li>
<li>Experiment：</li>
</ul>
<h4 id="Experiments-with-a-Venue-Centric-Model-for-Personalised-and-Time-Aware-Venue-Suggestion"><a href="#Experiments-with-a-Venue-Centric-Model-for-Personalised-and-Time-Aware-Venue-Suggestion" class="headerlink" title="Experiments with a Venue-Centric Model for Personalised and Time-Aware Venue Suggestion"></a>Experiments with a Venue-Centric Model for Personalised and Time-Aware Venue Suggestion</h4><p><em>Romain Deveaud, M-Dyaa Albakour, Craig Macdonald and Iadh Ounis, CIKM 2015</em></p>
<ul>
<li>Problem: POI 推荐</li>
<li>Motivation：基于用户的POI推荐需要大量个体用户的信息和数据，因此提出基于POI的POI推荐。</li>
<li>Method：<ul>
<li>$P(v|u,l,t)=P(v|u)\cdot P(v|l,t)$</li>
<li>$P(v|l,t) = P(v|l)\cdot P(v|t)$</li>
<li>其中 $P(v|t)$ 是POI流行度，采用时序预测的方法</li>
</ul>
</li>
<li>Experiment：<ul>
<li>时序预测POI流行度方面，ARIMA，基于过去 21 天取得最好效果。</li>
</ul>
</li>
</ul>
<h4 id="CORALS-Who-are-My-Potential-New-Customers-Tapping-into-the-Wisdom-of-Customers’-Decisions"><a href="#CORALS-Who-are-My-Potential-New-Customers-Tapping-into-the-Wisdom-of-Customers’-Decisions" class="headerlink" title="CORALS: Who are My Potential New Customers? Tapping into the Wisdom of Customers’ Decisions"></a>CORALS: Who are My Potential New Customers? Tapping into the Wisdom of Customers’ Decisions</h4><p><em>Ruirui Li, Jyunyu Jiang, Chelsea J.-T. Ju, Wei Wang. CKIM 2017</em></p>
<ul>
<li>Problem: POI 推荐</li>
<li>Motivation：用户选择POI的决策过程会考虑（1）自身兴趣（2）地理影响（3）POI 评价</li>
<li>Method：</li>
<li>Experiments：<strong>有新dataset</strong></li>
</ul>
<h4 id="Exploring-Student-Check-In-Behavior-for-Improved-Point-of-Interest-Prediction"><a href="#Exploring-Student-Check-In-Behavior-for-Improved-Point-of-Interest-Prediction" class="headerlink" title="Exploring Student Check-In Behavior for Improved Point-of-Interest Prediction"></a>Exploring Student Check-In Behavior for Improved Point-of-Interest Prediction</h4><p><em>KDD 2018</em></p>
<ul>
<li>Problem: 基于学生签到数据的位置预测</li>
<li>Motivation: <ul>
<li>基于LBSN的签到数据集中在娱乐活动上，不能反应用户活动全貌</li>
<li>学校数据特点：更多活跃用户、更多类型日常活动、意义明确的范围</li>
<li>在学校数据下，采用异构的图结构来做预测，比基于张量等方式更合适（WHY？）</li>
</ul>
</li>
<li>Method：<ul>
<li>Embedding for Dense Heterogeneous Graphs (EDHG)</li>
<li>把个人兴趣、时间规律和活动类型建立成多种异构的图</li>
<li>联合学习这些图的顶点embedding</li>
<li>用得到的embedding来进行特定时间的推荐</li>
</ul>
</li>
<li>Result</li>
</ul>
<h4 id="StepDeep-A-Novel-Spatial-temporal-Mobility-Event-Prediction-Framework-based-on-Deep-Neural-Network"><a href="#StepDeep-A-Novel-Spatial-temporal-Mobility-Event-Prediction-Framework-based-on-Deep-Neural-Network" class="headerlink" title="StepDeep A Novel Spatial-temporal Mobility Event Prediction Framework based on Deep Neural Network"></a>StepDeep A Novel Spatial-temporal Mobility Event Prediction Framework based on Deep Neural Network</h4><p><em>Bilong Shen，Xiaodan Liang，Yufeng Ouyang，Miaofeng Liu，Weimin Zheng，Kathleen M. Carley，KDD 2018</em> </p>
<ul>
<li>Problem: 预测打车数（Mobility Event）</li>
<li>Motivation<ul>
<li>Mobility Event 随时间动态变化、有空间依赖性，并且受许多其它因素影响</li>
<li>人工设计的特征和应用场景相关并且需要很强的领域知识</li>
</ul>
</li>
<li>Method<ul>
<li>用深度神经网络来建模</li>
<li>2维空间平面+时间维度，构成类似于“视频”的数据结构，因此该问题 变成是pixel-wised “视频”预测</li>
<li>其它因素添加在隐藏层中</li>
</ul>
</li>
<li>Result：</li>
</ul>
<h4 id="Predicting-new-venue-visitation-patterns-through-mobility-data"><a href="#Predicting-new-venue-visitation-patterns-through-mobility-data" class="headerlink" title="Predicting new venue visitation patterns through mobility data"></a>Predicting new venue visitation patterns through mobility data</h4><p><em>SIGSPATIAL 2017</em></p>
<ul>
<li>Problem: 预测新POI的访问量时间分布</li>
<li>Motivation：新问题，商业价值</li>
<li>Method：<ul>
<li>统计区域分布，统计POI分布，统计区域内类别分布</li>
<li>新 Venue 用K-NN：找到 N 个类别分布最相近的区域，这 N 个分布 用贝叶斯高斯平滑来拟合。</li>
</ul>
</li>
</ul>
<p>####POI Popularity Prediction via Hierarchical Fusion of multiple social clues</p>
<p><em>Yaqian Duan, Xinze W3KM<br>ang, Yang Yang, Zi Huang, Ning Xie, Heng Tao Shen. SIGIR 2016</em></p>
<ul>
<li>Problem: 预测POI总的访问量（热度）</li>
<li>Motivation：</li>
<li>Method：</li>
<li>Result：</li>
</ul>
<p>###2. 城市区域分析</p>
<h4 id="Discovering-Urban-Travel-Demands-through-Dynamic-Zone-Correlation-in-Location-Based-Social-Networks"><a href="#Discovering-Urban-Travel-Demands-through-Dynamic-Zone-Correlation-in-Location-Based-Social-Networks" class="headerlink" title="Discovering Urban Travel Demands through Dynamic Zone Correlation in Location-Based Social Networks"></a>Discovering Urban Travel Demands through Dynamic Zone Correlation in Location-Based Social Networks</h4><p><em>Wangsu Hu, Zijun Yao, Sen Yang, Shuhong Chen, and Peter J. Jin, ECML-PKDD</em> 2018</p>
<ul>
<li>Problem: 根据用户签到数据，估计区域为单位的Origin-Destination Flow，即一个 Origin Zone， Destination Zone，Timeslot组成的张量，张量元素的值表示trip数量。</li>
<li>Motivation:<ul>
<li>在车辆GPS层面做的OD flow工作，GPS数据无语义</li>
<li>在 check in 层面工作都是用户为单位的工作，没有区域层面的</li>
</ul>
</li>
<li>Method:<ul>
<li>根据 POI 类别划分，估计区域的 topic</li>
<li>用 Hawkes Process-based State-Space 来估计（区域？）签到数</li>
<li>用 Pearson Product-Moment Correlation Gravity Model 来估计任意区域对之间的人流关系</li>
</ul>
</li>
<li>Result:</li>
</ul>
<h4 id="Representing-Urban-Functions-through-Zone-Embedding-with-Human-Mobility-Patterns"><a href="#Representing-Urban-Functions-through-Zone-Embedding-with-Human-Mobility-Patterns" class="headerlink" title="Representing Urban Functions through Zone Embedding with Human Mobility Patterns"></a>Representing Urban Functions through Zone Embedding with Human Mobility Patterns</h4><p><em>Zijun Yao, Yanjie Fu, Bin Liu, Wangsu Hu, Hui Xiong. IJCAI 2018</em></p>
<ul>
<li>Problem: 基于人类移动数据，将城市区域进行embedding，功能相近的区域embedding结果相近</li>
<li>Motivation:<ul>
<li>在人类移动数据中，城市区域的co-occur可以帮助学习embedding</li>
<li>co-occur需要考虑时间因素，不同时间离开和到达某区域，代表该区域的功能不同</li>
</ul>
</li>
<li>Method：<ul>
<li>Time aware “word embedding”</li>
<li>加入了重力因子来衡量co-occur的重要性</li>
</ul>
</li>
<li>Result<ul>
<li>根据embedding进行区域聚类，跟ground truth以及若干baseline比聚类性能</li>
</ul>
</li>
</ul>
<h4 id="Exploring-the-Urban-Region-of-Interest-through-the-Analysis-of-Online-Map-Search-Queries"><a href="#Exploring-the-Urban-Region-of-Interest-through-the-Analysis-of-Online-Map-Search-Queries" class="headerlink" title="Exploring the Urban Region-of-Interest through the Analysis of Online Map Search Queries"></a>Exploring the Urban Region-of-Interest through the Analysis of Online Map Search Queries</h4><p><em>Ying Sun, Hengshu Zhu, Fuzhen Zhuang, Jingjing Gu, Qing He. KDD 2018</em></p>
<ul>
<li>Problem：ROI 提取和画像</li>
<li>Motivation：<ul>
<li>ROI 提取和画像的问题还没有解决好</li>
<li>利用地图的 query 数据来做是一个新的思路</li>
<li>地图 query 带有时间戳，起终点，并且起终点可以用POI形式表示</li>
</ul>
</li>
<li>Method：<ul>
<li>ROI 提取<ul>
<li>将城市划分格子，按格子统计转移矩阵</li>
<li>用 PageRank 统计每个格子的流行度</li>
<li>用一个基于密度的聚类，将格子聚类成 ROI</li>
</ul>
</li>
<li>ROI 画像<ul>
<li>提出一个时空隐变量模型来建模 ROI 访客的 topic</li>
<li>将 ROI 视为document，以该ROI为终点的查询（包括时间、起点、POI标签）为word</li>
</ul>
</li>
</ul>
</li>
<li>Experiment</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/人机交互技术复习/人机交互技术复习提纲（17-21）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/人机交互技术复习/人机交互技术复习提纲（17-21）/" itemprop="url">人机交互技术复习提纲（17-21）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/人机交互技术复习/" itemprop="url" rel="index">
                    <span itemprop="name">人机交互技术复习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>#1<br>    请定义一个类，存储指定文件夹下的所有文件名（含各级子文件夹），并写出该类的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Public Class clsDirectory</span><br><span class="line">    Public Files As List(Of String)</span><br><span class="line">    Public Directories As List(Of clsDirectory)</span><br><span class="line"></span><br><span class="line">    Public Sub New(PathName As String)</span><br><span class="line">        Create(PathName)</span><br><span class="line">    End Sub</span><br><span class="line">    </span><br><span class="line">        Private Sub Create(PathName As String)</span><br><span class="line">            Files = Directory.GetFiles(PathName).ToList</span><br><span class="line">            directories = New List(Of clsDirectory)</span><br><span class="line">            Dim foldes() As String = Directory.GetDirectories(PathName)</span><br><span class="line">            For i = 0 To foldes.Count - 1</span><br><span class="line">                Directories.Add(New clsDirectory(foldes(i)))</span><br><span class="line">            Next</span><br><span class="line">    End Sub</span><br><span class="line">End Class</span><br></pre></td></tr></table></figure></p>
<p>#2<br>    请编写函数，将指定的Tuple类型数据（例如:(“dad”, ”son”)）插入到TreeView控件中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">知识点：Tuple(Of String, String)：二元组类型。主要成员：Item1，Item2</span><br><span class="line">Public Tuples As List(Of Tuple(Of String, String)) //树形结构中的二元关系集合</span><br><span class="line">-----------------------------------------------------------------------------------------------------------------</span><br><span class="line">Public Sub Append(tuple As Tuple(Of String, String))</span><br><span class="line">        If AppendNode(tuple) = True Then</span><br><span class="line">            //树中添加了节点，二元关系集合才能添加二元关系</span><br><span class="line">            Tuples.Add(tuple)</span><br><span class="line">        End If</span><br><span class="line">End Sub</span><br><span class="line"></span><br><span class="line">Private Function AppendNode(tuple As Tuple(Of String, String)) As Boolean</span><br><span class="line">        Dim parentnode As TreeNode = SearchNode(Root, tuple.Item1)</span><br><span class="line">        If parentnode Is Nothing Then Return False</span><br><span class="line">        parentnode.Nodes.Add(tuple.Item2)</span><br><span class="line">        Return True</span><br><span class="line">End Function</span><br><span class="line"></span><br><span class="line">//在node所表示的属性结构中，查找关键值为key的节点</span><br><span class="line">    Private Function SearchNode(node As TreeNode, key As String) As TreeNode</span><br><span class="line">        If node.Text = key Then Return node</span><br><span class="line">        For i = 0 To node.Nodes.Count - 1</span><br><span class="line">            Dim node1 As TreeNode = SearchNode(node.Nodes(i), key)</span><br><span class="line">            If node1 IsNot Nothing Then Return node1</span><br><span class="line">        Next</span><br><span class="line">        Return Nothing</span><br><span class="line">End Function</span><br></pre></td></tr></table></figure></p>
<p>#3<br>    请编写函数，在TreeView控件中，删除text等于指定字符串的结点及其子树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Public Sub Remove(key As String)</span><br><span class="line">        If RemoveNode(key) = False Then Return</span><br><span class="line">        For i = Tuples.Count - 1 To 0 Step -1</span><br><span class="line">            If Tuples(i).Item1 = key Or Tuples(i).Item2 = key Then</span><br><span class="line">                Tuples.RemoveAt(i)</span><br><span class="line">            End If</span><br><span class="line">        Next</span><br><span class="line">End Sub</span><br><span class="line"></span><br><span class="line">    Private Function RemoveNode(key As String) As Boolean</span><br><span class="line">        Dim node As TreeNode = SearchNode(Root, key)</span><br><span class="line">        If node Is Nothing Then Return False</span><br><span class="line">        Dim parentnode As TreeNode = node.Parent()</span><br><span class="line">        If parentnode Is Nothing Then Return False //企图删除根节点</span><br><span class="line">        parentnode.Nodes.Remove(node)</span><br><span class="line">        Return True</span><br><span class="line">    End Function</span><br></pre></td></tr></table></figure>
<p>#4<br>    请编写函数，创建一列n个按钮控件，并指定每个按钮的Click事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Public Class clsButtonRow</span><br><span class="line">    Private Buttons As List(Of Button)</span><br><span class="line">    Private Width As Integer   // 方形按钮的宽度</span><br><span class="line">    Private XGap As Integer    //X方向按钮的间距</span><br><span class="line">    Private Start As Point     //按钮集合的排列起点（左上角）</span><br><span class="line"></span><br><span class="line">    Public Sub New(frm As frmTest, Start As Point, ButtonN As Integer)</span><br><span class="line">        Me.Width = 25 : Me.XGap = 1</span><br><span class="line">        Me.Start = Start</span><br><span class="line">        // 创建按钮集合</span><br><span class="line">        CreateButtons(ButtonN)</span><br><span class="line">        //将按钮集合加入frm中</span><br><span class="line">        For i = 0 To ButtonN - 1</span><br><span class="line">            frm.Controls.Add(Buttons(i))</span><br><span class="line">        Next</span><br><span class="line">        frm.ResumeLayout(False) </span><br><span class="line">        //恢复正常的布局逻辑，可以选择强制对挂起的布局请求立即进行布局。</span><br><span class="line">        frm.PerformLayout()     </span><br><span class="line">        //强制控件将布局逻辑应用于其所有子控件。</span><br><span class="line">    End Sub</span><br><span class="line"></span><br><span class="line">    Public Sub CreateButtons(ButtonN As Integer)</span><br><span class="line">        Buttons = New List(Of Button)</span><br><span class="line">        For i = 0 To ButtonN - 1</span><br><span class="line">            Buttons.Add(New Button)</span><br><span class="line">            With Buttons(i)</span><br><span class="line">                .Name = &quot;btn&quot; &amp; i</span><br><span class="line">                .Text = &quot;&quot;</span><br><span class="line">                .TabIndex = i</span><br><span class="line">                .UseVisualStyleBackColor = True</span><br><span class="line">                .Size = New System.Drawing.Size(Width, Width)</span><br><span class="line">                .Location = New System.Drawing.Point(Start.X + i * (Width + XGap), Start.Y)</span><br><span class="line">            End With</span><br><span class="line">            AddHandler Buttons(i).Click, AddressOf Button_Click</span><br><span class="line">        Next</span><br><span class="line">    End Sub</span><br><span class="line"></span><br><span class="line">    Private Sub Button_Click(sender As Object, e As EventArgs)</span><br><span class="line">        MsgBox(&quot;Hello &quot; &amp; sender.name)</span><br><span class="line">    End Sub</span><br><span class="line"></span><br><span class="line">End Class</span><br></pre></td></tr></table></figure></p>
<p>#5<br>    请举例说明Delegate类型的作用。</p>
<blockquote>
<ul>
<li>可交互的后台任务类<br>1 学习委托类型。其本质是指向函数的指针类型。委托对象是具体某个函数的地址。<br>2 在跨线程操作的流程中，委托对象使得一个线程可以通知另一个线程，执行指定的操作。</li>
</ul>
</blockquote>
<p>界面窗体的引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Private frmOut As frmTest       //拥有控件的窗体，有权改写控件</span><br><span class="line">Public Sub New(para As WorkerPara, frmOut As frmTest)</span><br><span class="line">       Me.frmOut = frmOut</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure></p>
<p>委托类型的定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Delegate Sub AppendMessage(id As Integer, msg As String) //函数类型</span><br></pre></td></tr></table></figure></p>
<p>委托对象的定义、创建、使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Private ReportProgress As AppendMessage  </span><br><span class="line">&apos;函数对象，向界面报告计算的进度</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Me.ReportProgress = New AppendMessage(AddressOf frmOut.AppendMessage)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在拥有控件的窗口线程上，用指定的参数列表执行指定委托函数。</span><br><span class="line">frmOut.Invoke(ReportProgress, para.id, sum.ToString)</span><br></pre></td></tr></table></figure>
<p>#6<br>    请举例说明自定义事件的使用方法。</p>
<p>#7<br>    请举例说明BackgroundWorker的使用方法。</p>
<blockquote>
<ul>
<li>BackgroundWorker是•net里用来执行多线程任务的控件</li>
<li>BackgroundWorker类（在单独的线程上执行操作）。</li>
<li>RunWorkerAsync方法：开始执行后台操作；</li>
<li>CancelAsync方法：请求取消挂起的后台操作。</li>
<li>在程序中调用BackgroundWorker控件的RunWorkerAsync方法则会启动DoWork事件的事件处理，当DoWork事件处理完成时，则会触发RunWorkerCompleted事件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例子：2开发环境-&gt;5多线程技术-&gt;2单个后台线程的运行过程</span><br><span class="line">附加：发射小球（多线程）</span><br><span class="line">功能：利用BackgroundWorker类的对象，在后台线程上，进行大计算，界面无停滞感觉。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>（1）在frmTest窗口设计中，从工具箱拖拉一个BackgroundWorker控件至窗口下方，重命名为bkWork。</li>
<li>（2）在开始按钮的Click事件btnStart_Click中，开始执行后台操作：<br>Me.bkWork.RunWorkerAsync(para)，其中para是包装后的参数</li>
<li>（3）在bkWork_DoWork事件中，处理大计算操作。</li>
<li>（4）在bkWork_RunWorkerCompleted事件中，在文本框中显示大计算的结果：txtResult.Text = e.Result</li>
<li>（5）在取消按钮的Click事件btnCancel_Click中，请求取消挂起的后台操作：      Me.bkWork.CancelAsync()</li>
</ul>
</blockquote>
<p>#8<br>    请举例说明Parallel.For的使用方法。</p>
<p>#9<br>    在智能输入中，用户在文本框中按键后，会显示输入提示，文本框将显示用户所确定的选项。请写出程序操作流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考程序：3开发项目-&gt;1键盘操作-&gt;1智能输入-&gt;2词库类</span><br><span class="line">功能：在文本框中输入字符，弹出单词选择窗口，用户可以输入字符，也可选择单词。</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>（1）frmListBox_Load事件中：读文件，初始化词库</li>
<li>（2）txtContent_KeyPress事件中：获取当前用户在文本框中输入字符串<pre><code>frm_WordSelected，frm_CharPress事件，GetLastChars()函数
</code></pre></li>
<li>（3）WordListInit(LastChars As String)中：显示最接近的单词集<pre><code>LastChars是指主窗口中正在输入的单词，已经输入的部分。
</code></pre></li>
<li>（4）lstWords_KeyPress事件中：接受输入的字符，将其传入主窗口的文本框中，同时调整当前选项的位置； </li>
<li>（5）lstWords_KeyPress事件中：接受空格字符，表示选定当前选项，并将选定单词传入主窗口的文本框中；</li>
</ul>
</blockquote>
<p>#10<br>    在文本编辑中，常常有对命令序列的管理要求。请写出基本操作的类型定义，及命令序列的存储结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考程序：3开发项目-&gt;1键盘操作-&gt;1智能输入-&gt;4操作历史-&gt;2回退&amp;前进</span><br></pre></td></tr></table></figure></p>
<p>##<strong>基本操作的类型定义：</strong></p>
<p>###（1）操作虚类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Public MustInherit Class clsOp</span><br><span class="line">    Public MustOverride Sub DoWork(txtContent As TextBox)</span><br><span class="line">    Public MustOverride Sub UnDo(txtContent As TextBox)</span><br><span class="line">End Class</span><br><span class="line">无子过程</span><br></pre></td></tr></table></figure></p>
<p>###（2）插入类，继承于操作虚类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在position之前插入newchars </span><br><span class="line">Public Class clsInsertOp</span><br><span class="line">    Inherits clsOp</span><br><span class="line">    Private position As Integer, newchars As String</span><br></pre></td></tr></table></figure></p>
<p>###（3）更新类，继承于操作虚类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Public Class clsUpdateOp</span><br><span class="line">    Inherits clsOp</span><br><span class="line">    Private position As Integer, length As Integer</span><br><span class="line">    Private oldchars As String, newchars As String   </span><br><span class="line">    //    替换前的旧文本, 替换后的新文本</span><br><span class="line">包含的子过程：</span><br><span class="line">New(position As Integer, length As Integer, oldchars As String, newchars As String)（其他同上）</span><br></pre></td></tr></table></figure></p>
<p>###（4）删除类，继承于操作虚类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//从position开始删除长度为length的字符串</span><br><span class="line">Public Class clsDeleteOp</span><br><span class="line">    Inherits clsOp</span><br><span class="line">    Private position As Integer, length As Integer</span><br><span class="line">    Private deletetxt As String  </span><br><span class="line">    // 删除的文本</span><br><span class="line">包含的子过程：</span><br><span class="line">New(position As Integer, length As Integer, deletetxt As String) </span><br><span class="line">（其他同上）</span><br></pre></td></tr></table></figure></p>
<p>##<strong>命令序列的存储结构：</strong></p>
<p>###（5）操作集合类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Public Class clsOps</span><br><span class="line">    Private Ops As List(Of clsOp), ith As Integer</span><br><span class="line">End Class</span><br></pre></td></tr></table></figure></p>
<p>#11<br>    在图像处理中，位图的数据类型是什么？举例说明如何读写像素？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考程序：3开发项目-&gt;2图像处理-&gt;1图像读写与分析-&gt;1图像文件及像素RGB的读写</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>位图的数据类型：<strong>Bitmap</strong><br><strong>Bitmap类：</strong>用于处理由像素数据定义的图像的对象。<br><strong>读写像素举例：</strong></p>
</blockquote>
<p>##（1）在picturebox  picCanvas中打开显示图像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Fname = &quot;Tulips.jpg&quot;</span><br><span class="line">        	Source = New Bitmap(Fname)   //在图像计算中，用作数据源</span><br><span class="line">        	Target = New Bitmap(Source)    // 用于显示</span><br><span class="line">        	picCanvas.Image = Target       </span><br><span class="line">        	                            // Bitmap是Image(虚类)的子类</span><br><span class="line">       	picCanvas.Width = Target.Width</span><br><span class="line">        picCanvas.Height = Target.Height</span><br></pre></td></tr></table></figure></p>
<p>##（2）保存图像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dim Fname1 As String = &quot;Tulips1.jpg&quot;</span><br><span class="line">Target.Save(Fname1)</span><br></pre></td></tr></table></figure></p>
<p>##（3）图像的操作（修改像素）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    // GetPixel、SetPixel</span><br><span class="line">Dim oldcolor As Color = Source.GetPixel(i, j)</span><br><span class="line">newcolor = Color.FromArgb(oldcolor.R, 0, 0)</span><br><span class="line">Target.SetPixel(i, j, newcolor)</span><br></pre></td></tr></table></figure></p>
<p>注：FromArgb(R,G,B)从指定的8位颜色值（红绿蓝）创建system.drawing.color结构。</p>
<p>#12<br>    在播放幻灯片时，有许多图像切换特效。请举例说明其实现方法。</p>
<p>通过文件名获得source原图片，并设置target图片的宽和高，设置picturebox控件中的图片为target暂时为空，并设置picturebox的宽和高为target的 宽和高<br><strong>百叶窗效果：</strong><br>①//自定义一个timer控件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Private WithEvents Timer1 As System.Windows.Forms.Timer </span><br><span class="line">并设置这个控件的属性（在btnOpen_Click（）事件中添加）</span><br><span class="line">Timer1 = New System.Windows.Forms.Timer		//创建一个类的对象</span><br><span class="line">Timer1.Interval = 50					//设置tick时间发生的时间间隔为50ms</span><br><span class="line">Timer1.Enabled = True				//使timer控件中的timer事件有效</span><br></pre></td></tr></table></figure></p>
<p>②添加Timer 的tick事件，每经过Interval属性指定的时间间隔时发生一次<br>根据单选按钮Radio的check值选择执行DisplayVertical函数还是DisplayHorizontal函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Private Sub Timer1_Tick(sender As Object, e As System.EventArgs) Handles Timer1.Tick</span><br><span class="line">     Const dx As Integer = 5, dy As Integer = 5</span><br><span class="line">     If RadioVertical.Checked = True Then DisplayVertical(dx)	</span><br><span class="line">     If RadioHorizontal.Checked = True Then DisplayHorizontal(dy)</span><br><span class="line">     picCanvas.Refresh()</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure></p>
<p>③添加 DisplayVertical (dx As Integer)函数            垂直百叶<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Private Sub DisplayVertical(dx As Integer)</span><br><span class="line">        Static xStart As Integer = 0</span><br><span class="line">        If xStart &gt;= Source.Width Then</span><br><span class="line">            xStart = 0 : Timer1.Enabled = False</span><br><span class="line">        End If</span><br><span class="line">        For x = xStart To xStart + dx - 1</span><br><span class="line">            If x &gt;= Source.Width Then Exit For	//如果像素点横坐标超过图片宽度则退出循环</span><br><span class="line">            For y = 0 To Source.Height - 1</span><br><span class="line">                Dim c As Color = Source.GetPixel(x, y)</span><br><span class="line">                Target.SetPixel(x, y, c)</span><br><span class="line">            Next</span><br><span class="line">        Next</span><br><span class="line">        xStart += dx</span><br><span class="line">    End Sub</span><br></pre></td></tr></table></figure></p>
<p>#13<br>    区域选择是图像处理中的基本操作，请说明区域选择的方法，区域的数据结构，及可能的操作。</p>
<p>##区域的数据结构：<br><img src="http://static.zybuluo.com/rg070836rg/1bp38o4tapu2xi8oy5ubdwtu/01.png" alt="01.png-40.3kB"><br><img src="http://static.zybuluo.com/rg070836rg/fjpb1180zok7uvrrevy56hgk/02.png" alt="02.png-24kB"></p>
<p>##区域选择的方法：</p>
<blockquote>
<ul>
<li>首先创建BitmapModifier对象，在创建的过程中通过new函数将SourceBuff中符合条件的像素值，改为Mark色，写入TargetBuff</li>
<li>然后通过GetRegions函数根据Mark色识别、创建区域，保存到区域集合对象中</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//构造函数</span><br><span class="line">Public Sub New(fname As String, red As Tuple(Of Integer, Integer), green As Tuple(Of Integer, Integer), blue As Tuple(Of Integer, Integer), Mark As Color)</span><br><span class="line">    </span><br><span class="line">//GetRegions函数 通过像素点的颜色值来选择的，RGB的颜色值在上面范围呢，就选中</span><br><span class="line">//在TargetBuff中，根据Mark识别、创建区域，保存到区域集合对象中</span><br><span class="line">    Function GetRegions() As clsRegions</span><br><span class="line">   </span><br><span class="line">//bfs函数</span><br><span class="line">Private Function Bfs(Buff As Bitmap, sp As Point, flagMatrix(,) As Boolean) As List(Of Point)</span><br></pre></td></tr></table></figure>
<p>##可能的操作</p>
<blockquote>
<ul>
<li>定义了red,green,blue三个二元组。</li>
<li>当点击form上的open按钮获得图片，此时同时设置这三个二元组（这个作为区域内点的颜色范围）,</li>
<li>创建BitmapModifier对象根据区域内点的颜色范围为source图片标记mark色（在构造函数里）。</li>
<li>当点击GetRegions函数时，调用BitmapModifier类的GetRegions函数和Regions的FillList函数</li>
</ul>
</blockquote>
<p>#14<br>    绘图软件中，图形对象的管理是如何实现的？请写出图元类的结构定义。</p>
<p>##图形对象的管理</p>
<blockquote>
<ul>
<li>定义抽象基类clsElem，类clsLine、clsRectangle等图形类继承它</li>
<li>定义类clsElems作为图形元素的集合类，其数据成员是List类型存放clasElem对象。</li>
<li>绘图时，创建一个clsElems的对象Elems作为存储图形元素的对象，</li>
<li>当鼠标按下并抬起后创建直线或矩形等图形对象，并将其添加到Elems中。</li>
</ul>
</blockquote>
<p>##图元类的结构定义</p>
<p>###抽象类：clsElem<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Public MustInherit Class clsElem</span><br><span class="line">    Public MustOverride Sub Draw(ByVal g As Graphics)</span><br><span class="line">End Class</span><br></pre></td></tr></table></figure></p>
<p>###子类1直线类：clsElem<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class clsLine</span><br><span class="line">    Inherits clsElem</span><br><span class="line"></span><br><span class="line">    Private sp, ep As PointF</span><br><span class="line"></span><br><span class="line">    Public Sub New(ByVal sp As PointF, ByVal ep As PointF)</span><br><span class="line">        Me.sp = sp : Me.ep = ep</span><br><span class="line">    End Sub</span><br><span class="line"></span><br><span class="line">    Public Overrides Sub Draw(g As Graphics)	</span><br><span class="line">        Dim myPen As New Pen(Color.Red, 1)</span><br><span class="line">        g.DrawLine(myPen, sp, ep)</span><br><span class="line">    End Sub</span><br><span class="line">    Public Overrides Function ToString() As String</span><br><span class="line">        Dim s As String = &quot;Line &quot;</span><br><span class="line">        s = s &amp; &quot;: &quot; &amp; sp.ToString &amp; &quot;,&quot; &amp; ep.ToString</span><br><span class="line">        Return s</span><br><span class="line">    End Function</span><br><span class="line"></span><br><span class="line">End Class</span><br></pre></td></tr></table></figure></p>
<p>###类clsElems：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Public Class clsElems</span><br><span class="line">    Public elems As List(Of clsElem)</span><br><span class="line">Event Redraw()</span><br><span class="line"></span><br><span class="line">    Public Sub New()</span><br><span class="line">        elems = New List(Of clsElem)</span><br><span class="line">    End Sub</span><br><span class="line">    Public Sub Append(e As clsElem)</span><br><span class="line">        elems.Add(e)</span><br><span class="line">        RaiseEvent Redraw() </span><br><span class="line">    End Sub</span><br><span class="line"></span><br><span class="line">    Public Sub Draw(ByVal g As Graphics)</span><br><span class="line">        For i = 0 To elems.Count - 1</span><br><span class="line">            elems(i).Draw(g)</span><br><span class="line">        Next</span><br><span class="line">    End Sub</span><br><span class="line"></span><br><span class="line">    Public Function Count() As Integer</span><br><span class="line">        Return elems.Count</span><br><span class="line">    End Function</span><br><span class="line">    Public Function GetElem(index As Integer) As clsElem</span><br><span class="line">        Return elems(index)</span><br><span class="line">    End Function</span><br><span class="line">End Class</span><br></pre></td></tr></table></figure></p>
<p>#15<br>    绘图软件中，用户应能设定作图的范围，并在该范围内利用鼠标绘图。请写出实现方法。</p>
<p>##变换矩阵<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Class clsMatrix3</span><br><span class="line">    Private M11, M12, M13 As Single</span><br><span class="line">    Private M21, M22, M23 As Single</span><br><span class="line">    Private M31, M32, M33 As Single</span><br><span class="line"></span><br><span class="line">    Public Sub New()</span><br><span class="line">        M11 = 1 : M12 = 0 : M13 = 0</span><br><span class="line">        M21 = 0 : M22 = 1 : M23 = 0</span><br><span class="line">        M31 = 0 : M32 = 0 : M33 = 1</span><br><span class="line">    End Sub</span><br><span class="line">    Sub New(a As Single, b As Single, c As Single, d As Single)</span><br><span class="line">        M11 = a : M12 = 0 : M13 = 0</span><br><span class="line">        M21 = 0 : M22 = c : M23 = 0</span><br><span class="line">        M31 = b : M32 = d : M33 = 1</span><br><span class="line">    End Sub</span><br><span class="line"></span><br><span class="line">    Function Tranform(p As PointF) As PointF</span><br><span class="line">        Dim newp As PointF</span><br><span class="line">        newp.X = p.X * M11 + p.Y * M21 + M31</span><br><span class="line">        newp.Y = p.X * M12 + p.Y * M22 + M32</span><br><span class="line">        Return newp</span><br><span class="line">    End Function</span><br><span class="line"></span><br><span class="line">End Class</span><br></pre></td></tr></table></figure></p>
<p>##转换公式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">通过Lp2Dp函数可以将逻辑坐标转为设备坐标</span><br><span class="line">Public Function Lp2Dp(Lp As PointF) As Point</span><br><span class="line">        Dim p As PointF = M_Lp2Dp.Tranform(Lp)</span><br><span class="line">        Dim newp As Point</span><br><span class="line">        newp.X = p.X : newp.Y = p.Y</span><br><span class="line">        Return newp</span><br><span class="line">    End Function</span><br><span class="line"></span><br><span class="line">通过Dp2Lp函数可以将设备坐标转为逻辑坐标</span><br><span class="line">Public Function Dp2Lp(Dp As Point) As PointF</span><br><span class="line">        Return M_Dp2Lp.Tranform(Dp)</span><br><span class="line">    End Function</span><br><span class="line">    End Function</span><br></pre></td></tr></table></figure></p>
<p>定义两个数据成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Private CS As clsCS  //picCanvas中的坐标系</span><br><span class="line">Dim DBox, LBox As clsBox    //设备坐标、逻辑坐标的范围</span><br></pre></td></tr></table></figure></p>
<p>窗口在初始化时设置设备坐标，逻辑坐标，坐标系的值，其中逻辑坐标范围是由用户设定的，根据DBox和LBox设置picCanvas中的坐标系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Private Sub frmTest_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load</span><br><span class="line">        DBox = New clsBox(0, picCanvas.Width, picCanvas.Height, 0)</span><br><span class="line">        LBox = New clsBox(txtXmin.Text, txtXmax.Text, txtYmin.Text, txtYmax.Text)</span><br><span class="line">        CS = New clsCS(DBox, LBox)</span><br><span class="line">        Lines = New clsLines : Polygon = Nothing</span><br><span class="line">        Flag = OpFlag.Create : tvPoints.Nodes.Add(Lines.Node)</span><br><span class="line">        Redraw()</span><br><span class="line">    End Sub</span><br></pre></td></tr></table></figure></p>
<p>当设置作图范围的按钮按下时，逻辑坐标的范围将重置并重新设定作图范围<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Private Sub btnSetup_Click(sender As System.Object, e As System.EventArgs) Handles btnSetup.Click</span><br><span class="line">        LBox = New clsBox(txtXmin.Text, txtXmax.Text, txtYmin.Text, txtYmax.Text)</span><br><span class="line">        CS = New clsCS(DBox, LBox)</span><br><span class="line">        Redraw()</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure></p>
<p>重新设定作图范围，首先将整个绘图界面清除并填充为白色，通过调用CS的Draw函数为作图区域作坐标系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Private Sub Redraw()</span><br><span class="line">        Dim g As Graphics = picCanvas.CreateGraphics</span><br><span class="line">        g.Clear(Color.White)</span><br><span class="line">        CS.Draw(g)</span><br><span class="line">        If Flag = OpFlag.Create Then Lines.Draw(g, CS)</span><br><span class="line">        If Flag = OpFlag.Modify Then Polygon.Draw(g, CS)</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure></p>
<p>CS的Draw函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Public Sub Draw(g As Graphics)</span><br><span class="line">		//通过Lp2Dp()函数和sp,ep的横坐标画出坐标系的横坐标</span><br><span class="line">        Dim myPen = New Pen(Color.Blue, 1)</span><br><span class="line">        Dim sp, ep As PointF</span><br><span class="line">        sp.X = LBox.xmin : sp.Y = 0</span><br><span class="line">        ep.X = LBox.xmax : ep.Y = 0</span><br><span class="line">        Dim sp1 As Point = Lp2Dp(sp)</span><br><span class="line">        Dim ep1 As Point = Lp2Dp(ep)</span><br><span class="line">        g.DrawLine(myPen, sp1, ep1)</span><br><span class="line"></span><br><span class="line">		//通过Lp2Dp()函数和sp,ep的纵坐标画出坐标系的横坐标</span><br><span class="line">        sp.X = 0 : sp.Y = LBox.ymin</span><br><span class="line">        ep.X = 0 : ep.Y = LBox.ymax</span><br><span class="line">        Dim sp2 As Point = Lp2Dp(sp)</span><br><span class="line">        Dim ep2 As Point = Lp2Dp(ep)</span><br><span class="line">        g.DrawLine(myPen, sp2, ep2)</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure></p>
<p>#16<br>    绘图软件中，创建图形对象中的橡皮筋技术、图形变换中的拖动技术，极大的改善了绘图界面，请说明其中的事件流程。</p>
<p>##橡皮筋技术<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class CEx1View : public CView</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">	CPoint m_prev, m_ep;</span><br><span class="line">void CEx1View::OnLButtonDown(UINT nFlags, CPoint point) </span><br><span class="line">&#123;</span><br><span class="line">	CView::OnLButtonDown(nFlags, point);</span><br><span class="line">    m_prev=point;	m_ep=point;</span><br><span class="line">	CDC *pDC=GetDC();</span><br><span class="line">	pDC-&gt;SetROP2(R2_NOTXORPEN); </span><br><span class="line">    if(m_tool==1)</span><br><span class="line">	&#123; CLine oldline(m_prev,m_ep ); </span><br><span class="line">	  oldline.SetColor(m_color); oldline.Draw(pDC);</span><br><span class="line">	&#125;</span><br><span class="line">    if(m_tool==2)</span><br><span class="line">    &#123; double oldr=…………;</span><br><span class="line">      CCircle oldcircle(m_prev,oldr);</span><br><span class="line">	  oldcircle.SetColor(m_color); oldcircle.Draw(pDC);</span><br><span class="line">    &#125;</span><br><span class="line">	SetCapture();</span><br><span class="line">&#125;</span><br><span class="line">void CEx1View::OnMouseMove(UINT nFlags, CPoint point) </span><br><span class="line">&#123;</span><br><span class="line">	if(nFlags!=MK_LBUTTON)   return;</span><br><span class="line">	CDC *pDC=GetDC();</span><br><span class="line">	pDC-&gt;SetROP2(R2_NOTXORPEN);</span><br><span class="line">    if(m_tool==1)</span><br><span class="line">	&#123; CLine oldline(m_prev,m_ep ); </span><br><span class="line">	  oldline.SetColor(m_color); oldline.Draw(pDC);</span><br><span class="line">	  CLine newline(m_prev,point);</span><br><span class="line">	  newline.SetColor(m_color); newline.Draw(pDC);</span><br><span class="line">	&#125;</span><br><span class="line">    if(m_tool==2)</span><br><span class="line">    &#123; double oldr=…………;</span><br><span class="line">      CCircle oldcircle(m_prev,oldr);</span><br><span class="line">	  oldcircle.SetColor(m_color); oldcircle.Draw(pDC);</span><br><span class="line">	  double newr=…………;</span><br><span class="line">      CCircle newcircle(m_prev,newr);</span><br><span class="line">	  newcircle.SetColor(m_color); newcircle.Draw(pDC);</span><br><span class="line">    &#125;</span><br><span class="line">	m_ep=point;</span><br><span class="line">	CView::OnMouseMove(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line">void CEx1View::OnLButtonUp(UINT nFlags, CPoint point) </span><br><span class="line">&#123;  ……………………</span><br><span class="line">	CEx1Doc* pDoc = GetDocument();</span><br><span class="line">     ………</span><br><span class="line">     pDoc-&gt;AddElem(pline);</span><br><span class="line">	ReleaseCapture();</span><br><span class="line">	Invalidate(true);</span><br><span class="line">&#125;</span><br><span class="line">void CEx1View::OnDraw(CDC* pDC)</span><br><span class="line">&#123;</span><br><span class="line">	pDC-&gt;SetROP2(R2_COPYPEN);</span><br><span class="line">	for(int i=0; i&lt;pDoc-&gt;GetElemCount(); i++)</span><br><span class="line">	&#123; CElem *pelem=pDoc-&gt;GetElem(i);</span><br><span class="line">	  pelem-&gt;Draw(pDC); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##拖动技术<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class CEx1View : public CView</span><br><span class="line">&#123;  ……………</span><br><span class="line">    CLine   *m_pLine;</span><br><span class="line">	CCircle *m_pCircle;</span><br><span class="line">	CPoint m_prev, m_ep;</span><br><span class="line">void CEx1View::OnMouseMove(UINT nFlags, CPoint point) </span><br><span class="line">&#123;</span><br><span class="line">	if(nFlags!=MK_LBUTTON)   return;</span><br><span class="line">	CDC *pDC=GetDC();</span><br><span class="line">	pDC-&gt;SetROP2(R2_NOTXORPEN); </span><br><span class="line">    if(m_tool==1)</span><br><span class="line">	&#123; CLine oldline(*m_pLine);</span><br><span class="line">	  oldline.Pan(m_ep-m_prev); oldline.Draw(pDC);</span><br><span class="line">      CLine newline(*m_pLine);</span><br><span class="line">	  newline.Pan(point-m_prev);newline.Draw(pDC); </span><br><span class="line">	&#125;</span><br><span class="line">    if(m_tool==2)</span><br><span class="line">	&#123; CCircle oldcircle(*m_pCircle);</span><br><span class="line">	  oldcircle.Pan(m_ep-m_prev); oldcircle.Draw(pDC);</span><br><span class="line">      CCircle newcircle(*m_pCircle);</span><br><span class="line">	  newcircle.Pan(point-m_prev);newcircle.Draw(pDC); </span><br><span class="line">	&#125;</span><br><span class="line">	m_ep=point;</span><br><span class="line">	CView::OnMouseMove(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line">void CEx1View::OnLButtonUp(UINT nFlags, CPoint point) </span><br><span class="line">&#123;</span><br><span class="line">	CView::OnLButtonUp(nFlags, point);</span><br><span class="line">    if(m_tool==1) m_pLine-&gt;Pan(point-m_prev); </span><br><span class="line">    if(m_tool==2) m_pCircle-&gt;Pan(point-m_prev); </span><br><span class="line">	ReleaseCapture();</span><br><span class="line">	Invalidate(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#17 </p>
<p>绘图软件中，图形对象的点选择，是如何实现的？请写出相关的类中的方法接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目存在于：0000讲义\09 二维图形项目\3 图形对象的选择技术\1 点选择图形</span><br></pre></td></tr></table></figure></p>
<p>下面是经过我筛选的代码图<br><img src="http://static.zybuluo.com/rg070836rg/o77kb5xmqxu7y2dsbfpgdx46/1.png" alt="1.png-49.9kB"></p>
<p>经过代码分析，关系图如上所示，结论如下：</p>
<blockquote>
<ul>
<li>基类clsElem里面定义了必须重写的纯需函数SelectBypoint();</li>
<li>clsElems类是面向窗体，管理所有元素的类，其中的SelectBypoint()调用元素的函数：elems(i).SelectByPoint(p)，只要有一个为真，判断终止，返回元素编号，否则返回-1</li>
<li>clsLine继承clsElem，重写了SelectBypoint，并设有同名的共享函数，用于计算是否选中(判断过程是，看选中点是否在起点到终点的直线段上，运行存在delta的误差)，同时也方便其他类的调用</li>
<li>clsRectangle继承clsElem，重写了SelectBypoint方法，在其中构造4组起点终点，调用clsLine中的共享函数，只要有一组为真，就被选中</li>
<li>clsPolygon继承clsElem，重写了SelectBypoint,从它的KeyPoints数组中，依次抽出两点，判断并迭代更新，只要有一个为真，就被选中</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类接口：</span><br><span class="line">SelectBypoint();</span><br></pre></td></tr></table></figure>
<hr>
<p>#18<br>    绘图软件和图像处理中，都存在线性变换，请写出平移、变比、旋转的变换矩阵。</p>
<p><strong>平移</strong>：相对坐标原点平移$(Tx,Ty)$<br>\begin{equation}<br>T_t=<br>\left[<br>\begin{array}{ccc}<br>1 &amp; 0 &amp; 0  \<br>0 &amp; 1 &amp; 0  \<br>Tx &amp; Ty &amp; 1<br>\end{array}<br>\right]<br>\end{equation}</p>
<p><strong>变比</strong>：相对坐标原点，沿x方向缩放Sx倍，沿y方向缩放Sy倍：<br>\begin{equation}<br>T_s=<br>\left[<br>\begin{array}{ccc}<br>Sx &amp; 0 &amp; 0  \<br>0 &amp; Sy &amp; 0  \<br>0 &amp; 0 &amp; 1<br>\end{array}<br>\right]<br>\end{equation}</p>
<p><strong>旋转</strong>：转过$θ$角</p>
<p>\begin{equation}<br>T_r=<br>\left[<br>\begin{array}{ccc}<br>cosθ &amp; sinθ &amp; 0  \<br>-sinθ &amp; cosθ  &amp; 0  \<br>0 &amp; 0 &amp; 1<br>\end{array}<br>\right]<br>\end{equation}</p>
<hr>
<p>#19<br>    良好的绘图软件，应该支持层次化的图形对象结构。请写出自定义块类和块插入对象的类定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目存在于：0000讲义\二位图形项目1-5\5 层次化的对象结构\2 自定义块的管理</span><br></pre></td></tr></table></figure></p>
<p><strong>自定义块类</strong><br><img src="http://static.zybuluo.com/rg070836rg/tukh8g9m5fianmhpizdgja9g/03.png" alt="03.png-24.2kB"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Public Class clsBlock</span><br><span class="line">    Private Elems As List(Of clsElem)</span><br><span class="line">    Private BasePoint As PointF</span><br><span class="line">    Public Sub New(ByVal Elems As clsSelection, ByVal BasePoint As PointF)</span><br><span class="line">    Public Function Count() As Integer</span><br><span class="line">    Public Function Item(ByVal index As Integer) As clsElem</span><br><span class="line">    Public Function GetBasePoint() As PointF</span><br><span class="line">End Class</span><br><span class="line">``` </span><br><span class="line">&gt;+ 属性：</span><br><span class="line">&gt; 1. **Elems**  </span><br><span class="line">存储当前被选中的元素集合，来源于clsSelection.clone()</span><br><span class="line">&gt; 2. **BasePoint** </span><br><span class="line">基点(0,0) 可以是其他点</span><br><span class="line">&gt;+ 函数</span><br><span class="line">&gt;1. **New(ByVal Elems As clsSelection, ByVal BasePoint As PointF)** </span><br><span class="line">构造函数</span><br><span class="line">&gt;2. **Count()** </span><br><span class="line">返回块对象中基本元素个数</span><br><span class="line">&gt;3. **Item(ByVal index As Integer)**  </span><br><span class="line">返回块对象中第index个个基本元素的引用</span><br><span class="line">&gt;4. **GetBasePoint()** </span><br><span class="line">返回基点位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**块插入对象的类定义**</span><br><span class="line">![04.png-41.8kB][5]</span><br></pre></td></tr></table></figure></p>
<p>Public Class clsBlockInsert<br>    Inherits clsElem<br>    Private Block As clsBlock<br>    Private M As clsMatrix3   对Block中所有图形对象的变换矩阵<br>    Public Sub New(ByVal Block As clsBlock, ByVal InsertPoint As PointF, ByVal scaleX As Single, ByVal scaleY As Single, ByVal angle As Single)<br>    Public Sub New(ByVal Block As clsBlock, ByVal M As clsMatrix3)<br>    Public Overrides Function Clone() As clsElem<br>    Public Overrides Function ToString() As String<br>    Public Overrides Sub Transform(ByVal m As clsMatrix3)<br>End Class</p>
<p><code>`</code></p>
<p>这个类本身继承与clsElem，所以可以被当成基本元素操作</p>
<blockquote>
<ul>
<li>属性：</li>
</ul>
<ol>
<li><strong>Block</strong><br>被定义的块</li>
<li><strong>M</strong><br>对Block中所有图形对象的变换矩阵</li>
</ol>
<ul>
<li>函数</li>
</ul>
<ol>
<li><strong>New(ByVal Block As clsBlock, ByVal InsertPoint As PointF, ByVal     scaleX As Single, ByVal scaleY As Single, ByVal angle As Single)</strong><br>构造函数，根据参数构造变换矩阵</li>
<li><strong>New(ByVal Block As clsBlock, ByVal M As clsMatrix3)</strong><br>构造函数，直接配置矩阵</li>
<li><strong>Clone()</strong><br>构造一个对象返回，值相同</li>
<li><strong>ToString()</strong><br>ToString表明位置</li>
<li><strong>Transform(ByVal m As clsMatrix3)</strong><br>根据矩阵变换</li>
</ol>
</blockquote>
<hr>
<p>#20<br>    在绘图软件中，图形对象的属性包括什么？如何实现属性的共性、个性管理？<br>???</p>
<hr>
<p>#21<br>    在本学期的学习中，你了解了不少软件项目，请写出10个名称及简单功能。</p>
<blockquote>
<ul>
<li>1 资源管理器：用控件显示文件资源，并有简单的操作</li>
<li>2 扫雷软件：扫雷游戏，创建button，并集成用户控件</li>
<li>3 表达式计算器：输入表达式，按步骤求结果</li>
<li>4 多线程,并行计算填图:利用多线程技术，进行并行运算</li>
<li>5 智能输入：利用键树，达到智能提示的效果</li>
<li>6 绘图软件：绘制图形，选中，变换图形</li>
<li>7 积木摆放：较好的摆放积木块，三维</li>
<li>8 朗读文章：可以朗读英文单词</li>
<li>9 图像变化：可以做到图像的效果变换</li>
<li>10 图像拟合图形：可以提取边界，进行边界重组等</li>
</ul>
</blockquote>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/人工智能考题/数电试卷/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/人工智能考题/数电试卷/" itemprop="url">数电试卷</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/人工智能考题/" itemprop="url" rel="index">
                    <span itemprop="name">人工智能考题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p><img src="http://static.zybuluo.com/rg070836rg/j5hnwqllr8bfxwj3zexts8g1/%E9%80%89%E6%8B%A9%E9%A2%981.jpg" alt="选择题1.jpg-132.3kB"><br><img src="http://static.zybuluo.com/rg070836rg/opk0z740ul3e7pl7f1kvxbk2/%E9%80%89%E6%8B%A9%E9%A2%982.jpg" alt="选择题2.jpg-95.5kB"><br><img src="http://static.zybuluo.com/rg070836rg/hh6a13202p52okldo19j4xgt/%E5%A1%AB%E7%A9%BA%E9%A2%982.jpg" alt="填空题2.jpg-71.5kB"><br><img src="http://static.zybuluo.com/rg070836rg/chg6l3u29zc8zfl8q1crk8tn/%E5%A1%AB%E7%A9%BA%E9%A2%983.jpg" alt="填空题3.jpg-52.8kB"><br><img src="http://static.zybuluo.com/rg070836rg/pxaii76rv4zsgfhdvolpb5he/%E7%AE%80%E7%AD%94%E9%A2%98.jpg" alt="简答题.jpg-117.2kB"><br><img src="http://static.zybuluo.com/rg070836rg/t5xcctmh2uwvzx4y5pf23si6/%E7%AC%AC%E5%9B%9B%E5%A4%A7%E9%A2%981.jpg" alt="第四大题1.jpg-77.4kB"><br><img src="http://static.zybuluo.com/rg070836rg/8l1wt1eyfxvm6eok7j5vnd09/%E7%AC%AC%E5%9B%9B%E5%A4%A7%E9%A2%982.jpg" alt="第四大题2.jpg-45.4kB"><br><img src="http://static.zybuluo.com/rg070836rg/po08mcjmxzlmumdaokuobtpp/%E7%AC%AC%E5%9B%9B%E5%A4%A7%E9%A2%983.jpg" alt="第四大题3.jpg-99.3kB"><br><img src="http://static.zybuluo.com/rg070836rg/4q40fimkd00n8efw7mcxrid5/%E7%AC%AC%E5%9B%9B%E5%A4%A7%E9%A2%984.jpg" alt="第四大题4.jpg-63.8kB"><br><img src="http://static.zybuluo.com/rg070836rg/483b4kjvldqdp7v7tejfa0wd/%E7%AC%AC%E5%9B%9B%E5%A4%A7%E9%A2%985.jpg" alt="第四大题5.jpg-55.3kB"><br><img src="http://static.zybuluo.com/rg070836rg/691a3zwx80yr79mus9atuq7p/%E7%AC%AC%E4%BA%94%E7%AD%94%E9%A2%981.jpg" alt="第五答题1.jpg-101.5kB"><br><img src="http://static.zybuluo.com/rg070836rg/ofok2m3179q6w12i64zz7fmy/%E7%AC%AC%E4%BA%94%E7%AD%94%E9%A2%982.jpg" alt="第五答题2.jpg-68.8kB"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/人工智能考题/人工智能考题2015/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/人工智能考题/人工智能考题2015/" itemprop="url">人工智能考题2015</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:20+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/人工智能考题/" itemprop="url" rel="index">
                    <span itemprop="name">人工智能考题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>#一 简答题<br>1.人工智能的英文，以及学科定义<br>2.请举例说出5个人工智能的软硬件<br>3.请说出深度，宽度，有序搜索的open表的数据结构<br>4.请写出与或树中与节点与或节点的定义，并用图表示<br>5.写出prolog语言的4个部分，并说明顺序<br>6.写出用神经网络来描述回归问题的结构和激励函数</p>
<p>#二 应用题<br>1.迷宫的宽度搜索（要求不重复出现）和有序搜索<br>2.与或树求解的深度和宽度<br>3.井字棋的一步最优解（题目给定了4步）<br>4.已知F1，F2，结论L，求解L的正确性（消解）<br>5.神经网络，求解这个神经网络代表的是什么运算（与，或，与或），有阀值</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/Vendetta.jpg" alt="Chens">
            
              <p class="site-author-name" itemprop="name">Chens</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">198</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chens</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

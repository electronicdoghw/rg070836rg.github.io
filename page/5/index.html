<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Chens">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Chens">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chens">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/">





  <title>Chens</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chens</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/算法概论作业/算法概论作业5.26 5.28 5.33/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/算法概论作业/算法概论作业5.26 5.28 5.33/" itemprop="url">算法概论作业5.26 5.28 5.33</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法概论作业/" itemprop="url" rel="index">
                    <span itemprop="name">算法概论作业</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>#5.26<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以下是程序自动分析中的一个问题。对于一组变量x1,x2,…,xn,给定一些形如“xi=xj”的等式约束和形如“xi≠xj”的不等式约束这些约束能否同时满足？</span><br><span class="line">例如，如下一组约束：x1=x2,x2=x3,x3=x4,x1≠x4，是无法同时满足的，请给出一个有效的算法，判断关于n个变量的m个约束是否可同时满足。</span><br></pre></td></tr></table></figure></p>
<p>解题思路:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.先处理相等约束，对相等的变量进行并集操作。</span><br><span class="line">2.检查不等约束，</span><br><span class="line">若不等号两边的变量位于同一个集合，则说明该约束条件是不可满足的，</span><br><span class="line">若所有位于不等号两边的变量都位于不同集合中，即说明该约束条件是可满足的。</span><br></pre></td></tr></table></figure></p>
<p>#5.28<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Alice想要举办一个舞会，为此需要决定邀请什么人参加。目前共有n个人可供选择， Alice根据他们之间是否相识列出了一个相互配对的列表。她希望邀请尽可能多的人参加，但同时必须考虑以下两点：在舞会上，每个人至少可以各找到5个相识和5个不相识的人。</span><br><span class="line">请就此问题给出一个高效的算法，以n个人的列表及其相识配对列表为输入，输出最优的被邀请客人名单。并基于变量n估算其运行时间。</span><br></pre></td></tr></table></figure></p>
<p>思路如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、建立无向图G(V,E)，并求出每个顶点的度</span><br><span class="line">2、遍历所有顶点，若满足d(v)&lt;5或者d(v)&gt;6,则将顶点v放入一个待删除队列delete中</span><br><span class="line">3、将待删除顶点删除，更新相关顶点的度，重复2 直至delete队列为空。</span><br></pre></td></tr></table></figure></p>
<p>算法思路如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一步，建立相识配对列表</span><br><span class="line">第二步：遍历所有顶点，若满足d(v)&lt;5或者d(v)&gt;6,则将顶点v放入一个待删除队列delete</span><br><span class="line">第三步：得出邀请名单</span><br></pre></td></tr></table></figure></p>
<p>#5.33<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请说明如何实现一个关于公式长度为线性时间的Horn公式可满足性问题的吝啬算法。</span><br></pre></td></tr></table></figure></p>
<p>首先读取所有的蕴含生成一张有向图：<br>对于每一个 Horn clause，将每一个左手边的 literal（后简称为 l-literal）连接到一个中间节点，并利用这个中间节点来记录这些l-literals 的个数，然后将中间节点连接到 r-literial（即右手边的 literal）。<br>例<img src="http://static.zybuluo.com/rg070836rg/qa07od4xu34fumw8xnz0jjdw/01.png" alt="01.png-2.4kB">以被表示为：<br><img src="http://static.zybuluo.com/rg070836rg/efszpzff3zv9r5umhjkmgk6t/01.png" alt="01.png-40.9kB"><br>接下来先将所有 literals 的值设为 false ，<br>然后进行 DFS：从“0”节点出发，将它所连结的literal设为true，<br>同时将这个literal 所连的中间结点的值减 1，<br>如果有某个中间结点的值减1后为0，<br>则继续在这个结点上进行搜索，否则跳出。<br>DFS 过程结束后再对 negative clauses 进行验证即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/算法概论作业/算法概论作业5.21 5.22 5.32/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/算法概论作业/算法概论作业5.21 5.22 5.32/" itemprop="url">算法概论作业5.21 5.22 5.32</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法概论作业/" itemprop="url" rel="index">
                    <span itemprop="name">算法概论作业</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>#5.22<br>a) 设这个环的顶点集为 C ，最大权边为 e u v ( , ) 。设在某一时刻， C 被 cut 成两<br>个部分<br>s s 1 2 , ，其中 s1包含 u ，而 s2 包括 v 。因 C 是一个环，所以连结 s s 1 2 , 的<br>边至少有两条，其中至少有一条不为 e 的边 e’，其权不大于 e ，由 cut property<br>可知，存在不含有 e 的最小生成树。<br>b) 因为每次删除的都是图 G 中权最大的环边，由题述中的性质可证。<br>c) 参考 Ex.3.11。<br>d) O E ( )</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/算法概论作业/算法概论作业2.4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/算法概论作业/算法概论作业2.4/" itemprop="url">算法概论作业2.4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法概论作业/" itemprop="url" rel="index">
                    <span itemprop="name">算法概论作业</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>#6.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 定义一维数组a[n]</span><br><span class="line">2. 用dist[i]来存放到a[i]结尾的子序列的最大和</span><br><span class="line">3. 求出dist[]中的最大值，即为最大连续子序列的和</span><br><span class="line">4. 每次dist[i-1] + array[i] &lt;= array[i]时，将begin = i；</span><br><span class="line">5. 每次sum&lt;dist[i]时，end = i；</span><br></pre></td></tr></table></figure></p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int array[n];</span><br><span class="line">  srand((unsigned)time(NULL));</span><br><span class="line">  for (int i = 0; i&lt;n; i++)   //生成串</span><br><span class="line">  &#123;</span><br><span class="line">      int temp = rand()%50-20;</span><br><span class="line">      array[i] = temp;</span><br><span class="line">      cout&lt;&lt;array[i]&lt;&lt;&quot; &quot;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int dist[n] = &#123;0&#125;;</span><br><span class="line"> int sum = 0;</span><br><span class="line"> int end;</span><br><span class="line"> int begin;</span><br><span class="line"> for (i = 1; i&lt;n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     if (dist[i-1] + array[i] &gt; array[i])</span><br><span class="line">     &#123;</span><br><span class="line">         dist[i] = dist[i-1]+array[i]; </span><br><span class="line">     &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">         dist[i] = array[i];</span><br><span class="line">         begin = i;  </span><br><span class="line">     &#125;</span><br><span class="line">     if (sum&lt;dist[i])</span><br><span class="line">     &#123;</span><br><span class="line">         sum = dist[i];</span><br><span class="line">         end = i;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;”最大相连子序列：”;</span><br><span class="line"> for(i = begin; i&lt;=end ; i++)</span><br><span class="line"> &#123;</span><br><span class="line">      cout&lt;&lt;array[i]&lt;&lt;” ”;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;&quot;最大和为：&quot;&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#6.2<br>思想：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 设p[i]为停留在第i个旅店的总最小惩罚</span><br><span class="line">2. 枚举上一个落脚点位置j，则有p[i] = min(p[j] + (200-(a[i] – a[j]))2)，并将min存放入容器route中，用于存放路径。</span><br><span class="line">3. p[n]即为总最小惩罚。 </span><br><span class="line">```</span><br></pre></td></tr></table></figure></p>
<p>  int main()<br> {<br>     int array[n];<br>     vector <int> route;<br>      srand((unsigned)time(NULL));<br>     array[0] = 0;<br>     for (int i = 1; i&lt;n; i++)   //随机产生英里数<br>     {<br>         int temp = rand()%100+10;<br>         array[i] = temp;<br>         cout&lt;&lt;array[i]&lt;&lt;” “;<br>     }</int></p>
<pre><code>int dist[n] = {0};
int min ;
for (i = 1; i&lt;=n; i++)
{
    for(int j = 1 ; j&lt;=i ;j++)  //枚举上一个落脚点位置j
    {    
        if (array[i]-array[j]&lt;=200)  //行走距离不得超过200
        {
            if (dist[j] + (200-(array[i]-array[j])* (array[i]-array[j])) &lt; dist[j-1] + (200-(array[i]-array[j-1])* (array[i]-array[j-1])))
            {
                dist[i] = dist[j] + (200-(array[i]-array[j])* (array[i]-array[j])); 
                min = j;
            }
        }
    }

    if (min&gt;0 &amp;&amp; min&lt;n )   //保存路径
    {
        route.push_back(min);
    }
}
cout&lt;&lt;endl;
cout&lt;&lt;&quot;总最小惩罚为：&quot;&lt;&lt;dist[n]&lt;&lt;endl;
for (i = 0; i&lt; route.size()-1; i++)
{
    cout&lt;&lt;route[i]&lt;&lt;&quot;-&gt;&quot;;
}
cout&lt;&lt;route[route.size()-1];
return 0;
</code></pre><p> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#6.3</span><br></pre></td></tr></table></figure>
<ol>
<li>设r[i]表示前i个位置开分店的最大总利润，且r0 = 0;</li>
<li>若j为上一个满足mi-mj≥k的位置;</li>
<li>则ri = max{ri-1,rj+pi};<br> 若取rj+pi，说明要在i点建酒店，则将i放入容器route</li>
<li><p>最大总利润即为rn</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码如下：</span><br></pre></td></tr></table></figure>
<p>int main()<br>{<br>  int m[n];//距离高速公路起点的距离<br>  int p[n];//可带来的利润<br>  int k  = 50;<br>  vector <int> route;<br>   srand((unsigned)time(NULL));<br>  m[0] = 0;<br>  p[0] = 0;<br>  int i,j = 0;<br>  for (i = 1; i&lt;n; i++)<br>  {</int></p>
<pre><code>int temp  = rand()%100+20;
int temp2 = rand()%1000+100;
m[i] = m[i-1]+ temp;
p[i] = temp2;
cout&lt;&lt;i&lt;&lt;&quot;  距离： &quot;&lt;&lt;m[i]&lt;&lt;&quot; 利润：&quot;&lt;&lt;p[i]&lt;&lt;endl;
</code></pre><p>  }</p>
<p>  int r[n] = {0};<br>  int max ;<br>  for (i = 1; i&lt;=n; i++)<br>  {</p>
<pre><code>for(j = 0; j &lt;= i; j++)//遍历之前的点
{
    if (m[i]-m[j]&gt;=k)
    {
        if(r[i-1]&gt;r[j]+p[i])
        {
            r[i] = r[i-1];
        }
        else
        {
            r[i] = r[j]+p[i];
            route.push_back(i);//将要建造的点入队
        }
    }
}
</code></pre><p>  }<br>  cout&lt;&lt;endl;<br>  cout&lt;&lt;r[n]&lt;&lt;endl;<br>  for (i = 1; i&lt;route.size()-1;i++)//输出建造点<br>  {</p>
<pre><code>if (route[i]!=route[i-1])
{
    cout&lt;&lt;route[i]&lt;&lt;&quot;-&gt;&quot;;
}
</code></pre><p>  }<br>  cout&lt;&lt;route[route.size()-1]&lt;&lt;endl;<br>  return 0;<br>}</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6.4</span><br></pre></td></tr></table></figure>
<ol>
<li>设vi表示前i个字符组成的子串能否被有效分割；</li>
<li>dict[i][j] ==1 为从第i个元素到第j个元素课组成合法字符串；</li>
<li>若dict[j][i]==1 &amp;&amp; v[j] == 1，则v[i] = 1，即前i个字符可被有效分割，并将j入队；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">    vector &lt;int&gt; route;</span><br><span class="line"> 	string s = &quot;itwasthebest&quot;;</span><br><span class="line"> 	bool dict[n][n] = </span><br><span class="line"> 	&#123;&#123;1,1,0,0,0,0,0,0,0,0,0,0&#125;,/*i*/</span><br><span class="line"> 	&#123;0,0,0,0,0,0,0,0,0,0,0,0&#125;,/*t*/</span><br><span class="line"> 	&#123;0,0,0,0,1,1,0,0,0,0,0,0&#125;,/*w*/</span><br><span class="line"> 	&#123;0,0,0,1,1,0,0,0,0,0,0,0&#125;,/*a*/</span><br><span class="line"> 	&#123;0,0,0,0,0,0,0,0,0,0,0,0&#125;,/*s*/</span><br><span class="line"> 	&#123;0,0,0,0,0,0,0,1,0,0,0,0&#125;,/*t*/</span><br><span class="line"> 	&#123;0,0,0,0,0,0,0,1,0,0,0,0&#125;,/*h*/</span><br><span class="line"> 	&#123;0,0,0,0,0,0,0,0,0,0,0,0&#125;,/*e*/</span><br><span class="line"> 	&#123;0,0,0,0,0,0,0,0,0,1,0,1&#125;,/*b*/</span><br><span class="line"> 	&#123;0,0,0,0,0,0,0,0,0,0,0,0&#125;,/*e*/</span><br><span class="line"> 	&#123;0,0,0,0,0,0,0,0,0,0,0,0&#125;,/*s*/</span><br><span class="line"> 	&#123;0,0,0,0,0,0,0,0,0,0,0,0&#125;&#125;;/*t*/</span><br><span class="line"> 	int v[n] = &#123;1&#125;;</span><br><span class="line"> 	for (int i=0; i&lt;n;i++)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		for (int j=0; j&lt;i; j++)</span><br><span class="line"> 		&#123;</span><br><span class="line"> 			if (dict[j][i]==1 &amp;&amp; v[j] == 1)</span><br><span class="line"> 			&#123;</span><br><span class="line"> 				v[i] = 1;</span><br><span class="line"> 				route.push_back(j);</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	cout&lt;&lt;v[n-1]&lt;&lt;endl;</span><br><span class="line"> 	for (i = 0; i&lt;route.size();i++)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		cout&lt;&lt;route[i]&lt;&lt;&quot;-&gt;&quot;;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	cout&lt;&lt;endl;</span><br><span class="line"> 	return 0;</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/算法概论作业/算法概论作业2.3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/算法概论作业/算法概论作业2.3/" itemprop="url">算法概论作业2.3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法概论作业/" itemprop="url" rel="index">
                    <span itemprop="name">算法概论作业</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>#Ex.2.22</p>
<blockquote>
<p>给定两个有序表，大小分别为m和n。给出一个算法，以$O(log m+log n)$的时间找出两个列表合并后的有序列表中的<strong>第K小元素</strong></p>
</blockquote>
<hr>
<p>我们从最基础的情况开始考虑，假设一个数组为空，在另一个数组中找第K小元素，很明显，如果k不超过第二个数组的长度，那么结果就是<code>B[bLeft+k-1]</code><br>反之同理<br>所以，合法性判定，和终止判定如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (k&gt;(aRight - aLeft + 1 + bRight - bLeft + 1))</span><br><span class="line">&#123;</span><br><span class="line">	cerr &lt;&lt; &quot;输入不合法&quot; &lt;&lt; endl;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line">if (aLeft &gt; aRight)&#123;</span><br><span class="line">	return B[bLeft+ k - 1];</span><br><span class="line">&#125;</span><br><span class="line">if (bLeft&gt; bRight)&#123;</span><br><span class="line">	return A[aLeft+ k - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面，我们回归一般情况下<br>我们取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int aMiddle = (aLeft + aRight) / 2;</span><br><span class="line">int bMiddle = (bLeft + bRight) / 2;</span><br></pre></td></tr></table></figure></p>
<p>首先比较$A[aMiddle]$与$B[bMiddle]$的大小<br>我们不妨假设$A[aMiddle]&gt;B[bMiddle]$</p>
<p>如果满足$A[aMiddle]&gt;B[bMiddle]$</p>
<blockquote>
<p>那么必定有$A[aMiddle+1,…,aRight]$排在所有元素的$(aMiddle+bMiddle)$之后<br>同时还有$B[bLeft,…,bMiddle]$排在所有元素的$(aMiddle+bMiddle)$之前</p>
</blockquote>
<p>然后那么如果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k &lt;= (aMiddle-aLeft)+(bMiddle-bLeft)+<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以把A数组右边的部分舍弃，否则<br>我们可以把B数组的左边部分舍弃，并在剩余部分寻找第（k-舍弃部分的个数）</p>
<p>反之亦然。</p>
<p>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (A[aMiddle] &gt; B[bMiddle])</span><br><span class="line">	&#123;</span><br><span class="line">		if (k &lt;= (aMiddle - aLeft) + (bMiddle - bLeft) + 1)</span><br><span class="line">			FindElement(A, B, aLeft, aMiddle - 1, bLeft, bRight, k);</span><br><span class="line">		else</span><br><span class="line">			FindElement(A, B, aLeft, aRight, bMiddle + 1, bRight, k - (bMiddle - bLeft) - 1);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		if (k &lt;= ((aMiddle - aLeft) + (bMiddle - bLeft) + 1))</span><br><span class="line">			FindElement(A, B, aLeft, aRight, bLeft, bMiddle - 1, k);</span><br><span class="line">		else</span><br><span class="line">			FindElement(A, B, aMiddle + 1, aRight, bLeft, bRight, k - (aMiddle - aLeft) - 1);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>全部代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int FindElement(int A[], int B[], int aLeft, int aRight, int bLeft, int bRight, int k);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int A[10] = &#123; 1, 3, 5, 6, 7, 9, 11, 13, 15, 17 &#125;;</span><br><span class="line">	int B[5] = &#123; 2, 4, 8, 10, 12, &#125;;</span><br><span class="line">	//int k;</span><br><span class="line">	//cout &lt;&lt; &quot;请输入k的值：&quot;;</span><br><span class="line">	//cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">	for (int k = 1; k &lt; 10; k++)</span><br><span class="line">		cout &lt;&lt; endl &lt;&lt; FindElement(A, B, 0, 9, 0, 4, k);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int FindElement(int A[], int B[], int aLeft, int aRight, int bLeft, int bRight, int k)</span><br><span class="line">&#123;</span><br><span class="line">	if (k &gt; (aRight - aLeft + 1 + bRight - bLeft + 1))</span><br><span class="line">	&#123;</span><br><span class="line">		cerr &lt;&lt; &quot;输入不合法&quot; &lt;&lt; endl;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	if (aLeft &gt; aRight)&#123;</span><br><span class="line">		return B[bLeft + k - 1];</span><br><span class="line">	&#125;</span><br><span class="line">	if (bLeft &gt; bRight)&#123;</span><br><span class="line">		return A[aLeft + k - 1];</span><br><span class="line">	&#125;</span><br><span class="line">	int aMiddle = (aLeft + aRight) / 2;</span><br><span class="line">	int bMiddle = (bLeft + bRight) / 2;</span><br><span class="line">	if (A[aMiddle] &gt; B[bMiddle])</span><br><span class="line">	&#123;</span><br><span class="line">		if (k &lt;= (aMiddle - aLeft) + (bMiddle - bLeft) + 1)</span><br><span class="line">			FindElement(A, B, aLeft, aMiddle - 1, bLeft, bRight, k);</span><br><span class="line">		else</span><br><span class="line">			FindElement(A, B, aLeft, aRight, bMiddle + 1, bRight, k - (bMiddle - bLeft + 1));</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		if (k &lt;= ((aMiddle - aLeft) + (bMiddle - bLeft) + 1))</span><br><span class="line">			FindElement(A, B, aLeft, aRight, bLeft, bMiddle - 1, k);</span><br><span class="line">		else</span><br><span class="line">			FindElement(A, B, aMiddle + 1, aRight, bLeft, bRight, k - (aMiddle - aLeft + 1));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#Ex2.27<br>(a)</p>
<p>\begin{equation}<br>\left[<br>\begin{array}{ccc}<br>a &amp; b  \<br>d &amp; e<br>\end{array}<br>\right]<br>^2=<br>\left[<br>\begin{array}{ccc}<br>a^2+bc &amp; b(a+d)  \<br>c(a+d) &amp; bc+d^2<br>\end{array}<br>\right]<br>\end{equation}</p>
<p>b)<br>因为分治之后得到的子问题不再是平方操作了，所以该算法的运行时间不是$O(nlog25)$</p>
<p>#Ex2.31</p>
<p>算法:<br>$gcd = 2gcd(a/2,b/2)$,     若a,b都是偶数<br>     $gcd(a,b/2)$,        若a是奇数，b是偶数<br>     $gcd(|a-b|,Min(a,b))$,若a,b都是奇数 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a == 0) return b;</span><br><span class="line">    if(b == 0) return a;</span><br><span class="line">    if(a % 2 == 0 &amp;&amp; b % 2 == 0) return 2 * gcd(a/2, b/2);</span><br><span class="line">    else if(a % 2 == 0)  return gcd(a/2 , b);</span><br><span class="line">    else if(b % 2 == 0) return gcd(a, b/2);</span><br><span class="line">    else return gcd(abs(a - b), Min(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Min(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	if (a &gt;= b)</span><br><span class="line">	&#123;</span><br><span class="line">		return b;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/算法概论作业/算法概论作业2.2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/算法概论作业/算法概论作业2.2/" itemprop="url">算法概论作业2.2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法概论作业/" itemprop="url" rel="index">
                    <span itemprop="name">算法概论作业</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>#2.3</p>
<p>##(a)<br>由题解，假定对于某个常数c,有$O(n)≤cn$<br>且$T(n)=3T(n/2)+O(n)$<br>那么有</p>
<p>\begin{eqnarray<em>}<br>T(n) &amp; ≤ &amp; 3T(n/2)+cn \<br>     &amp; ≤ &amp; 3[3T(n/4)+cn/2]+cn = 9T(n/4)+3cn/2+cn \<br>     &amp; ≤ &amp; 9[3T(n/8)+cn/4]+3cn/2+cn=27T(n/8)+9cn/4+3cn/2+cn \<br>    &amp;    \ldots  &amp;<br>\end{eqnarray</em>}<br>从而，通项公式为：<br>$$T(n)≤3^kT(n/2^k)+\sum_{i=0}^{k-1} (3/2)^icn$$<br>很明显，$k=log_2n$</p>
<hr>
<p>##(b)<br>由题解，假定对于某个常数c,有$O(1)≤c$<br>且$T(n)=T(n-1)+O(1)$<br>那么有<br>\begin{eqnarray<em>}<br>T(n) &amp; ≤ &amp; T(n-1)+c \<br>     &amp; ≤ &amp; T(n-2)+2c \<br>     &amp; ≤ &amp; T(n-3)+3c \<br>    &amp;    \ldots  &amp;<br>\end{eqnarray</em>}<br>从而，通项公式为：<br>$$T(n)≤T(n-k)+kc$$<br>很明显，$k=n$<br>所以，$$T(n)=O(n)$$</p>
<hr>
<p>#2.4<br>首先，介绍求解递归式的几个方法：<br> 1 主方法<br><img src="http://static.zybuluo.com/rg070836rg/udmfr1q3yqzuq96uuu7egxwl/1.gif" alt="1.gif-28.5kB"><br> 2 替代法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">猜测解的形式。</span><br><span class="line">通过推导验证。</span><br><span class="line">解出常数。</span><br></pre></td></tr></table></figure></p>
<p> 3 递归树方法<br>4  递推法</p>
<hr>
<p>##<strong>算法A:</strong><br>$T(n)=5T(n/2)+O(n)$<br>很明显，递归式满足主定理模式，a=5，b=2，$f(n)=n$<br>$log_ba=log_25$,<br>又$∵ log_25&gt;1$,<br>$∴T(n)=O(n^{log_25})$</p>
<hr>
<p>##<strong>算法B:</strong><br>$T(n)=2T(n-1)+O(1)$<br>采用递推法，<br>\begin{eqnarray<em>}<br>T(n) &amp; ≤ &amp; 2T(n-1)+c \<br>     &amp; ≤ &amp; 2^2T(n-2)+2c \<br>     &amp; ≤ &amp; 2^3T(n-3)+3c \<br>    &amp;    \ldots  &amp;\<br>    &amp; ≤ &amp; 2^nT(1)+nc \<br>\end{eqnarray</em>}<br>所以，$T(n)=O(2^n)$</p>
<hr>
<p>##<strong>算法C:</strong><br>$T(n)=9T(n/3)+O(n^3)$<br>很明显，递归式满足主定理模式，a=9，b=3，$f(n)=n^3$<br>$log_ba=log_39=2$,<br>又$∵ n^2&lt;n^3$,<br>$T(n)=O(n^3)$</p>
<hr>
<p>当n足够大时，很明显$T_a(n)&lt;T_c(n)&lt;T_b(n)$<br>所以算法A最优。</p>
<hr>
<p>#2.5</p>
<p>a)用递推法很快可以求出<br>$$T(n) = O(n^{log_32})$$</p>
<p>b)用主方法<br>$$T(n) = O(n^{log_45})$$<br>c)用主方法<br>$$T(n) = O(nlogn)$$<br>d)用主方法<br>$$T(n) = O(n^2logn)$$<br>e)用主方法<br>$$T(n) = O(n^3logn)$$<br>f)用替代法，由于前面是$log_{25},所以我们猜测大影响在后面 $$$T(n) = O(n^{3/2} log n)$$</p>
<p>g)用递推法 $$T(n) = O(n)$$<br>h) 用递推法$$T(n) = O(n^c+1)$$<br>i) 用递推法$$T(n) = O(c^n)$$<br>j)用递推法<br>$$T(n) = O(2^n)$$<br>k)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/算法概论作业/算法概论作业2.1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/算法概论作业/算法概论作业2.1/" itemprop="url">算法概论作业2.1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法概论作业/" itemprop="url" rel="index">
                    <span itemprop="name">算法概论作业</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>##2.14<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个含有n个元素的数组，注意到数组中的某些元素是重复的，即这些元素在数组中出现不止一次。给出一种算法，以O（nlogn）时间移除掉数组中的所有重复元素。</span><br></pre></td></tr></table></figure></p>
<p>###思路1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先采用nlogn级别的排序算法，再线性扫描，得到结果。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package homework_chen;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文 件 名 : test214.java </span><br><span class="line"> * 创 建 人： chen19130216 </span><br><span class="line"> * 日 期： 2015年9月21日 </span><br><span class="line"> * 描 述： 算法概论2.14题目源码</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class test214 &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param args</span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		int[] r = &#123; 8, 6, 8, 0, 4, 2, 6, 8, 3, 2, 6, 2, 1, 2, 5, 8, 0, 6, 3, 1,</span><br><span class="line">				2, 3, 5, 7, 9, 5, 8, 4, 8, 5, 7, 5, 6, 6, 3, 5, &#125;;</span><br><span class="line">		System.out.println(&quot;排序前：&quot;);</span><br><span class="line">		printarray(r);</span><br><span class="line">		System.out.println(&quot;\n排序后&quot;);</span><br><span class="line">		Merge_sort(r, 0, r.length - 1);</span><br><span class="line">		printarray(r);</span><br><span class="line">		removerepeat(r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void printarray(int[] r) &#123;</span><br><span class="line">		for (int key : r)</span><br><span class="line">			System.out.print(key + &quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param int []r 要求在线性时间内删除有序序列的重复元素</span><br><span class="line">	 */</span><br><span class="line">	public static void removerepeat(int[] r) &#123;</span><br><span class="line">		int[] tmp = new int[r.length];// 大小定义比较麻烦？不知道怎么定义大小？C++可以通过传递数组长度来约束，难道java也需要么？</span><br><span class="line">		int k = 0;</span><br><span class="line">		int t = Integer.MIN_VALUE;</span><br><span class="line">		for (int i = 0; i &lt; r.length; i++) &#123;// 当不一样就加进去，前提是有序序列</span><br><span class="line">			if (r[i] != t) &#123;</span><br><span class="line">				tmp[k++] = r[i];</span><br><span class="line">				t = r[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;\n删除后：&quot;);// 输出结果，有必要可以在重建大小为k的数组，重新赋值并传出去</span><br><span class="line">		for (int i = 0; i &lt; k; i++)</span><br><span class="line">			System.out.print(tmp[i] + &quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param int []r int start int mid int end 合并两段有序数组</span><br><span class="line">	 * 在调用时开辟新空间，归并，最后赋值回来，java自带gc，无须回收</span><br><span class="line">	 */</span><br><span class="line">	public static void merge(int[] r, int start, int mid, int end) &#123;</span><br><span class="line">		int[] tmp = new int[end - start + 1];// 创建临时空间</span><br><span class="line">		int k1 = start;// 记录第一有序序列的起始位置，</span><br><span class="line">		int k2 = mid + 1;// 记录第一有序序列的起始位置，</span><br><span class="line">		int k3 = 0;// 定义临时空间的起始位置</span><br><span class="line">		while (k1 &lt;= mid &amp;&amp; k2 &lt;= end) &#123;// 当序列未到结尾时，归并</span><br><span class="line">			if (r[k1] &lt;= r[k2])// 若果第一个序列的值小于等于第二个，则把其存进临时数组</span><br><span class="line">				tmp[k3++] = r[k1++];</span><br><span class="line">			else</span><br><span class="line">				tmp[k3++] = r[k2++];</span><br><span class="line">		&#125;</span><br><span class="line">		// 当不满足while条件时，退出循环，此时将剩下的附在后面</span><br><span class="line">		while (k1 &lt;= mid)</span><br><span class="line">			tmp[k3++] = r[k1++];</span><br><span class="line">		while (k2 &lt;= end)</span><br><span class="line">			tmp[k3++] = r[k2++];</span><br><span class="line">		// 全部完毕之后，将tmp回写到r数组中</span><br><span class="line">		for (int i = 0; i &lt; tmp.length; i++) &#123;</span><br><span class="line">			r[start++] = tmp[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param int []r int start int end 归并排序数组 当start &lt; end 分割 分割完毕之后，相邻的合并</span><br><span class="line">	 */</span><br><span class="line">	public static void Merge_sort(int[] r, int start, int end) &#123;</span><br><span class="line">		if (start &lt; end) &#123;</span><br><span class="line">			int mid = (start + end) / 2;</span><br><span class="line">			Merge_sort(r, start, mid);</span><br><span class="line">			Merge_sort(r, mid + 1, end);</span><br><span class="line">			merge(r, start, mid, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###思路2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线性下找到数组的最大值，最小值，若相差距离可以接受，则此方法效率不错。然后建立hash数组，扫描r数组，若flag位置的值为false，则改为true，否则不变，最后再顺序扫描一遍hash数组，输出结果。</span><br><span class="line">此方法为O（n）线性级别，不符合题目的要求，但优于题目的要求。</span><br><span class="line">但适用条件为密集数组，若前后跨距太大，则得不偿失</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package homework_chen;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文 件 名 : test214.java </span><br><span class="line"> * 创 建 人： chen19130216 </span><br><span class="line"> * 日 期： 2015年9月22日 </span><br><span class="line"> * 描 述： 算法概论2.14题目源码new</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class test214new &#123;</span><br><span class="line">	private static int max = Integer.MAX_VALUE;</span><br><span class="line">	private static int min = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param args</span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		int[] r = &#123; 8, 6,  8, 0, 4, 2, 6, 8, 3, 2, 6, 2, 1, 2, 5, 8,</span><br><span class="line">				0, 6, 3, 1, 2, 3, 5, 7, 9, 5, 8, 4, 8, 5, 7, 5, 6, 6, 3, 5, &#125;;</span><br><span class="line">		fd_max_min(r);</span><br><span class="line">		removerepeat(r, max, min);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param int []r 找出r数组中的最大值，最小值，并赋值给全局变量</span><br><span class="line">	 */</span><br><span class="line">	public static void fd_max_min(int[] r) &#123;</span><br><span class="line">		for (int i = 0; i &lt; r.length; i++) &#123;</span><br><span class="line">			if (r[i] &gt; min)</span><br><span class="line">				min = r[i];</span><br><span class="line">			if (r[i] &lt; max)</span><br><span class="line">				max = r[i];</span><br><span class="line">		&#125;</span><br><span class="line">		int t = min;</span><br><span class="line">		min = max;</span><br><span class="line">		max = t;// 交换</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param int []r 打印数组</span><br><span class="line">	 */</span><br><span class="line">	public static void printarray(int[] r) &#123;</span><br><span class="line">		for (int key : r)</span><br><span class="line">			System.out.print(key + &quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * </span><br><span class="line">	 * @param r</span><br><span class="line">	 * @param max</span><br><span class="line">	 * @param min</span><br><span class="line">	 * 用hash数组判定是否存在</span><br><span class="line">	 */</span><br><span class="line">	public static void removerepeat(int[] r, int max, int min) &#123;</span><br><span class="line">		int number = max - min + 1;</span><br><span class="line">		boolean[] flag = new boolean[number];// 初始化为false</span><br><span class="line">		for (int i = 0; i &lt; r.length; i++) &#123;</span><br><span class="line">			int t = r[i] - min;</span><br><span class="line">			if (flag[t] == false) &#123;</span><br><span class="line">				flag[t] = true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = 0; i &lt; flag.length; i++) &#123;</span><br><span class="line">			if (flag[i] == true) &#123;</span><br><span class="line">				System.out.print((i + min)+&quot; &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##2.16<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个无穷数组A[·]，其中前N个元素都是整数，且已排好序，剩余元素均为∞。n的值未知.给出一个算法，以一个整数x为输入，以O(logn)时间找到数组中的一个位置，并满足其上的元素为x.</span><br></pre></td></tr></table></figure></p>
<p>###思路：</p>
<p>从a[1]开始，依次访问a[2],a[4],a[8],依次类推，访问至a[$2^i$]，发现a[$2^i$<em>2]为∞，这个花费的时间代价为O(logn)<br>设k小于i+1,   x必定在a[$2^k$]至a[$2^k$</em>2]之间<br>对这个区间进行二分搜索，定位即可，若搜索到，返回位置，若搜索不到，返回-1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package homework_chen;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文 件 名 : test216.java </span><br><span class="line"> * 创 建 人： chen19130216 </span><br><span class="line"> * 日 期： 2015年9月22日 </span><br><span class="line"> * 描 述： 算法概论2.16题目源码</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class test216 &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param args</span><br><span class="line">	 * 从a[1]开始，依次访问a[2],a[4],a[8], 依次类推，访问至a[2^i]，发现a[2^(i+1)]为∞，</span><br><span class="line">	 * 这个花费的时间代价为O(logn) 设k小于i+1, x必定在a[2^k]至a[2^(k+1)]之间</span><br><span class="line">	 * 对这个区间进行二分搜索， 定位即可，若搜索到，返回位置，若搜索不到，返回-1.</span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		int[] r = &#123; 1, 2, 5, 9, 11, 15, 17, 19, 23, 27, 29, 32, 37, 41, 45, 49,</span><br><span class="line">				54, 57, 59 &#125;;</span><br><span class="line">		int x = 60;</span><br><span class="line"></span><br><span class="line">		int index = solution(r, x);</span><br><span class="line">		System.out.println(&quot;index:&quot; + index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param r </span><br><span class="line">	 * @param x  </span><br><span class="line">	 * @return index 存在返回下标，不存在返回-1</span><br><span class="line">	 */</span><br><span class="line">	private static int solution(int[] r, int x) &#123;</span><br><span class="line">		int left = 1;</span><br><span class="line">		int right = 1;</span><br><span class="line">		// 定位x的位置</span><br><span class="line">		try &#123;</span><br><span class="line">			while (r[left] &lt; x) &#123;// 当x大于左界值，left翻倍</span><br><span class="line">				left *= 2;</span><br><span class="line">			&#125;// 此时，数组未越界，将其作为右边界</span><br><span class="line">		&#125; catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line"></span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			right = left;// 此时left已经越界，将其作为右边界</span><br><span class="line">			left = right / 2;</span><br><span class="line">			System.out.println(left + &quot; &quot; + right);</span><br><span class="line">		&#125;</span><br><span class="line">		int index = binSearch(r, left, right, x);</span><br><span class="line">		return index;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param r</span><br><span class="line">	 * @param left</span><br><span class="line">	 * @param right</span><br><span class="line">	 * @param x</span><br><span class="line">	 * @return</span><br><span class="line">	 * 二分查找,存在返回index，不存在返回-1</span><br><span class="line">	 */</span><br><span class="line">	private static int binSearch(int[] r, int left, int right, int x) &#123;</span><br><span class="line">		while (left &lt;= right) &#123;</span><br><span class="line">			int mid = (left + right) / 2;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (x &lt; r[mid]) &#123;</span><br><span class="line">					right = mid - 1;</span><br><span class="line">				&#125; else if (x &gt; r[mid]) &#123;</span><br><span class="line">					left = mid + 1;</span><br><span class="line">				&#125; else if (x == r[mid]) &#123;</span><br><span class="line">					return mid;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">				right = mid - 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##2.23<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一个数组A[1,...,n]中总数超过半数的元素都相同时，该数组被称为含有一个主元素，给定一个数组，设计一个有效算法，确定该数组中是否含有一个主元素，如果有，找出这个元素。需注意的是，该数组的元素之间可能不存在顺序——即不能进行”A[i]&lt;A[j]”的判断，但是可以进行是否相等的判断。</span><br></pre></td></tr></table></figure></p>
<p>###思路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">整体采用分治法</span><br><span class="line">当分到只有一个元素时，必定是主元素</span><br><span class="line">对于连续的两段，取得左半边的主元素，取得右半边的主元素</span><br><span class="line">如果左右两边一样，必定为主元素</span><br><span class="line">否则线性扫描，统计次数，找到主元素，若没有返回null</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package homework_chen;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文 件 名 : test223a.java </span><br><span class="line"> * 创 建 人： chen19130216 </span><br><span class="line"> * 日 期： 2015年9月22日 </span><br><span class="line"> * 描 述： 算法概论2.23题目源码</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class test223a &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param args</span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		int[] r = &#123; 1, 1, 2, 2, 2, 3, 3, 3 &#125;;</span><br><span class="line">		Integer majority = getmajority(r, 0, r.length - 1);</span><br><span class="line">		System.out.println(&quot;主元素为:&quot; + majority);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 求数组的主元素</span><br><span class="line">	 * @param r</span><br><span class="line">	 * @param start</span><br><span class="line">	 * @param end</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	private static Integer getmajority(int[] r, int start, int end) &#123;</span><br><span class="line"></span><br><span class="line">		if (start == end) &#123;// 只有一个元素时，必定是主元素</span><br><span class="line">			return r[start];</span><br><span class="line">		&#125;</span><br><span class="line">		int mid = (start + end) / 2;</span><br><span class="line">		Integer majority0 = getmajority(r, start, mid);// 取得左半边的主元素</span><br><span class="line">		Integer majority1 = getmajority(r, mid + 1, end);// 取得右半边的主元素</span><br><span class="line">		if (majority0 == majority1) &#123;// 如果左右两边一样，必定为主元素</span><br><span class="line">			return majority0;</span><br><span class="line">		&#125;</span><br><span class="line">		Integer majority = traverseAndFind(r, majority0, majority1, start, end);// 综合两边主元素判定综合主元素</span><br><span class="line">		return majority;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 本方法用于返回相邻两段的主元素，若不存在，返回null</span><br><span class="line">	 * @param r</span><br><span class="line">	 * @param majority0</span><br><span class="line">	 * @param majority1</span><br><span class="line">	 * @param start</span><br><span class="line">	 * @param end</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	private static Integer traverseAndFind(int[] r, Integer majority0,</span><br><span class="line">			Integer majority1, int start, int end) &#123;</span><br><span class="line">		int halfRate = (end - start + 1) / 2;//测定程序中的半数</span><br><span class="line">		int fre0 = 0;//统计次数1</span><br><span class="line">		int fre1 = 0;//统计次数2</span><br><span class="line">		for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">			if (majority0 != null &amp;&amp; r[i] == majority0)</span><br><span class="line">				fre0++;</span><br><span class="line">			if (majority1 != null &amp;&amp; r[i] == majority1)</span><br><span class="line">				fre1++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (fre0 &gt; halfRate)//超过半数，满足主元素条件返回</span><br><span class="line">			return majority0;</span><br><span class="line">		if (fre1 &gt; halfRate)</span><br><span class="line">			return majority1;</span><br><span class="line">		return null;//无主元素，返回空指针</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/算法概论作业/算法作业合集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/算法概论作业/算法作业合集/" itemprop="url">算法作业合集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法概论作业/" itemprop="url" rel="index">
                    <span itemprop="name">算法概论作业</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>[TOC]</p>
<hr>
<p>##第二章</p>
<p>###2.14<br><img src="http://static.zybuluo.com/rg070836rg/1pyo482sfzkn9709uigfe94c/2.14.png" alt="2.14.png-262.3kB"></p>
<p>###2.16<br><img src="http://static.zybuluo.com/rg070836rg/9boba3mga51relqw6zan5d13/2.16.png" alt="2.16.png-565.4kB"></p>
<p>###2.23<br><img src="http://static.zybuluo.com/rg070836rg/w8g4n0l6bb05qg7vv8hn2kti/2.23.1.png" alt="2.23.1.png-469.8kB"><br><img src="http://static.zybuluo.com/rg070836rg/3sm1iy9svh3haqx8yf36lv59/2.23.2.png" alt="2.23.2.png-95.9kB"></p>
<p>###2.5<br><img src="http://static.zybuluo.com/rg070836rg/nlvervkbiajbhk15cue0trsa/2.5.png" alt="2.5.png-59.3kB"></p>
<p>###2.22<br><img src="http://static.zybuluo.com/rg070836rg/jzfrbwxet9aws0qniemzsbe6/2.22.png" alt="2.22.png-243.3kB"></p>
<p>###2.31<br><img src="http://static.zybuluo.com/rg070836rg/7f9o72dt26860rjrcwiqyon2/2.31.png" alt="2.31.png-374kB"></p>
<p>###2.15<br><img src="http://static.zybuluo.com/rg070836rg/qtz6kmzh28y6sr2kqcmcqjmx/2.15.png" alt="2.15.png-316.6kB"></p>
<p>###2.19<br><img src="http://static.zybuluo.com/rg070836rg/t5uhoubyl18kr0dcbkyvmjlh/2.19.png" alt="2.19.png-889.3kB"></p>
<hr>
<p>##第六章</p>
<p>###6.1<br><img src="http://static.zybuluo.com/rg070836rg/polmoil0lhe0bnbd0nt3tpu2/6.1.png" alt="6.1.png-712.8kB"></p>
<p>###6.2<br><img src="http://static.zybuluo.com/rg070836rg/1zjn73nlskegzsg28yen9ifn/6.2.png" alt="6.2.png-605kB"></p>
<p>###6.3<br><img src="http://static.zybuluo.com/rg070836rg/j5t6kuspgfrm4so9vkjicagu/6.3.png" alt="6.3.png-738.1kB"></p>
<p>###6.4<br><img src="http://static.zybuluo.com/rg070836rg/8cxnbzii4suei1sb3ph73cbj/6.4.png" alt="6.4.png-657.4kB"></p>
<p>###6.20<br><img src="http://static.zybuluo.com/rg070836rg/watkcdgw4rbs4wh2dx7tw2he/6.20.png" alt="6.20.png-318.1kB"></p>
<p>###6.26<br><img src="http://static.zybuluo.com/rg070836rg/ffprr0jlp4a89n1bn5mallbs/6.26.png" alt="6.26.png-375.7kB"></p>
<p>###6.17<br><img src="http://static.zybuluo.com/rg070836rg/9thr71qhwigei8dln1mtrz72/6.17.png" alt="6.17.png-624.6kB"></p>
<p>###6.18<br><img src="http://static.zybuluo.com/rg070836rg/v8rhw7epur65w0wnxv3fbvvc/6.18.png" alt="6.18.png-789.8kB"></p>
<p>###6.23<br><img src="http://static.zybuluo.com/rg070836rg/hqplnsulsewhhu3hmga2mmn3/6.23.png" alt="6.23.png-575.1kB"></p>
<p>###6.19<br><img src="http://static.zybuluo.com/rg070836rg/troigi0dm9bg0iy6tdcl2orp/6.19.png" alt="6.19.png-723.6kB"></p>
<p>###6.21<br><img src="http://static.zybuluo.com/rg070836rg/lz44uqmgj4h4qcrualmzjzbd/6.21.png" alt="6.21.png-637kB"></p>
<p>###6.14<br><img src="http://static.zybuluo.com/rg070836rg/91r9dy2op1eg2w2miyeljtt4/6.14.png" alt="6.14.png-652.1kB"></p>
<hr>
<p>##第五章</p>
<p>###5.32<br><img src="http://static.zybuluo.com/rg070836rg/z8p4te8uxj671vn0dhegeg6k/5.32.png" alt="5.32.png-570.4kB"></p>
<p>###5.26<br><img src="http://static.zybuluo.com/rg070836rg/vdvw12wrlgz1vn0d9dni2k57/5.26.png" alt="5.26.png-777.9kB"></p>
<p>###5.28<br><img src="http://static.zybuluo.com/rg070836rg/cqh2ovd936b3yd2ypljclllq/5.28.png" alt="5.28.png-407.1kB"></p>
<p>###5.33<br><img src="http://static.zybuluo.com/rg070836rg/qcwsnojcmtr7yuezf1e8dh5p/5.33.png" alt="5.33.png-761.5kB"></p>
<hr>
<p>##第三章</p>
<p>###3.15<br><img src="http://static.zybuluo.com/rg070836rg/ffhvj3q3mwod31cpqfv33agx/3.15.png" alt="3.15.png-553.7kB"></p>
<p>###3.17<br><img src="http://static.zybuluo.com/rg070836rg/qxmdi8btiifuuho6dngcm7xq/3.17.png" alt="3.17.png-597.6kB"></p>
<p>###3.25<br><img src="http://static.zybuluo.com/rg070836rg/xuw5ngyd6za9tah6b7wvvc73/3.25.png" alt="3.25.png-214.8kB"></p>
<p>###3.28<br><img src="http://static.zybuluo.com/rg070836rg/r341w58d1ctftzcfr7adjkck/3.28.1.png" alt="3.28.1.png-394.6kB"><img src="http://static.zybuluo.com/rg070836rg/hze6cpok1be7irmf65lp4f7z/3.28.2.png" alt="3.28.2.png-178kB"></p>
<hr>
<p>##第四章</p>
<p>###4.10<br><img src="http://static.zybuluo.com/rg070836rg/p3glvgix1u02pxvpq2w03fb7/4.10.png" alt="4.10.png-54.7kB"></p>
<p>###4.21<br><img src="http://static.zybuluo.com/rg070836rg/idtk5app2ep7x4mice6th8ix/4.21.png" alt="4.21.png-471.2kB"></p>
<hr>
<p>##第七章</p>
<p>###7.17<br><img src="http://static.zybuluo.com/rg070836rg/uibr6wxuipcfwzfljxjalxc9/7.17.1.png" alt="7.17.1.png-631.1kB"><br><img src="http://static.zybuluo.com/rg070836rg/3onamq3tomjmhg2rxfhzeegp/7.17.2.png" alt="7.17.2.png-755.4kB"></p>
<p>###7.21<br><img src="http://static.zybuluo.com/rg070836rg/icave91l1jbxtbgrxpcs7h6n/7.21.png" alt="7.21.png-79.3kB"></p>
<p>###7.31<br><img src="http://static.zybuluo.com/rg070836rg/522nmu3zfooz6deva78kahuo/7.31.png" alt="7.31.png-305.1kB"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/算法概论实验/算法概论实验四/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/算法概论实验/算法概论实验四/" itemprop="url">算法概论实验四</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法概论实验/" itemprop="url" rel="index">
                    <span itemprop="name">算法概论实验</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">实验四</span><br><span class="line"></span><br><span class="line">实验目的与要求：掌握动态规划方法的基本思想与设计策略。</span><br><span class="line">1．多段图中的最短路径问题</span><br><span class="line">【问题描述】</span><br><span class="line">建立一个从源点S到终点T的多段图，设计一个动态规划算法求出从S到T的最短路径值，并输出相应的最短路径。</span><br><span class="line">2．有向无环图中的最短路径问题</span><br><span class="line">【问题描述】</span><br><span class="line">建立一个从源点S到终点E的有向无环图，设计一个动态规划算法求出从S到E的最短路径值，并输出相应的最短路径。</span><br></pre></td></tr></table></figure>
<p>#1．多段图中的最短路径问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int  dp[1222222],alone[1222222],a[1222222];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,n,m;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">		memset(dp,0,sizeof(dp));</span><br><span class="line">		memset(alone ,0,sizeof(alone));</span><br><span class="line">        for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        int tmax;         </span><br><span class="line">        for(i=1;i&lt;=m;i++)//★分i段</span><br><span class="line">        &#123;</span><br><span class="line">            tmax=-(1&lt;&lt;30);</span><br><span class="line">		</span><br><span class="line">            for(j=i;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]=_cpp_max(dp[j-1],alone[j-1])+a[j];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(&quot;%2d %2d %2d\n&quot;,a[j],alone[j-1],dp[j]);</span><br><span class="line">                if(j&gt;i)alone[j-1]=tmax;</span><br><span class="line"></span><br><span class="line">                if(tmax&lt;dp[j])tmax=dp[j];</span><br><span class="line">	</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,tmax);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#2．有向无环图中的最短路径问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Init_Graph(int N,int **S)</span><br><span class="line">&#123;</span><br><span class="line">	int i,j;</span><br><span class="line">	cout&lt;&lt;&quot;输入边的长度：输入1 2 4 表示点1 与 2的边的长度为 4：首数字为0表示结束输入&quot;&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;i;</span><br><span class="line">	while(i!=0)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;j;</span><br><span class="line">		cin&gt;&gt;S[i][j];</span><br><span class="line">		cin&gt;&gt;i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DP(int N,int **S,int *dist,int *from)</span><br><span class="line">&#123;</span><br><span class="line">	int i,j;</span><br><span class="line">	for(j=0;j&lt;N+1;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(S[1][j]&lt;INT_MAX)</span><br><span class="line">		&#123;</span><br><span class="line">			dist[j]=S[1][j];</span><br><span class="line">			from[j]=1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(j=2;j&lt;N+1;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(i=2;i&lt;j;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(S[i][j]&lt;INT_MAX)</span><br><span class="line">			&#123;</span><br><span class="line">				if(dist[i]+S[i][j]&lt;dist[j])</span><br><span class="line">				&#123;</span><br><span class="line">					dist[j]=dist[i]+S[i][j];</span><br><span class="line">					from[j]=i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;最短路径为：&quot;;</span><br><span class="line">	i=6;</span><br><span class="line">	cout&lt;&lt;N&lt;&lt;&quot;  &quot;&lt;&lt;from[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">	i=from[i];</span><br><span class="line">	while(i!=1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;from[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">		i=from[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;最短距离为：&quot;&lt;&lt;dist[N]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int N;</span><br><span class="line">	int **S,*dist,*from;</span><br><span class="line">	int i,j;</span><br><span class="line">	cout&lt;&lt;&quot;输入点的个数：&quot;;  </span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line"></span><br><span class="line">	S=new int*[N+1];</span><br><span class="line">	for(i=0;i&lt;N+1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		S[i]=new int[N+1];</span><br><span class="line">		for(j=0;j&lt;N+1;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			S[i][j]=INT_MAX;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dist=new int[N+1];</span><br><span class="line">	for(i=0;i&lt;N+1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dist[i]=INT_MAX;</span><br><span class="line">	&#125;</span><br><span class="line">    from=new int[N+1];</span><br><span class="line">	for(i=0;i&lt;N+1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		from[i]=0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Init_Graph(N,S);</span><br><span class="line">	DP(N,S,dist,from);</span><br><span class="line"></span><br><span class="line">	for(i=0;i&lt;N+1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		delete []S[i];</span><br><span class="line">	&#125;</span><br><span class="line">	delete []S;</span><br><span class="line">	delete []dist;</span><br><span class="line">	delete []from;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/算法概论实验/算法概论实验十二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/算法概论实验/算法概论实验十二/" itemprop="url">算法概论实验十二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法概论实验/" itemprop="url" rel="index">
                    <span itemprop="name">算法概论实验</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">实验十二</span><br><span class="line"></span><br><span class="line">实验目的与要求：</span><br><span class="line">（1）	理解与掌握求解最大流与最小割的基本算法。</span><br><span class="line">（2）	学会应用最大流与最小割算法解决实际问题。</span><br><span class="line"></span><br><span class="line">1．实现Ford-Fulkerson算法，求出给定图中从源点s到汇点t的最大流，并输出最小割。</span><br><span class="line"></span><br><span class="line">2. 设计与实现二部图匹配（Bipartite Matching）问题的算法。</span><br></pre></td></tr></table></figure>
<p>#1．Ford-Fulkerson算法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">//void *memset(void *s,int c,size_t n)将已开辟内存空间 s 的首 n 个字节的值设为值 c</span><br><span class="line">//#include &lt;Ford_Fulkerson&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INFI 1000</span><br><span class="line">typedef struct _mark</span><br><span class="line">&#123;</span><br><span class="line">	int pre_suc;</span><br><span class="line">	int max_incr;</span><br><span class="line">&#125;MARK;</span><br><span class="line"></span><br><span class="line">int iteration = 0;//增光路径数目</span><br><span class="line">const int N = 100;</span><br><span class="line">list&lt;int&gt; setS;</span><br><span class="line">bool isMark[N], isCheck[N], isDone;</span><br><span class="line">MARK markList[N];</span><br><span class="line">int c[N][N], f[N][N];</span><br><span class="line">int n; //顶点数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int Maxflow()</span><br><span class="line">&#123;</span><br><span class="line">	int flow = 0;</span><br><span class="line">	for (int i = 0; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		flow += f[0][i];</span><br><span class="line">	&#125;</span><br><span class="line">	return flow;</span><br><span class="line">&#125;</span><br><span class="line">void Mincut()//isMark的点就是最小割</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	while (i&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		if (isMark[i])</span><br><span class="line">			setS.push_back(i);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int IncrFlowAuxi(int index)//计算增广路径中的最大可增量</span><br><span class="line">&#123;</span><br><span class="line">	if (index == 0)</span><br><span class="line">		return markList[index].max_incr;</span><br><span class="line"></span><br><span class="line">	int prev = markList[index].pre_suc;</span><br><span class="line">	int maxIncr = markList[index].max_incr;</span><br><span class="line">	return min(maxIncr, IncrFlowAuxi(prev));//递归求瓶颈值为最大增量</span><br><span class="line">&#125;</span><br><span class="line">void IncrFlow()//增广路径的增加</span><br><span class="line">&#123;</span><br><span class="line">	iteration++;</span><br><span class="line">	int incr = IncrFlowAuxi(n - 1); //最大可增量</span><br><span class="line">	int index = n - 1;</span><br><span class="line">	int prev;</span><br><span class="line">	while (index != 0)</span><br><span class="line">	&#123;</span><br><span class="line">		prev = markList[index].pre_suc;</span><br><span class="line">		f[prev][index] += incr; //增广路径增加后，相应的流量进行更新</span><br><span class="line">		index = prev;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Mark(int index, int pre_suc, int max_incr)//被标记表示可能被纳入新路径</span><br><span class="line">&#123;</span><br><span class="line">	isMark[index] = true;</span><br><span class="line"></span><br><span class="line">	markList[index].pre_suc = pre_suc;//前驱</span><br><span class="line">	markList[index].max_incr = max_incr;//当前路径的流值</span><br><span class="line">&#125;</span><br><span class="line">void Check(int i)//被mark且被check的点表示已经被纳入新路径</span><br><span class="line">&#123;</span><br><span class="line">	isCheck[i] = true;</span><br><span class="line"></span><br><span class="line">	for (int j = 0; j&lt;n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (c[i][j]&gt;0 &amp;&amp; !isMark[j] &amp;&amp; c[i][j]&gt;f[i][j])//forward 边</span><br><span class="line">			Mark(j, i, min(markList[i].max_incr, c[i][j] - f[i][j]));</span><br><span class="line">		if (c[j][i]&gt;0 &amp;&amp; !isMark[j] &amp;&amp; f[j][i]&gt;0)//reverse 边</span><br><span class="line">			Mark(j, i, min(markList[i].max_incr, f[j][i]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ford_fulkerson算法</span><br><span class="line">int ford_fulkerson()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line">	while (1)//一次循环找到一个新路径</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		isDone = true;</span><br><span class="line">		i = 0;</span><br><span class="line">		while (i&lt;n)//一次循环判断上次循环是否有找到新路径，若无则表明没有新路径，终止算法</span><br><span class="line">		&#123;</span><br><span class="line">			if (isMark[i] &amp;&amp; !isCheck[i])  //判断是否所有标记的点都已被检查：若是，结束整个算法</span><br><span class="line">			&#123;</span><br><span class="line">				isDone = false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (isDone) //算法结束，则计算最小割和最大流</span><br><span class="line">		&#123;</span><br><span class="line">			Mincut();</span><br><span class="line">			return Maxflow();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		while (i&lt;n)//贪心法构建新路径</span><br><span class="line">		&#123;</span><br><span class="line">			if (isMark[i] &amp;&amp; !isCheck[i]) &#123;</span><br><span class="line">				Check(i);</span><br><span class="line">				i = 0;</span><br><span class="line">			&#125;</span><br><span class="line">			if (isMark[n - 1]) //如果汇t被标记，说明找到了一条增广路径，则增加该条路径的最大可增加量</span><br><span class="line">			&#123;</span><br><span class="line">				IncrFlow();</span><br><span class="line">				memset(isMark + 1, false, n - 1); //增加该增广路径后，除了源s，其余标记抹去</span><br><span class="line">				memset(isCheck, false, n);</span><br><span class="line">			&#125;</span><br><span class="line">			else i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	测试值：ppt上的例子</span><br><span class="line">	0  20 10 0</span><br><span class="line">	0  0  30 10</span><br><span class="line">	0  0  0  20</span><br><span class="line">	0  0  0  0</span><br><span class="line">	*/</span><br><span class="line">	n = 4;</span><br><span class="line">	for (int k = 0; k &lt; n; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(c[k], 0, sizeof(c[0][0])*n);</span><br><span class="line">		memset(f[k], 0, sizeof(f[0][0])*n);  //初始各分支流量为0</span><br><span class="line">		memset(isMark, false, n);</span><br><span class="line">		memset(isCheck, false, n);</span><br><span class="line">	&#125;</span><br><span class="line">	isMark[0] = true; //给源做永久标记</span><br><span class="line">	markList[0].max_incr = INFI;</span><br><span class="line">	markList[0].pre_suc = INFI;</span><br><span class="line"></span><br><span class="line">	c[0][1] = 20;</span><br><span class="line">	c[0][2] = 10;</span><br><span class="line">	c[1][2] = 30;</span><br><span class="line">	c[1][3] = 10;</span><br><span class="line">	c[2][3] = 20;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;最大流为：&quot; &lt;&lt; ford_fulkerson() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;最大割的S集合为：&#123;&quot;;</span><br><span class="line">	for (list&lt;int&gt;::iterator i = setS.begin(); i != setS.end(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d  &quot;, *i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;&#125;&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;增广路径个数为：&quot; &lt;&lt; iteration &lt;&lt; endl;</span><br><span class="line">	system(&quot;PAUSE&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#2. 二部图匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">//void *memset(void *s,int c,size_t n)将已开辟内存空间 s 的首 n 个字节的值设为值 c</span><br><span class="line">//#include &lt;Ford_Fulkerson&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define INFI 1000</span><br><span class="line">typedef struct _mark</span><br><span class="line">&#123;</span><br><span class="line">	int pre_suc;</span><br><span class="line">	int max_incr;</span><br><span class="line">&#125;MARK;</span><br><span class="line"></span><br><span class="line">int iteration = 0;//增光路径数目</span><br><span class="line">const int N = 100;</span><br><span class="line">list&lt;int&gt; setS;</span><br><span class="line">bool isMark[N], isCheck[N], isDone;</span><br><span class="line">MARK markList[N];</span><br><span class="line">int c[N][N], f[N][N];</span><br><span class="line">int n; //顶点数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int Maxflow()</span><br><span class="line">&#123;</span><br><span class="line">	int flow = 0;</span><br><span class="line">	for (int i = 0; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		flow += f[0][i];</span><br><span class="line">	&#125;</span><br><span class="line">	return flow;</span><br><span class="line">&#125;</span><br><span class="line">void Mincut()//isMark的点就是最小割</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	while (i&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		if (isMark[i])</span><br><span class="line">			setS.push_back(i);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int IncrFlowAuxi(int index)//计算增广路径中的最大可增量</span><br><span class="line">&#123;</span><br><span class="line">	if (index == 0)</span><br><span class="line">		return markList[index].max_incr;</span><br><span class="line"></span><br><span class="line">	int prev = markList[index].pre_suc;</span><br><span class="line">	int maxIncr = markList[index].max_incr;</span><br><span class="line">	return min(maxIncr, IncrFlowAuxi(prev));//递归求瓶颈值为最大增量</span><br><span class="line">&#125;</span><br><span class="line">void IncrFlow()//增广路径的增加</span><br><span class="line">&#123;</span><br><span class="line">	iteration++;</span><br><span class="line">	int incr = IncrFlowAuxi(n - 1); //最大可增量</span><br><span class="line">	int index = n - 1;</span><br><span class="line">	int prev;</span><br><span class="line">	while (index != 0)</span><br><span class="line">	&#123;</span><br><span class="line">		if (index != n - 1)</span><br><span class="line">			cout &lt;&lt; index &lt;&lt; &quot; &quot;;</span><br><span class="line">		prev = markList[index].pre_suc;</span><br><span class="line">		f[prev][index] += incr; //增广路径增加后，相应的流量进行更新</span><br><span class="line">		index = prev;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Mark(int index, int pre_suc, int max_incr)//被标记表示可能被纳入新路径</span><br><span class="line">&#123;</span><br><span class="line">	isMark[index] = true;</span><br><span class="line"></span><br><span class="line">	markList[index].pre_suc = pre_suc;//前驱</span><br><span class="line">	markList[index].max_incr = max_incr;//当前路径的流值</span><br><span class="line">&#125;</span><br><span class="line">void Check(int i)//被mark且被check的点表示已经被纳入新路径</span><br><span class="line">&#123;</span><br><span class="line">	isCheck[i] = true;</span><br><span class="line"></span><br><span class="line">	for (int j = 0; j&lt;n; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (c[i][j]&gt;0 &amp;&amp; !isMark[j] &amp;&amp; c[i][j]&gt;f[i][j])//forward 边</span><br><span class="line">			Mark(j, i, min(markList[i].max_incr, c[i][j] - f[i][j]));</span><br><span class="line">		if (c[j][i]&gt;0 &amp;&amp; !isMark[j] &amp;&amp; f[j][i]&gt;0)//reverse 边</span><br><span class="line">			Mark(j, i, min(markList[i].max_incr, f[j][i]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ford_fulkerson算法</span><br><span class="line">int ford_fulkerson()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line">	while (1)//一次循环找到一个新路径</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		isDone = true;</span><br><span class="line">		i = 0;</span><br><span class="line">		while (i&lt;n)//一次循环判断上次循环是否有找到新路径，若无则表明没有新路径，终止算法</span><br><span class="line">		&#123;</span><br><span class="line">			if (isMark[i] &amp;&amp; !isCheck[i])  //判断是否所有标记的点都已被检查：若是，结束整个算法</span><br><span class="line">			&#123;</span><br><span class="line">				isDone = false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (isDone) //算法结束，则计算最小割和最大流</span><br><span class="line">		&#123;</span><br><span class="line">			Mincut();</span><br><span class="line">			return Maxflow();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		while (i&lt;n)//贪心法构建新路径</span><br><span class="line">		&#123;</span><br><span class="line">			if (isMark[i] &amp;&amp; !isCheck[i]) &#123;</span><br><span class="line">				Check(i);</span><br><span class="line">				i = 0;</span><br><span class="line">			&#125;</span><br><span class="line">			if (isMark[n - 1]) //如果汇t被标记，说明找到了一条增广路径，则增加该条路径的最大可增加量</span><br><span class="line">			&#123;</span><br><span class="line">				IncrFlow();</span><br><span class="line">				memset(isMark + 1, false, n - 1); //增加该增广路径后，除了源s，其余标记抹去</span><br><span class="line">				memset(isCheck, false, n);</span><br><span class="line">			&#125;</span><br><span class="line">			else i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//测试数据为ppt第40页的图，只实现了二部图的最大匹配</span><br><span class="line">	n = 12;</span><br><span class="line">	for (int k = 0; k &lt; n; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(c[k], 0, sizeof(c[0][0])*n);</span><br><span class="line">		memset(f[k], 0, sizeof(f[0][0])*n);  //初始各分支流量为0</span><br><span class="line">		memset(isMark, false, n);</span><br><span class="line">		memset(isCheck, false, n);</span><br><span class="line">	&#125;</span><br><span class="line">	isMark[0] = true; //给源做永久标记</span><br><span class="line">	markList[0].max_incr = INFI;</span><br><span class="line">	markList[0].pre_suc = INFI;</span><br><span class="line"></span><br><span class="line">	c[1][6] = INFI;</span><br><span class="line">	c[1][7] = INFI;</span><br><span class="line">	c[2][7] = INFI;</span><br><span class="line">	c[3][6] = INFI;</span><br><span class="line">	c[3][8] = INFI;</span><br><span class="line">	c[3][9] = INFI;</span><br><span class="line">	c[4][7] = INFI;</span><br><span class="line">	c[4][10] = INFI;</span><br><span class="line">	c[5][7] = INFI;</span><br><span class="line">	c[5][10] = INFI;</span><br><span class="line"></span><br><span class="line">	for (int i = 1; i &lt; n / 2; i++)</span><br><span class="line">		c[0][i] = 1;</span><br><span class="line">	for (int i = n/2; i &lt; n-1; i++)</span><br><span class="line">		c[i][n-1] = 1;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;最大匹配结果为：&quot; &lt;&lt; endl;</span><br><span class="line">	int result=	ford_fulkerson();</span><br><span class="line">	cout &lt;&lt; &quot;匹配边个数为：&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">	system(&quot;PAUSE&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/算法概论实验/算法概论实验十三/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chens">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Vendetta.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chens">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/14/算法概论实验/算法概论实验十三/" itemprop="url">算法概论实验十三</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-14T16:31:21+08:00">
                2019-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法概论实验/" itemprop="url" rel="index">
                    <span itemprop="name">算法概论实验</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">实验十三</span><br><span class="line"></span><br><span class="line">实验目的与要求：</span><br><span class="line">（1）	理解与掌握求解最大流与最小割的基本算法。</span><br><span class="line">（2）	学会应用最大流与最小割算法解决实际问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 设计与实现项目选择（Project Selection）问题的算法。</span><br><span class="line"></span><br><span class="line">2. 设计与实现调查设计（Survey Design）问题的算法。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot; </span><br><span class="line">#include &quot;iostream.h&quot; </span><br><span class="line">#define Maxint 10000 </span><br><span class="line">#define CLength 7 </span><br><span class="line"></span><br><span class="line">template&lt;class Type&gt; </span><br><span class="line"></span><br><span class="line">Type min(Type a,Type b) </span><br><span class="line">&#123; 	</span><br><span class="line">	return a&lt;b?a:b; </span><br><span class="line">&#125; </span><br><span class="line">int isnull(int mlist[],int n) </span><br><span class="line">&#123; </span><br><span class="line">	for (int j = 1; j &lt;= n;  j++) </span><br><span class="line">		if (mlist[j]&gt;0) </span><br><span class="line">			return j;  </span><br><span class="line">		return 0; </span><br><span class="line">&#125; </span><br><span class="line">void MaxFlowFF(int n,int Curf[CLength][CLength]) </span><br><span class="line">&#123;</span><br><span class="line">	//输出流Curf  </span><br><span class="line">	int i,j,tf=0; </span><br><span class="line">	for (i = 1; i &lt;= n;  i++) </span><br><span class="line">		for (j = 1; j &lt;= n;  j++) </span><br><span class="line">			if (Curf[i][j]!=0) </span><br><span class="line">			&#123; </span><br><span class="line">				</span><br><span class="line">				cout&lt;&lt;&quot;顶点&quot;&lt;&lt;i&lt;&lt;&quot;--&gt;&quot;&lt;&lt;&quot;顶点&quot;&lt;&lt;j&lt;&lt;&quot;流量:&quot;&lt;&lt;Curf[i][j]&lt;&lt;&quot;\n&quot;; </span><br><span class="line">				if (i==1) </span><br><span class="line">					tf+=Curf[i][j]; </span><br><span class="line">			&#125; </span><br><span class="line">			printf(&quot;\n当前总流量为:%d\n\n&quot;,tf); </span><br><span class="line">&#125; </span><br><span class="line">void FordFulkerson(int n,int Cap[CLength][CLength],int Curf[CLength][CLength]) </span><br><span class="line">&#123; </span><br><span class="line">	// s=1,t=n </span><br><span class="line">	// cap :弧邻接距阵及容量 u(i,j) </span><br><span class="line">	// Curf:当前流量x(i,j) </span><br><span class="line">	// maxf:增广路中间变量（节点当前流量）</span><br><span class="line">	// prev:增广路的前导节点</span><br><span class="line">	// LIST:可能增广节点</span><br><span class="line">	</span><br><span class="line">	int i,j; </span><br><span class="line">	int maxf[CLength]=&#123;Maxint&#125;,prev[CLength]=&#123;0&#125;; </span><br><span class="line">	int LIST[CLength]=&#123;0&#125;,Cut[CLength]=&#123;0&#125;; </span><br><span class="line">	maxf[n]=1; </span><br><span class="line">	bool aug=true; </span><br><span class="line">	while(maxf[n]&gt;0) // maxf[n]表示得到最大流</span><br><span class="line">	&#123; </span><br><span class="line">		// step 2 </span><br><span class="line">		// 取消所有节点标号</span><br><span class="line">		for (j = 1; j &lt;= n;  j++) </span><br><span class="line">		&#123; </span><br><span class="line">			maxf[j]=0; </span><br><span class="line">			prev[j]=0; </span><br><span class="line">			LIST[j]=0; </span><br><span class="line">		&#125; </span><br><span class="line">		LIST[1]=1; </span><br><span class="line">		maxf[1]=Maxint; </span><br><span class="line">		int temp; </span><br><span class="line">		while(true) </span><br><span class="line">		&#123; </span><br><span class="line">			//step 3 </span><br><span class="line">			// 判断LIST是否非空,非空返回第一个非空值,空则返回0 </span><br><span class="line">			temp=isnull(LIST,n); </span><br><span class="line">			// LIST非空且maxf[n]==0 </span><br><span class="line">			if(temp!=0 &amp;&amp; maxf[n]==0) </span><br><span class="line">			&#123; </span><br><span class="line">				// step 4 </span><br><span class="line">				// LIST中移走temp，并寻找从temp出发的可能增广弧 </span><br><span class="line">				LIST[temp]=0; </span><br><span class="line">				for(int k = 1; k &lt;= n;  k++) </span><br><span class="line">				&#123; </span><br><span class="line">					// 非饱和前向弧</span><br><span class="line">					if(Curf[temp][k]&lt;Cap[temp][k] &amp;&amp; prev[k]==0)// </span><br><span class="line">					&#123; </span><br><span class="line">						maxf[k]=min(maxf[temp],Cap[temp][k]-Curf[temp][k]); </span><br><span class="line">						prev[k]=temp; </span><br><span class="line">						LIST[k]=1; </span><br><span class="line">					&#125; </span><br><span class="line">					else if(Curf[k][temp]&gt;0 &amp;&amp; prev[k]==0) //非空反向弧</span><br><span class="line">					&#123; </span><br><span class="line">						maxf[k]=min(maxf[temp],Curf[k][temp]); </span><br><span class="line">						prev[k]=temp; </span><br><span class="line">						LIST[k]=1; </span><br><span class="line">					&#125; </span><br><span class="line">				&#125; </span><br><span class="line">				</span><br><span class="line">			&#125; </span><br><span class="line">			else </span><br><span class="line">			&#123; </span><br><span class="line">				// step 3a,3b </span><br><span class="line">				if(maxf[n]&gt;0) // 找到了一条增广路</span><br><span class="line">				&#123; </span><br><span class="line">					// 对增广当前流Curf </span><br><span class="line">					int pv=n;</span><br><span class="line">					while(pv!=1) </span><br><span class="line">					&#123; </span><br><span class="line">						// 非饱和前向弧</span><br><span class="line">						if(Curf[prev[pv]][pv]&lt;Cap[prev[pv]][pv]) </span><br><span class="line">							Curf[prev[pv]][pv]+=maxf[n]; </span><br><span class="line">						else if(Curf[pv][prev[pv]]&gt;0) //非空反向弧</span><br><span class="line">							Curf[pv][prev[pv]]-=maxf[n]; </span><br><span class="line">						pv=prev[pv]; </span><br><span class="line">					&#125; </span><br><span class="line">					MaxFlowFF(n,Curf); </span><br><span class="line">				&#125; </span><br><span class="line">				break; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; // end of while 2 </span><br><span class="line">	&#125; </span><br><span class="line">	// end of while 1 </span><br><span class="line">&#125; </span><br><span class="line">void main(void) </span><br><span class="line">&#123; </span><br><span class="line">	int Cap[CLength][CLength]=&#123; </span><br><span class="line">		&#123;0,0,0,0,0,0,0&#125;, </span><br><span class="line">		&#123;0,0,3,3,2,0,0&#125;, </span><br><span class="line">		&#123;0,0,0,0,0,4,0&#125;, </span><br><span class="line">		&#123;0,0,0,0,1,0,2&#125;, </span><br><span class="line">		&#123;0,0,1,0,0,0,2&#125;, </span><br><span class="line">		&#123;0,0,0,0,1,0,1&#125;, </span><br><span class="line">		&#123;0,0,0,0,0,0,0&#125;, </span><br><span class="line">	&#125;; </span><br><span class="line">	int Cf[CLength][CLength]=&#123;0&#125;; </span><br><span class="line">	int i,j; </span><br><span class="line">	int n=CLength-1; </span><br><span class="line">	FordFulkerson(n,Cap,Cf); </span><br><span class="line">	MaxFlowFF(n,Cf); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/Vendetta.jpg" alt="Chens">
            
              <p class="site-author-name" itemprop="name">Chens</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">198</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chens</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
